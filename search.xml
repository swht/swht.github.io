<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[2016/08/20 [nodejs开发书籍]MEAN Web开发]]></title>
      <url>http://blog.songqingbo.cn/2016/08/20/2016-08-20-nodejs%E5%BC%80%E5%8F%91%E4%B9%A6%E7%B1%8D-MEAN-Web%E5%BC%80%E5%8F%91/</url>
      <content type="html"><![CDATA[<p>Author:@南非波波</p>
<p><a href="http://blog.songqingbo.cn/pdf/nodejs/MEAN Web开发.pdf" title="MEAN Web开发.pdf">MEAN WEB开发</a></p>
<p>声明：本电子书为为本人从图灵社区所购，涉及版权，请读者不要私自传播。本平台仅提供在线阅读功能。如果您觉得此书帮助了您，同时也想帮作者分摊一部分电子书版权费。欢迎通过微信二维码进行资助，非常感谢。</p>
<p><img src="http://blog.songqingbo.cn/img/微信收款.png" alt="资助南非波波"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python自动化开发 day17]]></title>
      <url>http://blog.songqingbo.cn/2016/05/14/s12-20160514-day17/</url>
      <content type="html"><![CDATA[<p>Author:@南非波波</p>
<p>课程大纲：</p>
<p><a href="http://www.cnblogs.com/alex3714/articles/5474411.html" title="常用算法设计" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5474411.html</a></p>
<h2 id="一、冒泡排序算法"><a href="#一、冒泡排序算法" class="headerlink" title="一、冒泡排序算法"></a>一、冒泡排序算法</h2><pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
import random,time
#m冒泡排序

def bubble_up1(array):
    &apos;&apos;&apos;
    m冒泡排序算法
    :param array:
    :return: count: 6190862 time: 6.706383466720581
    &apos;&apos;&apos;
    count = 0
    for i in range(len(array)):
        for j in range(len(array) - 1 - i):
            if array[j] &gt; array[j + 1]:
                temp = array[j + 1]
                array[j + 1] = array[j]
                array[j] = temp
                count += 1
    print(&quot;count:&quot;, count)
    print(&quot;array:&quot;, array)

def bubble_up2(array):
    &apos;&apos;&apos;
    m冒泡排序算法
    :param array:
    :return:count: 5000 time: 3.825218915939331
    &apos;&apos;&apos;
    count = 0
    for i in range(len(array)):
        for j in range(len(array) - 1 - i):
            big_temp = j
            if array[big_temp] &gt; array[j + 1]:
                big_temp = j + 1
        temp = array[big_temp]
        array[i] = array[big_temp]
        array[big_temp] = temp
        count += 1
    print(&quot;count:&quot;, count)
    print(&quot;array:&quot;, array)


if __name__ == &apos;__main__&apos;:
    array = []
    for i in range(5000):
        array.append(random.randrange(1000))

    time_start = time.time()
    bubble_up2(array)
    time_end = time.time()
    #
    print(array[0:100])
    print(&quot;time:&quot;,time_end - time_start)
</code></pre><h2 id="二、-选择排序"><a href="#二、-选择排序" class="headerlink" title="二、 选择排序"></a>二、 选择排序</h2><pre><code>def select1(array):
    &apos;&apos;&apos;
    选择排序算法v1
    :param array:
    :return:count: 1996750 time: 3.2961885929107666
    &apos;&apos;&apos;
    count = 0
    for i in range(len(array)):
        for j in range(i,len(array)):
            if array[i] &gt; array[j]:
                temp = array[j]
                array[j] = array[i]
                array[i] = temp
                count += 1
    print(&quot;count:&quot;,count)
    print(&quot;array:&quot;,array)

def select2(array):
    &apos;&apos;&apos;
    选择排序算法v2
    :param array:
    :return:count: 5000 time: 2.4801418781280518
    &apos;&apos;&apos;
    count = 0
    for i in range(len(array)):
        smallest_index = i
        for j in range(i,len(array)):
            if array[smallest_index] &gt; array[j]:
                smallest_index = j
        temp = array[smallest_index]
        array[smallest_index] = array[i]
        array[i] = temp
        count += 1
    print(&quot;count:&quot;,count)
    print(&quot;array:&quot;,array)
</code></pre><h2 id="三、直接插入排序算法"><a href="#三、直接插入排序算法" class="headerlink" title="三、直接插入排序算法"></a>三、直接插入排序算法</h2><pre><code>def insert1(array):
    &apos;&apos;&apos;
    插入排序算法
    :param array:
    :return: count: 4999 time: 3.685210704803467
    &apos;&apos;&apos;
    count = 0
    for index in range(1, len(array)):
        current_val = array[index]  # 先记下来每次大循环走到的第几个元素的值
        position = index

        while position &gt; 0 and array[
                    position - 1] &gt; current_val:  # 当前元素的左边的紧靠的元素比它大,要把左边的元素一个一个的往右移一位,给当前这个值插入到左边挪一个位置出来
            array[position] = array[position - 1]  # 把左边的一个元素往右移一位
            position -= 1  # 只一次左移只能把当前元素一个位置 ,还得继续左移只到此元素放到排序好的列表的适当位置 为止

        array[position] = current_val  # 已经找到了左边排序好的列表里不小于current_val的元素的位置,把current_val放在这里
        count += 1
    print(&quot;count:&quot;, count)
    print(array)
</code></pre><h2 id="四、快速排序"><a href="#四、快速排序" class="headerlink" title="四、快速排序"></a>四、快速排序</h2><pre><code>def quick_sort(array,start,end):
    &apos;&apos;&apos;
    快速排序算法
    :param array:
    :param start:
    :param end:
    :return:time: 0.03600192070007324
    &apos;&apos;&apos;
    if start &gt;= end:
        return
    k = array[start]
    left_flag = start
    right_flag = end
    while left_flag &lt; right_flag:
        while array[right_flag] &gt; k:
            right_flag -= 1
        temp = array[right_flag]
        array[left_flag] = array[right_flag]
        array[right_flag] = temp

        while array[left_flag] &lt;= k:
            left_flag += 1
        temp = array[left_flag]
        array[left_flag] = array[right_flag]
        array[right_flag] = temp

    quick_sort(array,start,left_flag - 1)
    quick_sort(array,left_flag + 1,end)
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python自动化开发 day16]]></title>
      <url>http://blog.songqingbo.cn/2016/05/07/s12-20160507-day16/</url>
      <content type="html"><![CDATA[<p>Author:@南非波波</p>
<p>课程大纲：</p>
<p><a href="http://www.cnblogs.com/alex3714/articles/5457672.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5457672.html</a></p>
<h2 id="一、Django起步"><a href="#一、Django起步" class="headerlink" title="一、Django起步"></a>一、Django起步</h2><h3 id="1-创建Django项目"><a href="#1-创建Django项目" class="headerlink" title="1.创建Django项目"></a>1.创建Django项目</h3><pre><code>两种方式：使用pycharm工具进行创建
         使用manage命令进行创建
</code></pre><p><img src="http://i.imgur.com/UKdz7aG.png" alt=""></p>
<h3 id="2-url设计"><a href="#2-url设计" class="headerlink" title="2.url设计"></a>2.url设计</h3><p><img src="http://i.imgur.com/2y2zgI4.png" alt=""></p>
<h3 id="3-views视图设计"><a href="#3-views视图设计" class="headerlink" title="3.views视图设计"></a>3.views视图设计</h3><p><img src="http://i.imgur.com/M1xkgkw.png" alt=""></p>
<p><img src="http://i.imgur.com/UsZ5fay.png" alt=""></p>
<h3 id="4-Template版本设计"><a href="#4-Template版本设计" class="headerlink" title="4.Template版本设计"></a>4.Template版本设计</h3><p><img src="http://i.imgur.com/LLavnYW.png" alt=""></p>
<h2 id="二、Template模板渲染"><a href="#二、Template模板渲染" class="headerlink" title="二、Template模板渲染"></a>二、Template模板渲染</h2><h3 id="1-调用后端传递的数据"><a href="#1-调用后端传递的数据" class="headerlink" title="1.调用后端传递的数据"></a>1.调用后端传递的数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;h3&gt;username:&#123;&#123;user_obj.username&#125;&#125;&lt;/h3&gt;</div><div class="line">&lt;h3&gt;E-mail:&#123;&#123;user_obj.email&#125;&#125;&lt;/h3&gt;</div></pre></td></tr></table></figure>
<h3 id="2-使用for循环进行遍历数据"><a href="#2-使用for循环进行遍历数据" class="headerlink" title="2.使用for循环进行遍历数据"></a>2.使用for循环进行遍历数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;url&gt;</div><div class="line">    &#123;% for user_info in user_obj %&#125;</div><div class="line">    	&lt;li style=&quot;&quot;&gt;username:&#123;&#123;user_info.username&#125;&#125;,E-mail:&#123;&#123;user_info.email&#125;&#125;&lt;/li&gt;</div><div class="line">    &#123;% endfor %&#125;</div><div class="line">&lt;/url&gt;</div></pre></td></tr></table></figure>
<h3 id="3-使用if进行相关条件判断"><a href="#3-使用if进行相关条件判断" class="headerlink" title="3.使用if进行相关条件判断"></a>3.使用if进行相关条件判断</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;url&gt;</div><div class="line">	&#123;% for user_info in user_obj %&#125;</div><div class="line">	&#123;#  &#123;% if user_info.username == &quot;swht&quot; %&#125;#&#125; &lt;!--可以直接判断某个字符串，然后进行处理--&gt;</div><div class="line">    	&#123;% if forloop.counter0|divisibleby:&quot;2&quot; %&#125; &lt;!--使用forloop。counter参数获取遍历的当前数字。counter0是从0开始的索引值，divisibleby:&quot;2&quot;是指能够被2整除--&gt;</div><div class="line">        	&lt;li style=&quot;background-color: aqua&quot;&gt;username:&#123;&#123;user_info.username&#125;&#125;,E-mail:&#123;&#123;user_info.email&#125;&#125;&lt;/li&gt;</div><div class="line">        &#123;% else %&#125;</div><div class="line">            &lt;li style=&quot;&quot;&gt;username:&#123;&#123;user_info.username&#125;&#125;,E-mail:&#123;&#123;user_info.email&#125;&#125;&lt;/li&gt;</div><div class="line">        &#123;% endif %&#125;</div><div class="line"></div><div class="line">   	&#123;% endfor %&#125;</div><div class="line">&lt;/url&gt;</div></pre></td></tr></table></figure>
<h3 id="4-模板的继承与复用"><a href="#4-模板的继承与复用" class="headerlink" title="4.模板的继承与复用"></a>4.模板的继承与复用</h3><p>使用主页的头部进行继承，然后将主体进行重写</p>
<pre><code>index.html
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&#123;% block header-menu %&#125;</div><div class="line">    &lt;ul &gt;</div><div class="line">        &lt;li style=&quot;display: inline-block&quot;&gt;Home&lt;/li&gt;</div><div class="line">        &lt;li style=&quot;display: inline-block&quot;&gt;page1&lt;/li&gt;</div><div class="line">        &lt;li style=&quot;display: inline-block&quot;&gt;page2&lt;/li&gt;</div><div class="line">        &lt;li style=&quot;display: inline-block&quot;&gt;page3&lt;/li&gt;</div><div class="line">    &lt;/ul&gt;</div><div class="line">    &#123;% endblock %&#125;</div><div class="line">    &#123;% block content-container %&#125;</div><div class="line">    &lt;h2&gt;这是文章的首页&lt;/h2&gt;</div><div class="line">    &lt;!--&lt;h3&gt;username:&#123;&#123;user_obj.username&#125;&#125;&lt;/h3&gt;--&gt;</div><div class="line">    &lt;!--&lt;h3&gt;E-mail:&#123;&#123;user_obj.email&#125;&#125;&lt;/h3&gt;--&gt;</div><div class="line">    &lt;url&gt;</div><div class="line">        &#123;% for user_info in user_obj %&#125;</div><div class="line">&#123;#            &#123;% if user_info.username == &quot;swht&quot; %&#125;#&#125; &lt;!--可以直接判断某个字符串，然后进行处理--&gt;</div><div class="line">            &#123;% if forloop.counter0|divisibleby:&quot;2&quot; %&#125; &lt;!--使用forloop。counter参数获取遍历的当前数字。counter0是从0开始的索引值，divisibleby:&quot;2&quot;是指能够被2整除--&gt;</div><div class="line">                &lt;li style=&quot;background-color: aqua&quot;&gt;username:&#123;&#123;user_info.username&#125;&#125;,E-mail:&#123;&#123;user_info.email&#125;&#125;&lt;/li&gt;</div><div class="line">            &#123;% else %&#125;</div><div class="line">                &lt;li style=&quot;&quot;&gt;username:&#123;&#123;user_info.username&#125;&#125;,E-mail:&#123;&#123;user_info.email&#125;&#125;&lt;/li&gt;</div><div class="line">            &#123;% endif %&#125;</div><div class="line"></div><div class="line">        &#123;% endfor %&#125;</div><div class="line">    &lt;/url&gt;</div><div class="line">    &#123;% endblock %&#125;</div></pre></td></tr></table></figure>
<pre><code>year.html
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;% extends &apos;article/index.html&apos; %&#125;</div><div class="line">&#123;% block content-container %&#125;</div><div class="line">    &lt;h1&gt;这是&#123;&#123; year_obj.year &#125;&#125;年的文章&lt;/h1&gt;</div><div class="line">&#123;% endblock %&#125;</div></pre></td></tr></table></figure>
<p>说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% extends &apos;article/index.html&apos; %&#125; 语法是继承主页的所有属性</div><div class="line">&#123;% block content-container %&#125;</div><div class="line">&#123;% endblock%&#125;  语法说明该语块是可以被重写的</div></pre></td></tr></table></figure>
<p>模板的继承和重写支持：子继承父、孙继承子</p>
<h2 id="三、配置文件"><a href="#三、配置文件" class="headerlink" title="三、配置文件"></a>三、配置文件</h2><h3 id="1-setting文件说明"><a href="#1-setting文件说明" class="headerlink" title="1.setting文件说明"></a>1.setting文件说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))  指定了当前项目文件的基础路径</div><div class="line">SECRET_KEY = &apos;-i6p7t+w6@&amp;duki)8s88tf=_ms%@z8fz4_5g@vhvzp@tij36w$&apos; django通信KEY，我们一般不需要进行修改</div><div class="line"></div><div class="line">DEBUG = True  #选项为True时，属于开发环境，当遇到错误时会弹出默认的提示大黄页，当选项为False时，属于生产环境，需要下面的关键字进行配合设置</div><div class="line">ALLOWED_HOSTS = [] #当DEBUG = False时，ALLOWED_HOSTS = [*]，即允许所有主机访问，当访问的资源不存在时，默认会返回默认的404页面提示</div><div class="line">INSTALLED_APPS=[] #这里需要配置我们安装的应用的名称</div><div class="line">TEMPLATES = [] #这里指定项目模板的路径，一般不需要修改，但也可以自定义路径</div><div class="line">DATABASES = &#123;&#125; #这里默认使用sqlite3数据库进行存储，我们可以修改成支持的其他数据库类型</div><div class="line">TIME_ZONE = &apos;Asia/Shanghai&apos; #这里的时区参数需要选择上海时区</div></pre></td></tr></table></figure>
<h3 id="2-设置mysql数据库配置"><a href="#2-设置mysql数据库配置" class="headerlink" title="2.设置mysql数据库配置"></a>2.设置mysql数据库配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">DATABASES = &#123;</div><div class="line">    &apos;default&apos;:&#123;</div><div class="line">        &apos;ENGINE&apos;:&apos;django.db.backends.mysql&apos;,</div><div class="line">        &apos;NAME&apos;:&apos;blog&apos;,</div><div class="line">        &apos;HOST&apos;:&apos;127.0.0.1&apos;,</div><div class="line">        &apos;PORT&apos;:&apos;3306&apos;,</div><div class="line">        &apos;USER&apos;:&apos;root&apos;,</div><div class="line">        &apos;PASSWORD&apos;:&apos;&apos;,</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Windows下面安装mysql环境：http://www.cnblogs.com/songqingbo/p/5080847.html</div><div class="line"></div><div class="line">创建所需的数据库：</div><div class="line">	create database blog charset utf8;</div></pre></td></tr></table></figure>
<h3 id="3-mysql数据库初始化"><a href="#3-mysql数据库初始化" class="headerlink" title="3.mysql数据库初始化"></a>3.mysql数据库初始化</h3><pre><code>models
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Author(models.Model):</div><div class="line">    first_name = models.CharField(max_length=32)</div><div class="line">    last_name = models.CharField(max_length=32)</div><div class="line">    email = models.EmailField()</div><div class="line">    def __unicode__(self):</div><div class="line">        return &quot;&lt;%s %s&gt;&quot; %(self.first_name,self.last_name)</div><div class="line"></div><div class="line">    class Meta:</div><div class="line">        verbose_name_plural = u&quot;作者&quot;</div><div class="line">    #def __str__()</div><div class="line">class Publisher(models.Model):</div><div class="line">    name = models.CharField(max_length=64,unique=True)</div><div class="line">    address = models.CharField(max_length=128,null=True,blank=True)</div><div class="line">    city = models.CharField(max_length=64)</div><div class="line">    state_province = models.CharField(max_length=30,help_text=&quot;put your country code here..&quot;,verbose_name=u&quot;所属省&quot;)</div><div class="line">    country = models.CharField(max_length=50,editable=False)</div><div class="line">    website = models.URLField()</div><div class="line">    def __unicode__(self):</div><div class="line">        return &quot;&lt;%s&gt;&quot; %(self.name)</div><div class="line">class Book(models.Model):</div><div class="line">    name = models.CharField(max_length=128)</div><div class="line">    authors = models.ManyToManyField(Author)</div><div class="line">    publisher = models.ForeignKey(Publisher)</div><div class="line">    #publish_date = models.DateTimeField</div><div class="line">    publish_date = models.DateField()</div><div class="line">    def __unicode__(self):</div><div class="line">        return &quot;&lt;%s&gt;&quot; %(self.name)</div></pre></td></tr></table></figure>
<p>由于django需要MySQLdb进行连接mysql数据库，需要安装MySQLdb模块和vc++ for python2.7环境包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">python2 manage.py makemigrations  #生成数据库创建表文件</div><div class="line">	Migrations for &apos;article&apos;:</div><div class="line">	  0001_initial.py:</div><div class="line">	    - Create model Author</div><div class="line">	    - Create model Book</div><div class="line">	    - Create model Publisher</div><div class="line">	    - Add field publisher to book</div><div class="line">python2 manage.py migrate #将表结构写入数据库</div><div class="line">	Operations to perform:</div><div class="line">	  Apply all migrations: admin, article, contenttypes, auth, sessions</div><div class="line">	Running migrations:</div><div class="line">	  Rendering model states... DONE</div><div class="line">	  Applying contenttypes.0001_initial... OK</div><div class="line">	  Applying auth.0001_initial... OK</div><div class="line">	  Applying admin.0001_initial... OK</div><div class="line">	  Applying admin.0002_logentry_remove_auto_add... OK</div><div class="line">	  Applying article.0001_initial... OK</div><div class="line">	  Applying contenttypes.0002_remove_content_type_name... OK</div><div class="line">	  Applying auth.0002_alter_permission_name_max_length... OK</div><div class="line">	  Applying auth.0003_alter_user_email_max_length... OK</div><div class="line">	  Applying auth.0004_alter_user_username_opts... OK</div><div class="line">	  Applying auth.0005_alter_user_last_login_null... OK</div><div class="line">	  Applying auth.0006_require_contenttypes_0002... OK</div><div class="line">	  Applying auth.0007_alter_validators_add_error_messages... OK</div></pre></td></tr></table></figure>
<h3 id="4-创建后台用户"><a href="#4-创建后台用户" class="headerlink" title="4.创建后台用户"></a>4.创建后台用户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">admin.py</div><div class="line">	#增加下面的语句作用是使用admin后台进行数据库的管理操作</div><div class="line">	import models</div><div class="line">	admin.site.register(models.Author)</div><div class="line">	admin.site.register(models.Book)</div><div class="line">	admin.site.register(models.Publisher)</div><div class="line">python2 manage.py createsuperuser #创建一个超级用户</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/Foh6exY.png" alt="Django后台增加数据"></p>
<h2 id="四、使用django命令对数据库进行基础操作"><a href="#四、使用django命令对数据库进行基础操作" class="headerlink" title="四、使用django命令对数据库进行基础操作"></a>四、使用django命令对数据库进行基础操作</h2><h3 id="1-进入python-django-shell"><a href="#1-进入python-django-shell" class="headerlink" title="1. 进入python django shell"></a>1. 进入python django shell</h3><pre><code>shell&gt;&gt;python2 manage.py shell
</code></pre><h3 id="2-查询数据"><a href="#2-查询数据" class="headerlink" title="2. 查询数据"></a>2. 查询数据</h3><pre><code>\&gt;&gt;&gt;from article.models import Publisher

\&gt;&gt;&gt;publisher_list = Publisher.objects.all() #查询所有的出版社列表

\&gt;&gt;&gt;publisher_list[1].name  #查询第2个出版社的名称

\&gt;&gt;&gt;publisher_list[1].id  #查询第2个出版社的id
</code></pre><h3 id="3-增加一条数据"><a href="#3-增加一条数据" class="headerlink" title="3. 增加一条数据"></a>3. 增加一条数据</h3><pre><code>\&gt;&gt;&gt; p1 = Publisher.objects.create(name=&apos;SWht&apos;,address=&apos;haidian&apos;,city=&apos;beijing&apos;,state_province=&apos;CA&apos;,country=&apos;CN&apos;,website=&apos;http://www.songqingbo.cn&apos;)

\&gt;&gt;&gt;p2 = Publisher(name=&apos;SWht2&apos;,address=&apos;haidian1&apos;,city=&apos;beijing&apos;,state_province=&apos;CA&apos;,country=&apos;CN&apos;,website=&apos;http://www.songqingbo.cn&apos;)

\&gt;&gt;&gt;p2.save()  #增加数据两种方式，1.使用对象的objects的create方法进行数据的创建，2.使用对象的save方法进行数据的保存。
</code></pre><h3 id="4-数据库过滤查询"><a href="#4-数据库过滤查询" class="headerlink" title="4. 数据库过滤查询"></a>4. 数据库过滤查询</h3><pre><code>\&gt;&gt;&gt; from article.models import Author

\&gt;&gt;&gt; author_list = Author.objects.all()

\&gt;&gt;&gt; author_list

[&lt;Author: &lt;shen test&gt;&gt;, &lt;Author: &lt;alix sds&gt;&gt;]

\&gt;&gt;&gt; Author.objects.filter(first_name=&apos;shen&apos;)

[&lt;Author: &lt;shen test&gt;&gt;]
</code></pre><h3 id="5-获取单个对象"><a href="#5-获取单个对象" class="headerlink" title="5. 获取单个对象"></a>5. 获取单个对象</h3><pre><code>\&gt;&gt;&gt; Author.objects.get(first_name=&apos;shen&apos;)

&lt;Author: &lt;shen test&gt;&gt;

\&gt;&gt;&gt; Author.objects.get(id=&apos;1&apos;)

&lt;Author: &lt;shen test&gt;&gt;

\&gt;&gt;&gt; Author.objects.get(id=&apos;2&apos;)

&lt;Author: &lt;alix sds&gt;&gt;

注意：如果查询没有返回结果也会抛出异常
</code></pre><h3 id="6-数据排序"><a href="#6-数据排序" class="headerlink" title="6. 数据排序"></a>6. 数据排序</h3><pre><code>\&gt;&gt;&gt; Author.objects.order_by(&quot;first_name&quot;)

[&lt;Author: &lt;alix sds&gt;&gt;, &lt;Author: &lt;shen test&gt;&gt;]

\&gt;&gt;&gt; Author.objects.order_by(&quot;id&quot;)

[&lt;Author: &lt;shen test&gt;&gt;, &lt;Author: &lt;alix sds&gt;&gt;]
</code></pre><h3 id="7-数据更新"><a href="#7-数据更新" class="headerlink" title="7. 数据更新"></a>7. 数据更新</h3><pre><code>\&gt;&gt;&gt; author = Author.objects.get(last_name=&apos;test&apos;)

\&gt;&gt;&gt; author.last_name = &apos;diaoxia&apos;

\&gt;&gt;&gt; author.save()

\&gt;&gt;&gt; Author.objects.all()

[&lt;Author: &lt;shen diaoxia&gt;&gt;, &lt;Author: &lt;alix sds&gt;&gt;]
</code></pre><h3 id="8-删除对象"><a href="#8-删除对象" class="headerlink" title="8. 删除对象"></a>8. 删除对象</h3><pre><code>\&gt;&gt;&gt; author = Author.objects.get(first_name=&apos;alix&apos;)

\&gt;&gt;&gt; author

&lt;Author: &lt;alix sds&gt;&gt;

\&gt;&gt;&gt; author.delete()

(2L, {u&apos;article.Book_authors&apos;: 1L, u&apos;article.Author&apos;: 1L})

\&gt;&gt;&gt; Author.objects.all()

[&lt;Author: &lt;shen diaoxia&gt;&gt;]
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python自动化开发 day15]]></title>
      <url>http://blog.songqingbo.cn/2016/04/30/s12-20160430-day15/</url>
      <content type="html"><![CDATA[<p>Author:@南非波波</p>
<p>课程大纲：</p>
<p><a href="http://www.cnblogs.com/wupeiqi/articles/4491246.html" target="_blank" rel="external">http://www.cnblogs.com/wupeiqi/articles/4491246.html</a><br><a href="http://www.cnblogs.com/wupeiqi/articles/4508271.html" target="_blank" rel="external">http://www.cnblogs.com/wupeiqi/articles/4508271.html</a></p>
<h2 id="一、前端设计"><a href="#一、前端设计" class="headerlink" title="一、前端设计"></a>一、前端设计</h2><h3 id="1-实现图片轮播"><a href="#1-实现图片轮播" class="headerlink" title="1.实现图片轮播"></a>1.实现图片轮播</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">js下载地址：</div><div class="line">	http://bxslider.com/</div><div class="line">引入</div><div class="line">	&lt;!-- jQuery library (served from Google) --&gt;</div><div class="line">	&lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">	&lt;!-- bxSlider Javascript file --&gt;</div><div class="line">	&lt;script src=&quot;/js/jquery.bxslider.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">	&lt;!-- bxSlider CSS file --&gt;</div><div class="line">	&lt;link href=&quot;/lib/jquery.bxslider.css&quot; rel=&quot;stylesheet&quot; /&gt;</div><div class="line">加载图片：</div><div class="line">	&lt;ul class=&quot;bxslider&quot;&gt;</div><div class="line">	  &lt;li&gt;&lt;img src=&quot;/images/pic1.jpg&quot; /&gt;&lt;/li&gt;</div><div class="line">	  &lt;li&gt;&lt;img src=&quot;/images/pic2.jpg&quot; /&gt;&lt;/li&gt;</div><div class="line">	  &lt;li&gt;&lt;img src=&quot;/images/pic3.jpg&quot; /&gt;&lt;/li&gt;</div><div class="line">	  &lt;li&gt;&lt;img src=&quot;/images/pic4.jpg&quot; /&gt;&lt;/li&gt;</div><div class="line">	&lt;/ul&gt;</div><div class="line"></div><div class="line">调用：	</div><div class="line">	$(document).ready(function()&#123;</div><div class="line">	  $(&apos;.bxslider&apos;).bxSlider();</div><div class="line">	&#125;);</div></pre></td></tr></table></figure>
<h3 id="2-图标资源"><a href="#2-图标资源" class="headerlink" title="2.图标资源"></a>2.图标资源</h3><pre><code>Font Awesome
   http://fontawesome.io/
   a、图片，自己找图片，挖洞
   b、现成的图标
       css
       使用样式
       --以前版本
           css
           图片库
           使用样式
       -- 现在
           css
           字体文件
           使用样式
   c、css
       字体文件
       样式
   =====》 大图片
</code></pre><h3 id="3-伪类"><a href="#3-伪类" class="headerlink" title="3.伪类"></a>3.伪类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;响应式&lt;/title&gt;</div><div class="line">    &lt;style&gt;</div><div class="line">        @media (min-width: 768px) &#123;</div><div class="line">            .lead &#123;</div><div class="line">                background-color: red;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        .c1 &#123;</div><div class="line">            background-color: green;</div><div class="line">            &#125;</div><div class="line">        .clearfix:after &#123;</div><div class="line">            content: &quot;.&quot;;</div><div class="line">            clear: both;</div><div class="line">            visibility: hidden;</div><div class="line">        &#125;</div><div class="line">    &lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line"></div><div class="line">    &lt;dev class=&quot;lead&quot;&gt;</div><div class="line">        我们都是中国人</div><div class="line">    &lt;/dev&gt;</div><div class="line"></div><div class="line">    &lt;div class=&quot;c1 clearfix&quot;&gt;</div><div class="line">        &lt;div style=&quot;float: right;&quot;&gt;</div><div class="line">            你好</div><div class="line">        &lt;/div&gt;</div><div class="line">         &lt;div style=&quot;float: right;&quot;&gt;</div><div class="line">             china</div><div class="line">        &lt;/div&gt;</div><div class="line">         &lt;!--&lt;div style=&quot;clear: both&quot;&gt;&lt;/div&gt;--&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line"></div><div class="line"></div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h2 id="二、web框架"><a href="#二、web框架" class="headerlink" title="二、web框架"></a>二、web框架</h2><h3 id="1-python-web框架分类"><a href="#1-python-web框架分类" class="headerlink" title="1.python web框架分类"></a>1.python web框架分类</h3><pre><code>#!/usr/bin/env python
#coding:utf-8

import socket

def handle_request(client):
    buf = client.recv(1024)
    client.send(&quot;HTTP/1.1 200 OK\r\n\r\n&quot;)
    client.send(&quot;Hello, Seven&quot;)

def main():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.bind((&apos;localhost&apos;,8000))
    sock.listen(5)

    while True:
        connection, address = sock.accept()
        handle_request(connection)
        connection.close()

if __name__ == &apos;__main__&apos;:
    main()
</code></pre><h3 id="2-MVC-web框架"><a href="#2-MVC-web框架" class="headerlink" title="2.MVC web框架"></a>2.MVC web框架</h3><pre><code>MVC：Models  Views Controllers

        数据库操作 模板  处理请求的函数
代码块的归类结构

MTV：Models Templates Views

    数据库操作 模板  处理请求的函数
</code></pre><h3 id="3-Django基础"><a href="#3-Django基础" class="headerlink" title="3.Django基础"></a>3.Django基础</h3><pre><code>Django框架属于MTV框架。程序需要的操作的：
    1.models
    2.Templates
    3.Views
    4.urls
</code></pre><h2 id="三、Django"><a href="#三、Django" class="headerlink" title="三、Django"></a>三、Django</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><pre><code>pip install django 1.9.5
</code></pre><h3 id="2-创建Django程序框架"><a href="#2-创建Django程序框架" class="headerlink" title="2.创建Django程序框架"></a>2.创建Django程序框架</h3><pre><code>使用命令创建
    django-admin startproject demo 创建projects
    cd demo
    python manage.py startapp app0 创建应用
使用pycharm进行创建项目和应用
</code></pre><h3 id="3-执行程序"><a href="#3-执行程序" class="headerlink" title="3.执行程序"></a>3.执行程序</h3><pre><code>进入项目， python manage.py runserver 127.0.0.1：8000
</code></pre><h3 id="4-创建数据表"><a href="#4-创建数据表" class="headerlink" title="4.创建数据表"></a>4.创建数据表</h3><pre><code>python manage.py makemigrations #生成配置文件
python manage.py migrate       #根据配置文件创建数据库相关 表
</code></pre><h3 id="5-django默认后台管理"><a href="#5-django默认后台管理" class="headerlink" title="5.django默认后台管理"></a>5.django默认后台管理</h3><pre><code>创建超级用户名 python manage.py createsuperuser
</code></pre><h3 id="6-路由系统"><a href="#6-路由系统" class="headerlink" title="6.路由系统"></a>6.路由系统</h3><pre><code>静态路由
动态路由
    安照顺序，第n个匹配的数据交给函数的第n个参数，严格按照顺序
        url(r&apos;^page/（\d+)/(\d+)&apos;,views.page)
    模板的方法，将匹配的参数，传给指定的形式参数
        url(r&apos;^page/(?P&lt;n1&gt;\d+)/(?P&lt;n2&gt;\d+)&apos;,views.page)
二级路由
    app01
        urls.py
    project name 
        URL：app01 -&gt;include（&quot;app01.urls&quot;）
</code></pre><p><img src="http://i.imgur.com/QbaeTDM.png" alt=""></p>
<h3 id="7-基本数据库操作"><a href="#7-基本数据库操作" class="headerlink" title="7.基本数据库操作"></a>7.基本数据库操作</h3><pre><code>ORM框架
    code first
        自己写类 --&gt;数据库表
    db first
        自己写命令操作数据库--&gt;更新类
    使用类进行数据操作

创建类
    from django.db import models
    class UserInfo(models.Model):
        username = models.CharField(max_length=32)
        password = models.CharField(max_length=32)
        age = models.IntegerField()

配置
    setting
        INSTALLED_APPS = [
            &apos;django.contrib.admin&apos;,
            &apos;django.contrib.auth&apos;,
            &apos;django.contrib.contenttypes&apos;,
            &apos;django.contrib.sessions&apos;,
            &apos;django.contrib.messages&apos;,
            &apos;django.contrib.staticfiles&apos;,
            &apos;app01&apos;,
        ]
使用命令根据类创建表
    python manage.py makemigrations #生成配置文件
    python manage.py migrate       #根据配置文件创建数据库相关 表
默认表名：
    appname_classname

d. 
    views中导入models

e.
    POST提交数据
        settings里操作：
            MIDDLEWARE_CLASSES = [
                &apos;django.middleware.security.SecurityMiddleware&apos;,
                &apos;django.contrib.sessions.middleware.SessionMiddleware&apos;,
                &apos;django.middleware.common.CommonMiddleware&apos;,
               # &apos;django.middleware.csrf.CsrfViewMiddleware&apos;,
                &apos;django.contrib.auth.middleware.AuthenticationMiddleware&apos;,
                &apos;django.contrib.auth.middleware.SessionAuthenticationMiddleware&apos;,
                &apos;django.contrib.messages.middleware.MessageMiddleware&apos;,
                &apos;django.middleware.clickjacking.XFrameOptionsMiddleware&apos;,
            ]
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python自动化开发 day14]]></title>
      <url>http://blog.songqingbo.cn/2016/04/21/s12-20160421-day14/</url>
      <content type="html"><![CDATA[<p>Author:@南非波波</p>
<p>课程大纲：</p>
<p><a href="http://www.cnblogs.com/wupeiqi/articles/5369773.html" target="_blank" rel="external">http://www.cnblogs.com/wupeiqi/articles/5369773.html</a></p>
<p><a href="http://www.php100.com/manual/jquery/" target="_blank" rel="external">http://www.php100.com/manual/jquery/</a></p>
<h2 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h2><h3 id="1-查找"><a href="#1-查找" class="headerlink" title="1.查找"></a>1.查找</h3><h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><pre><code>$(&apos;#nid&apos;)  根据id找到某个标签
$(&apos;.nid&apos;)  根据class查找
$(&apos;.nid div #nid&apos;)  根据class查找下面的div标签下面的id
$(&apos;.nid,div,#nid&apos;)  查找到class或div或id条件的查找到
$(&apos;li:eq(0)&apos;)  查到到第一个li标签行
</code></pre><h4 id="筛选器"><a href="#筛选器" class="headerlink" title="筛选器"></a>筛选器</h4><pre><code>$(&apos;li&apos;).eq(0)  查到到第一个li标签行
</code></pre><h2 id="2-操作"><a href="#2-操作" class="headerlink" title="2.操作"></a>2.操作</h2><p>属性</p>
<pre><code>添加指定属性，并删除兄弟的属性
 $(ths).addClass(&apos;current&apos;).siblings().removeClass(&apos;current&apos;);

attr：
    其他所有标签都适用，除checkbox、redio之外
prop：
    checkbox、redio

jQuery循环：

    var userList = [&apos;swht&apos;,&apos;shen&apos;,&apos;test&apos;];
    $.each(userList,fun(i,item){
        console.log(i,item);
    })    
</code></pre><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>文档处理</p>
<pre><code>增加
append(content|fn)
    在指定的标签内部后面追加
appendTo(content)
    把指定的某个标签追加某个标签内部后面
prepend(content|fn)
    在指定的标签内部前面追加
prependTo(content)
    把指定的某个标签追加某个标签内部前面
包裹
wrap(html|ele|fn)
unwrap()
wrapAll(html|ele)
wrapInner(html|ele|fn)

删除
empty()
remove([expr])
detach([expr])
复制
clone([Even[,deepEven]])
</code></pre><p>事件</p>
<pre><code>绑定事件：
    1. 直接绑定ready(fn) 文本加载完之后执行事件绑定
        1. $(document).ready(function(){

            })
        2. $(function(){

            })
    2. 委派delegate(s,[t],[d],fn)
        1. $(&apos;ul&apos;).delegate(&apos;li&apos;,&apos;click&apos;,function(){

           })

    3. bind(type,[data],fn)
        1. $(&apos;li&apos;).click(function(){

            })
        2. $(&apos;li&apos;).bind(&apos;click&apos;)
        3. unbind
</code></pre><p>AJAX</p>
<pre><code>异步的javascript和xml
ajax是对javascript和Dom的封装。
ajax容易出现跨域的问题。
$.ajax({
    url:&quot;&quot;,
    data:{},
    type:&quot;&quot;,
    dateType:&quot;&quot;,
    jsonp:&quot;&quot;,
    jsonpCallback:&quot;&quot;,
    sucess:function(){},
    error:function(){}
})
</code></pre><p>JQuery扩展</p>
<pre><code>(function(arg){
    arg.extend({
      qinghua: function() {
        return &quot;SB&quot;;
      },
      qinghua1: function() {
        return this.each(function() { this.checked = false; });
      }
    });

    arg.fn.extend({
       sanjiang:function(){
           return &quot;DSB&quot;
       }
    });
})(jQuery);
</code></pre><p>其他</p>
<p>30款最好的 Bootstrap 3.0 免费主题和模板<br><a href="http://www.cnblogs.com/lhb25/p/30-free-bootstrap-templates.html" target="_blank" rel="external">http://www.cnblogs.com/lhb25/p/30-free-bootstrap-templates.html</a></p>
<p>例子：</p>
<pre><code>tab菜单

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;tab&lt;/title&gt;
    &lt;style&gt;
        .tab-box .box-menu{
            background-color: #DDDDDD;
            border: 1px solid #DDDDDD;
            height: 33px;
            line-height: 33px;
        }
        .box-menu a{
            border-right: 1px solid #664747;
            padding: 10px;
            background-color: #425a66;;
        }
        .tab-box .box-body{
            border: 1px solid #dddddd;
        }
        .hide{
            display: none;
        }
         .current{
            background-color: white;
            color: black;
            border-top: 2px solid red;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;tab-box&quot;&gt;
        &lt;div class=&quot;box-menu&quot;&gt;
            &lt;!--所有菜单--&gt;
            &lt;a menu1=&quot;c1&quot; onclick=&quot;ChangeTab(this);&quot; class=&quot;current&quot;&gt;菜单一&lt;/a&gt;
            &lt;a menu1=&quot;c2&quot; onclick=&quot;ChangeTab(this);&quot;&gt;菜单二&lt;/a&gt;
            &lt;a menu1=&quot;c3&quot; onclick=&quot;ChangeTab(this);&quot;&gt;菜单三&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class=&quot;box-body&quot;&gt;
            &lt;!--所有内容--&gt;
            &lt;div id=&quot;c1&quot;&gt;内容一&lt;/div&gt;
            &lt;div id=&quot;c2&quot; class=&quot;hide&quot;&gt;内容二&lt;/div&gt;
            &lt;div id=&quot;c3&quot; class=&quot;hide&quot;&gt;内容三&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;script src=&quot;jquery-2.2.3.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        function ChangeTab(ths){
            $(ths).addClass(&apos;current&apos;).siblings().removeClass(&apos;current&apos;);
            var contentId = $(ths).attr(&apos;menu1&apos;);
            var temp = &quot;#&quot; + contentId;
            $(temp).removeClass(&apos;hide&apos;).siblings().addClass(&apos;hide&apos;);

        }
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;


全选、反选、取消

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;全选、反选、取消&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;
        &lt;input type=&quot;button&quot; value=&quot;全选&quot; onclick=&quot;selectAll();&quot; /&gt;
        &lt;input type=&quot;button&quot; value=&quot;反选&quot; onclick=&quot;selectInvert();&quot; /&gt;
        &lt;input type=&quot;button&quot; value=&quot;取消&quot; onclick=&quot;clearAll();&quot; /&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;table border=&quot;1&quot;&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;input type=&quot;checkbox&quot; /&gt;
                &lt;/td&gt;
                &lt;td&gt;
                    第一章
                &lt;/td&gt;
                &lt;td&gt;
                    第一篇
                &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;input type=&quot;checkbox&quot; /&gt;
                &lt;/td&gt;
                &lt;td&gt;
                    第二章
                &lt;/td&gt;
                &lt;td&gt;
                    第一篇
                &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;input type=&quot;checkbox&quot; /&gt;
                &lt;/td&gt;
                &lt;td&gt;
                   第三章
                &lt;/td&gt;
                &lt;td&gt;
                    第一篇
                &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;input type=&quot;checkbox&quot; /&gt;
                &lt;/td&gt;
                &lt;td&gt;
                   第四章
                &lt;/td&gt;
                &lt;td&gt;
                    第一篇
                &lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;
    &lt;/div&gt;

    &lt;script src=&quot;jquery-2.2.3.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        function selectAll(){
            $(&quot;table input[type=&apos;checkbox&apos;]&quot;).prop(&apos;checked&apos;,true);
        }
        function selectInvert(){
            $(&quot;table input[type=&apos;checkbox&apos;]&quot;).each(function(){
               var isChecked = $(this).prop(&apos;checked&apos;);
                if(isChecked){
                    $(this).prop(&apos;checked&apos;,false);
                }else{
                    $(this).prop(&apos;checked&apos;,true);
                }
            });
        }
        function clearAll(){
            $(&quot;table input[type=&apos;checkbox&apos;]&quot;).prop(&apos;checked&apos;,false);
        }
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;


ajax_jsonp

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;ajax_jsonp&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;input type=&quot;button&quot; value=&quot;获取电视节目&quot; onclick=&quot;Ajax_jsonp();&quot;/&gt;
    &lt;dev id=&quot;contaner&quot;&gt;

    &lt;/dev&gt;
    &lt;script src=&quot;jquery-2.2.3.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        function Ajax_jsonp(){
            $.ajax({
                url:&quot;http://www.jxntv.cn/data/jmd-jxtv2.html&quot;,
                data:{},
                type:&quot;GET&quot;,
                dataType:&quot;jsonp&quot;,
                jsonp:&quot;callback&quot;,
                jsonpCallback:&quot;list&quot;,
                success:function(arg){
                    console.log(arg);
                    var jsonArray = arg.data;
                    $.each(jsonArray,function(k,v){
                        var week = v.week;
                        var label = &quot;&lt;h1&gt;&quot; + week + &quot;&lt;/h1&gt;&quot;;
                        $(&quot;#contaner&quot;).append(label);
                        var listArray = v.list;
                        $.each(listArray,function(kk,vv){
                            var link = vv.link;
                            var name = vv.name;
                            var time = vv.time;
                            var labelNew = &quot;&lt;a href=&apos;&quot; + link + &quot;&apos;&gt;&quot; + time+name + &quot;&lt;/a&gt;&lt;br/&gt;&quot;;
                            $(&quot;#contaner&quot;).append(labelNew);
                        })
                    })
                },
                error:function(arg){
                    console.log(arg);
                }
            })
        }
    &lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python自动化开发 day13]]></title>
      <url>http://blog.songqingbo.cn/2016/04/09/s12-20160409-day13/</url>
      <content type="html"><![CDATA[<p>Author:@南非波波</p>
<p>课程大纲：</p>
<p>day13</p>
<p><a href="http://www.cnblogs.com/wupeiqi/articles/5369773.html" target="_blank" rel="external">http://www.cnblogs.com/wupeiqi/articles/5369773.html</a></p>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><pre><code>js    
    使页面动起来的一门语言，解释器就是浏览器的引擎
dom
    提供一套api
jQuery
    封装的JS和dom的类库
</code></pre><h2 id="二、javaScript"><a href="#二、javaScript" class="headerlink" title="二、javaScript"></a>二、javaScript</h2><pre><code>1. 存在形式：
    文件
    标签
2. 放置位置：
    原则上可以存在head 和body，但是当页面请求不到js的时候就会一直在等待。建议将js代码放在body底部
3. 声明变量：
    name = &quot;swht&quot;;  //全局变量
    age = 18;   //局部变量    

4. 注释：
    当行注释：  //
    多行注释：    /*  ..  */
    每行代码结束需要加分号(;)
5. 类型：
    数字                
    字符串
    数组（字典）
6. 类型转换：
    var age = 18；
    var age = Number(18)；

    Number(&quot;123&quot;);
    parseInt(&apos;123&apos;);  //将字符串转换成数字类型
    var num = 18.9;
    num1 = parseInt(num); //将数字类型转换成整型数字输出
    num2 = parseFloat(num); //将数字类型转换成浮点型数字输出
    console.log(&quot;num1:&quot;,num1,typeof num1,&quot;num2:&quot;,num2,typeof num2); //控制台打印转换后的值和类型
    //输出结果：num1: 18 number num2: 18.9 number
7. 控制台打印：
    var age = &quot;18&quot;; 
    var n1 = 1,n2 = 3,n3 = 4; //单行可以声明多个变量并赋值
    console.log(age,typeof age); //控制台输出变量的值和类型
</code></pre><h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><pre><code>1. 去除字符串左右空格：        
    var name = &quot;swht   &quot;;
    name.trim();    
2. 按索引取值：
    var name = &quot;swht&quot;;
    name.charAt(1);
3. search:
    name.search(&quot;w&quot;);  //返回字符所在的索引值
4. split：
    name.split(&quot;&quot;);  //将字符串转换成数组
    [&quot;s&quot;, &quot;w&quot;, &quot;h&quot;, &quot;t&quot;, &quot; &quot;, &quot; &quot;, &quot; &quot;]
5. xx
</code></pre><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var li1 = [11,22,33,44];</div><div class="line">for (var index in li1)&#123;</div><div class="line">console.log(index);</div><div class="line">&#125;</div><div class="line"></div><div class="line">for (var i = 0;i &lt; li1.length;i++)&#123;</div><div class="line">console.log(i,li1[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var dict = &#123;&quot;name&quot;:&quot;swht&quot;,&quot;age&quot;:18,&quot;work&quot;:&quot;运维&quot;&#125;</div><div class="line">for (var item in dict)&#123;</div><div class="line">console.log(item,dict[item]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><pre><code>while(true){
    countine;
    break;
}
</code></pre><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><pre><code>var name = &apos;1&apos;;
switch (name){
    case &quot;1&quot;:
        console.log(1);
        break;
    case &quot;2&quot;:
        console.log(2);
        break;
    case &quot;3&quot;:
        console.log(3);
        break;
    default:
        console.log(&apos;default&apos;);
        break;
}
</code></pre><h4 id="if条件句"><a href="#if条件句" class="headerlink" title="if条件句"></a>if条件句</h4><pre><code>var name = &quot;swht&quot;;
if (name == &quot;alex&quot;){
    console.log(err);
}else if (name == &quot;hh&quot;){
    console.log(true);
}else {
    console.log(&quot;你逗呢！&quot;);
}
</code></pre><h4 id="try"><a href="#try" class="headerlink" title="try"></a>try</h4><pre><code>var name = &quot;swht&quot;;
try {
    if (name == &quot;shen&quot;){
        console.log(&quot;err&quot;);
    }else {
        console.log(&quot;false&quot;);
    }
}catch (e){
    console.log(e);
}finally {
    console.log(&quot;finally&quot;);
}
</code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><pre><code>//函数的声明
function func1(arg){
    return true;
}
//匿名函数
var func2 = function(arg){
    return true;
}
//自执行函数，一般用在jq封装类库时使用
(function(arg){
    console.log(arg);
})(&apos;123&apos;)
</code></pre><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><pre><code>function Foo(name,age){
this.Name = name;
this.Age = age;
this.Func = function(arg){
    return this.Name +arg;
}
}
var obj = new Foo(&apos;swht&apos;,22)
console.log(obj.Name);
console.log(obj.Age);
var ret = obj.Func(&apos;haha&apos;);
console.log(ret);
</code></pre><h2 id="三、Dom"><a href="#三、Dom" class="headerlink" title="三、Dom"></a>三、Dom</h2><p>文档对象模型（Document Object Model，DOM）是一种用于HTML和XML文档的编程接口。它给文档提供了一种结构化的表示方法，可以改变文档的内容和呈现方式。我们最为关心的是，DOM把网页和脚本以及其他的编程语言联系了起来。DOM属于浏览器，而不是JavaScript语言规范里的规定的核心内容。</p>
<p>注：一般说的JS让页面动起来泛指JavaScript和Dom</p>
<h3 id="1-选择器"><a href="#1-选择器" class="headerlink" title="1.选择器"></a>1.选择器</h3><pre><code>document.getElementById(&apos;id&apos;);
document.getElementsByName(&apos;name&apos;);
document.getElementsByTagName(&apos;tagname&apos;);
</code></pre><h3 id="2-内容"><a href="#2-内容" class="headerlink" title="2.内容"></a>2.内容</h3><pre><code>innerText
innerHTML

var obj = document.getElementById(&apos;nid&apos;)
obj.innerText                       # 获取文本内容
obj.innerText = &quot;hello&quot;             # 设置文本内容
obj.innerHTML                       # 获取HTML内容
obj.innerHTML = &quot;&lt;h1&gt;asd&lt;/h1&gt;&quot;      # 设置HTML内容


特殊的：
    input系列
    textarea标签
    select标签

    value属性操作用户输入和选择的值
</code></pre><h3 id="3-创建标签"><a href="#3-创建标签" class="headerlink" title="3.创建标签"></a>3.创建标签</h3><pre><code>方式一：
    var obj = document.createElement(&apos;a&apos;);
    obj.href = &quot;http://www.apicloud.com&quot;;
    obj.innerText = &quot;APICloud&quot;;

    var container = document.getElementById(&apos;container&apos;);
    //container.appendChild(obj);
    //container.insertBefore(obj, container.firstChild);
    //container.insertBefore(obj, document.getElementById(&apos;hhh&apos;));

方式二：
    var container = document.getElementById(&apos;container&apos;);
    var obj = &quot;&lt;input  type=&apos;text&apos; /&gt;&quot;;
    container.innerHTML = obj;
    // &apos;beforeBegin&apos;, &apos;afterBegin&apos;, &apos;beforeEnd&apos;,  &apos;afterEnd&apos;
    //container.insertAdjacentHTML(&quot;beforeEnd&quot;,obj);
</code></pre><h3 id="4-标签属性"><a href="#4-标签属性" class="headerlink" title="4.标签属性"></a>4.标签属性</h3><pre><code>var obj = document.getElementById(&apos;container&apos;);
固定属性
    obj.id
    obj.id = &quot;nid&quot;
    obj.className
    obj.style.fontSize = &quot;88px&quot;;

自定义属性
    obj.setAttribute(name,value)
    obj.getAttribute(name)
    obj.removeAttribute(name)
</code></pre><h3 id="5-提交表单"><a href="#5-提交表单" class="headerlink" title="5.提交表单"></a>5.提交表单</h3><pre><code>document.geElementById(&apos;form&apos;).submit()
</code></pre><h3 id="6-事件"><a href="#6-事件" class="headerlink" title="6.事件"></a>6.事件</h3><p><img src="http://i.imgur.com/aP6MTMY.png" alt=""></p>
<h3 id="7-其他功能"><a href="#7-其他功能" class="headerlink" title="7.其他功能"></a>7.其他功能</h3><pre><code>console.log()
alert()
confirm()

// URL和刷新
location.href
location.href = &quot;url&quot;  window.location.reload()

// 定时器
setInterval(&quot;alert()&quot;,2000);   
clearInterval(obj)
setTimeout();   
clearTimeout(obj)
</code></pre><p>示例：</p>
<pre><code>跑马灯

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;欢迎南非波波同志成为本届董事长&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;input type=&quot;button&quot; onclick=&quot;DropInterval();&quot; value=&quot;停止滚动&quot; /&gt;
        &lt;script&gt;
            obj1 = setInterval(&quot;GunDong()&quot;,1000);
            console.log(obj1);
            function DropInterval(){
                   clearInterval(obj1);
            }
            function GunDong(){
                var text = document.title;
                var firstWord = text.charAt(0);
                var subWord = text.substring(1,text.length);
                var newWord = subWord + firstWord;
                document.title = newWord;
            }
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;

搜索框

&lt;input type=&quot;text&quot; placeholder=&quot;请输入关键字&quot; id=&quot;search&quot; onfocus=&quot;Focus();&quot; onblur=&quot;Blur();&quot;/&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    function Focus(){
        var nid = document.getElementById(&quot;search&quot;);
        var value = nid.placeholder;
        if (value == &quot;请输入关键字&quot;){
            nid.placeholder = &quot;&quot;;
        }
    }

    function Blur(){
        var nid = document.getElementById(&quot;search&quot;);
        var value = nid.placeholder;
        if (!value.trim()){
            nid.placeholder = &quot;请输入关键字&quot;;
        }
    }
&lt;/script&gt;
</code></pre><h2 id="四、jQuery"><a href="#四、jQuery" class="headerlink" title="四、jQuery"></a>四、jQuery</h2><h3 id="1-选择器："><a href="#1-选择器：" class="headerlink" title="1.选择器："></a>1.选择器：</h3><pre><code>#id
element
.class
*
selector1,selector2,selectorN
</code></pre><p><img src="http://i.imgur.com/fhuW9MD.png" alt=""></p>
<p>示例：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;Title&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div&gt;
           &lt;div id=&quot;n1&quot;&gt;11&lt;/div&gt;
            &lt;div class=&quot;c1&quot;&gt;22&lt;/div&gt;
            &lt;div  class=&quot;c1&quot;&gt;33&lt;/div&gt;
            &lt;a&gt;&lt;/a&gt;
            &lt;span id=&quot;n2&quot;&gt;&lt;/span&gt;

            &lt;div id=&quot;n3&quot;&gt;
                &lt;div&gt;
                    &lt;div class=&quot;c3&quot;&gt;
                        &lt;span&gt;
                            &lt;a class=&quot;c4&quot;&gt;asdf&lt;/a&gt;
                        &lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;span&gt;asdf&lt;/span&gt;
            &lt;/div&gt;

        &lt;/div&gt;

        &lt;script src=&quot;jquery-2.2.3.js&quot;&gt;&lt;/script&gt;
        &lt;script&gt;
            /*
            选择器基础使用
             */
            $(&quot;#n1&quot;).text(&quot;中国好声音&quot;);
            $(&quot;.c1&quot;).text(&quot;欢迎三江同学&quot;);
            $(&quot;.c4&quot;).text(&quot;一不小心挂掉了&quot;);
            $(&quot;#n3 span&quot;).text(&quot;游泳冠军&quot;);

        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="2-筛选器"><a href="#2-筛选器" class="headerlink" title="2.筛选器"></a>2.筛选器</h3><p><img src="http://i.imgur.com/x7Jqi96.jpg" alt=""></p>
<h3 id="3-属性、CSS"><a href="#3-属性、CSS" class="headerlink" title="3.属性、CSS"></a>3.属性、CSS</h3><p><img src="http://i.imgur.com/mPoLfMu.png" alt="">    </p>
<h3 id="4-文档处理"><a href="#4-文档处理" class="headerlink" title="4.文档处理"></a>4.文档处理</h3><p><img src="http://i.imgur.com/8YcX0EW.png" alt=""></p>
<h3 id="5-事件"><a href="#5-事件" class="headerlink" title="5.事件"></a>5.事件</h3><p><img src="http://i.imgur.com/p53Uf3n.png" alt=""></p>
<p><strong>作业</strong></p>
<ol>
<li>jQuery API文档阅读</li>
<li>博客实例阅读练习</li>
<li>列表处理、登录方式</li>
<li>主机管理列表可编辑</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python自动化开发 day10]]></title>
      <url>http://blog.songqingbo.cn/2016/03/19/s12-20160319-day10/</url>
      <content type="html"><![CDATA[<p>Author:@南非波波</p>
<p>课程大纲：</p>
<p>day09</p>
<p><a href="http://www.cnblogs.com/alex3714/articles/5248247.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5248247.html</a></p>
<p>day10</p>
<p><a href="http://www.cnblogs.com/alex3714/articles/5286889.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5286889.html
</a></p>
<h2 id="一、回顾"><a href="#一、回顾" class="headerlink" title="一、回顾"></a>一、回顾</h2><h3 id="1-队列"><a href="#1-队列" class="headerlink" title="1.    队列"></a>1.    队列</h3><pre><code>1.    队列的作业就是实现多个线程之间数据安全的交互
2.    队列类型：先进先出、后进先出、优先级
3.    queue的数据必须按照顺序进行取出--&gt;处理--&gt;放回。主要作用就是不同进程之间数据的交换，manager可以进行多个进程之间的数据的共享，而且是数据安全的。
4.    生产者-消费者模型：实现程序的松耦合
</code></pre><h3 id="2-gevent模块：对Greenlet模块的一次封装"><a href="#2-gevent模块：对Greenlet模块的一次封装" class="headerlink" title="2. gevent模块：对Greenlet模块的一次封装"></a>2. gevent模块：对Greenlet模块的一次封装</h3><pre><code>1. gevent里面的socket本身可以实现IO阻塞变成非阻塞
2. monkey.path_all()可以帮助我们实现阻塞变成非阻塞
</code></pre><h3 id="3-协程"><a href="#3-协程" class="headerlink" title="3. 协程"></a>3. 协程</h3><pre><code>1. 实现单个线程里面的并发
2. 无需线程上下文切换的开销，无需原子操作锁定及同步的开销，方便切换控制流，高并发+高扩展性+低成本
3. 无法利用多核资源，但是可以实现单个进程下面起一个线程，然后一个线程下面实现多个协程并发
</code></pre><h3 id="4-select"><a href="#4-select" class="headerlink" title="4. select"></a>4. select</h3><p><img src="http://i.imgur.com/SpEkQHr.png" alt=""></p>
<pre><code>1. select 与poll的区别

    select有一个最大文件数的限制1024，文件扫描一个列表是非常低效的；poll没有这个限制
    内核态到用户态的数据copy；Epoll直接调用C语言进行内核态的数据nat到用户态

2.    select代码注释


    __auther__ = &apos;Victor&apos;

    import select
    import socket
    import sys
    import queue

    # 创建一个TCP/IP socket
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setblocking(False)
    # 绑定socket到指定端口
    server_address = (&apos;localhost&apos;, 10000)
    print(sys.stderr, &apos;starting up on %s port %s&apos; % server_address)
    server.bind(server_address)
    # 监听连接的地址
    server.listen(5)
    inputs = [server]
    # Socket的读操作
    outputs = []
    # socket的写操作
    message_queues = {}
    while inputs:
    # Wait for at least one of the sockets to be ready for processing
    print( &apos;\nwaiting for the next event&apos;)
    readable, writable, exceptional = select.select(inputs, outputs, inputs)
    # 监听句柄序列，如果某个发生变化，select的第一个rLest会拿到数据，output只要有数据wLest就能获取到，select的第三个参数inputs用来监测异常，并赋值给exceptional。
    # 监听inputs，outputs，inputs  如果他们的值有变化，就将分别赋值给readable，writable，exceptional。
    for s in readable:
    # 遍历readable的值。
    if s is server:
    connection, client_address = s.accept()
    # 如果s 是server，那么server socket将接收连接。
    print(&apos;new connection from&apos;, client_address)
    # 打印出连接客户端的地址。
    connection.setblocking(False)
    # 设置socket 为非阻塞模式。
    inputs.append(connection)
    # 因为有读操作发生，所以将此连接加入inputs
    message_queues[connection] = queue.Queue()
    # 为每个连接创建一个queue队列。使得每个连接接收到正确的数据。
    else:
    data = s.recv(1024)
    # 如果s不是server，说明客户端连接来了，那么就接受客户端的数据。
    if data:
    # 如果接收到客户端的数据
    print(sys.stderr, &apos;received &quot;%s&quot; from %s&apos; % (data, s.getpeername()) )
    message_queues[s].put(data)
    # 将收到的数据放入队列中
    if s not in outputs:
    outputs.append(s)
    # 将socket客户端的连接加入select的output中，并且用来返回给客户端数据。
    else:
    print(&apos;closing&apos;, client_address, &apos;after reading no data&apos;)
    # 如果没有收到客户端发来的空消息，则说明客户端已经断开连接。
    if s in outputs:
    outputs.remove(s)
    # 既然客户端都断开了，我就不用再给它返回数据了，所以这时候如果这个客户端的连接对象还在outputs列表中，就把它删掉
    inputs.remove(s)
    # inputs中也删除掉
    s.close()
    # 把这个连接关闭掉
    del message_queues[s]
    # 删除此客户端的消息队列

    for s in writable:
    # 遍历output的数据
    try:
    next_msg = message_queues[s].get_nowait()
    except queue.Empty:
    # 获取对应客户端消息队列中的数据，如果队列中的数据为空，从消息队列中移除此客户端连接。
    print(&apos;output queue for&apos;, s.getpeername(), &apos;is empty&apos;)
    outputs.remove(s)
    else:
    print( &apos;sending &quot;%s&quot; to %s&apos; % (next_msg, s.getpeername()))
    s.send(next_msg)
    # 如果消息队列有数据，则发送给客户端。
    for s in exceptional:
    # 处理 &quot;exceptional conditions&quot;
    print(&apos;handling exceptional condition for&apos;, s.getpeername() )
    inputs.remove(s)
    # 取消对出现异常的客户端的监听
    if s in outputs:
    outputs.remove(s)
    # 移除客户端的连接对象。
    s.close()
    # 关闭此socket连接
    del message_queues[s]
    # 删除此消息队列。

    &apos;&apos;&apos;

    在select/poll时代，服务器进程每次都把这100万个连接告诉操作系统(从用户态复制句柄数据结构到内核态)，让操作系统内核去查询这些套接字上是否有事件发生，

    轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll一般只能处理几千的并发连接。

    epoll的设计和实现与select完全不同。epoll通过在Linux内核中申请一个简易的文件系统(文件系统一般用什么数据结构实现？B+树)。把原先的select/poll调用分成了3个部分：

    1）调用epoll_create()建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源)

    2）调用epoll_ctl向epoll对象中添加这100万个连接的套接字

    3）调用epoll_wait收集发生的事件的连接

    &apos;&apos;&apos;


3.    epoll代码注释

    __auther__ = &apos;Victor&apos;


    #--------------这是一个epoll的例子--------------


    import socket, select
    # &apos;windows&apos;下不支持&apos;epoll&apos;

    EOL1 = b&apos;\n\n&apos;
    EOL2 = b&apos;\n\r\n&apos;
    response = b&apos;HTTP/1.0 200 OK\r\nDate: Mon, 1 Jan 1996 01:01:01 GMT\r\n&apos;
    response += b&apos;Content-Type: text/plain\r\nContent-Length: 13\r\n\r\n&apos;
    response += b&apos;Hello, world!&apos;

    serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    serversocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    serversocket.bind((&apos;0.0.0.0&apos;, 8080))
    serversocket.listen(1)
    # 建立socket连接。
    serversocket.setblocking(0)
    # 因为socket本身是阻塞的，setblocking（0）使得socket不阻塞

    epoll = select.epoll()
    # 创建一个eopll对象
    epoll.register(serversocket.fileno(), select.EPOLLIN)
    # 在服务器端socket上面注册对读event的关注，一个读event随时会触发服务器端socket去接收一个socket连接。

    try:
       connections = {}; requests = {}; responses = {}
    # 生成3个字典，connection字典是存储文件描述符映射到他们相应的网络连接对象
       while True:
          events = epoll.poll(1)
    # 查询epoll对象，看是否有任何关注的event被触发，参数‘1’表示，会等待一秒来看是否有event发生，如果有任何感兴趣的event发生在这次查询之前，这个查询就会带着这些event的列表立即返回
          for fileno, event in events:
            # event作为一个序列（fileno，event code）的元组返回，fileno是文件描述符的代名词，始终是一个整数。
             if fileno == serversocket.fileno():
                # 如果一个读event在服务器端socket发生，就会有一个新的socket连接可能被创建。
                connection, address = serversocket.accept()
                # 服务器端开始接收连接和客户端地址
                connection.setblocking(0)
                # 设置新的socket为非阻塞模式
                epoll.register(connection.fileno(), select.EPOLLIN)
                # 为新的socket注册对读（EPOLLIN）event的关注
                connections[connection.fileno()] = connection
                requests[connection.fileno()] = b&apos;&apos;
                responses[connection.fileno()] = response
             elif event &amp; select.EPOLLIN:
                requests[fileno] += connections[fileno].recv(1024)
                # 如果发生一个读event，就读取从客户端发过来的数据。
                if EOL1 in requests[fileno] or EOL2 in requests[fileno]:
                   epoll.modify(fileno, select.EPOLLOUT)
                # 一旦完成请求已经收到，就注销对读event的关注，注册对写（EPOLLOUT）event的关注，写event发生的时候，会回复数据给客户端。
                   print(&apos;-&apos;*40 + &apos;\n&apos; + requests[fileno].decode()[:-2])
                # 打印完整的请求，证明虽然与客户端的通信是交错进行的，但是数据可以作为一个整体来组装和处理。
             elif event &amp; select.EPOLLOUT:
                # 如果一个写event在一个客户端socket上面发生，他会接受新的数据以便发送到客户端。
                byteswritten = connections[fileno].send(responses[fileno])
                responses[fileno] = responses[fileno][byteswritten:]
                if len(responses[fileno]) == 0:
                    # 每次发送一部分响应数据，直到完整的响应数据都已经发送给操作系统等待传输给客户端。
                   epoll.modify(fileno, 0)
                # 一旦完整的响应数据发送完成，就不再关注读或者写event。
                   connections[fileno].shutdown(socket.SHUT_RDWR)
                # 如果一个连接显式关闭，那么socket shutdown是可选的，在这里这样使用，是为了让客户端首先关闭。
                # shutdown调用会通知客户端socket没有更多的数据应该被发送或者接收，并会让功能正常的客户端关闭自己的socket连接。
             elif event &amp; select.EPOLLHUP:
                # HUP挂起event表明客户端socket已经断开（即关闭），所以服务器端也需要关闭，没有必要注册对HUP event的关注，在socket上面，他们总是会被epoll对象注册。
                epoll.unregister(fileno)
                # 注销对此socket连接的关注。
                connections[fileno].close()
                # 关闭socket连接。
                del connections[fileno]
    finally:
       epoll.unregister(serversocket.fileno())
    # 去掉已经注册的文件句柄
       epoll.close()
    # 关闭epoll对象
       serversocket.close()
    # 关闭服务器连接
    # 打开的socket连接不需要关闭，因为Python会在程序结束时关闭， 这里的显示关闭是个好的习惯。

    &apos;&apos;&apos;

    首先我们来定义流的概念，一个流可以是文件，socket，pipe等等可以进行I/O操作的内核对象。

        不管是文件，还是套接字，还是管道，我们都可以把他们看作流。

        之后我们来讨论I/O的操作，通过read，我们可以从流中读入数据；通过write，我们可以往流写入数据。现在假定一个情形，
        我们需要从流中读数据，但是流中还没有数据，（典型的例子为，客户端要从socket读如数据，但是服务器还没有把数据传回来），
        这时候该怎么办？

    阻塞：阻塞是个什么概念呢？比如某个时候你在等快递，但是你不知道快递什么时候过来，而且你没有别的事可以干（或者说接下来的事要等快递来了才能做）；
    那么你可以去睡觉了，因为你知道快递把货送来时一定会给你打个电话（假定一定能叫醒你）。

    非阻塞忙轮询：接着上面等快递的例子，如果用忙轮询的方法，那么你需要知道快递员的手机号，然后每分钟给他挂个电话：“你到了没？”

        很明显一般人不会用第二种做法，不仅显很无脑，浪费话费不说，还占用了快递员大量的时间。

        大部分程序也不会用第二种做法，因为第一种方法经济而简单，经济是指消耗很少的CPU时间，如果线程睡眠了，就掉出了系统的调度队列，暂时不会去瓜分CPU宝贵的时间片了。

        为了了解阻塞是如何进行的，我们来讨论缓冲区，以及内核缓冲区，最终把I/O事件解释清楚。缓冲区的引入是为了减少频繁I/O操作而引起频繁的系统调用（你知道它很慢的），
        当你操作一个流时，更多的是以缓冲区为单位进行操作，这是相对于用户空间而言。对于内核来说，也需要缓冲区。

    假设有一个管道，进程A为管道的写入方，Ｂ为管道的读出方。

    假设一开始内核缓冲区是空的，B作为读出方，被阻塞着。然后首先A往管道写入，这时候内核缓冲区由空的状态变到非空状态，内核就会产生一个事件告诉Ｂ该醒来了，
    这个事件姑且称之为“缓冲区非空”。

        但是“缓冲区非空”事件通知B后，B却还没有读出数据；且内核许诺了不能把写入管道中的数据丢掉这个时候，Ａ写入的数据会滞留在内核缓冲区中，如果内核也缓冲区满了，
        B仍未开始读数据，最终内核缓冲区会被填满，这个时候会产生一个I/O事件，告诉进程A，你该等等（阻塞）了，我们把这个事件定义为“缓冲区满”。

    假设后来Ｂ终于开始读数据了，于是内核的缓冲区空了出来，这时候内核会告诉A，内核缓冲区有空位了，你可以从长眠中醒来了，继续写数据了，我们把这个事件叫做“缓冲区非满”

        也许事件Y1已经通知了A，但是A也没有数据写入了，而Ｂ继续读出数据，知道内核缓冲区空了。这个时候内核就告诉B，你需要阻塞了！，我们把这个时间定为“缓冲区空”。

    这四个情形涵盖了四个I/O事件，缓冲区满，缓冲区空，缓冲区非空，缓冲区非满（注都是说的内核缓冲区，且这四个术语都是我生造的，仅为解释其原理而造）。
    这四个I/O事件是进行阻塞同步的根本。（如果不能理解“同步”是什么概念，请学习操作系统的锁，信号量，条件变量等任务同步方面的相关知识）。

        然后我们来说说阻塞I/O的缺点。但是阻塞I/O模式下，一个线程只能处理一个流的I/O事件。如果想要同时处理多个流，要么多进程(fork)，要么多线程(pthread_create)，
        很不幸这两种方法效率都不高。

        于是再来考虑非阻塞忙轮询的I/O方式，我们发现我们可以同时处理多个流了（把一个流从阻塞模式切换到非阻塞模式再此不予讨论）：

    while true {
        for i in stream[]; {
            if i has data
                read until unavailable
        }
    }

        我们只要不停的把所有流从头到尾问一遍，又从头开始。这样就可以处理多个流了，但这样的做法显然不好，因为如果所有的流都没有数据，那么只会白白浪费CPU。
        这里要补充一点，阻塞模式下，内核对于I/O事件的处理是阻塞或者唤醒，而非阻塞模式下则把I/O事件交给其他对象（后文介绍的select以及epoll）处理甚至直接忽略。

        为了避免CPU空转，可以引进了一个代理（一开始有一位叫做select的代理，后来又有一位叫做poll的代理，不过两者的本质是一样的）。这个代理比较厉害，
        可以同时观察许多流的I/O事件，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流
        （于是我们可以把“忙”字去掉了）。代码长这样:

    while true {
        select(streams[])
        for i in streams[] {
            if i has data
                read until unavailable
        }
    }

        于是，如果没有I/O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知道了，有I/O事件发生了，但却并不知道是那几个流
        （可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。

        但是使用select，我们有O(n)的无差别轮询复杂度，同时处理的流越多，没一次无差别轮询时间就越长。再次

    说了这么多，终于能好好解释epoll了

        epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll之会把哪个流发生了怎样的I/O事件通知我们。此时我们对这些流的操作都是有意义的。
        （复杂度降低到了O(1)）

        在讨论epoll的实现细节之前，先把epoll的相关操作列出：

          epoll_create 创建一个epoll对象，一般epollfd = epoll_create()

          epoll_ctl （epoll_add/epoll_del的合体），往epoll对象中增加/删除某一个流的某一个事件

    比如

    epoll_ctl(epollfd, EPOLL_CTL_ADD, socket, EPOLLIN);//注册缓冲区非空事件，即有数据流入

    epoll_ctl(epollfd, EPOLL_CTL_DEL, socket, EPOLLOUT);//注册缓冲区非满事件，即流可以被写入

    epoll_wait(epollfd,...)等待直到注册的事件发生

    （注：当对一个非阻塞流的读写发生缓冲区满或缓冲区空，write/read会返回-1，并设置errno=EAGAIN。而epoll只关心缓冲区非满和缓冲区非空事件）。

    一个epoll模式的代码大概的样子是：
    while true {
        active_stream[] = epoll_wait(epollfd)
        for i in active_stream[] {
            read or write till
        }
    }
    &apos;&apos;&apos;
</code></pre><h2 id="二、Twsited异步网络框架"><a href="#二、Twsited异步网络框架" class="headerlink" title="二、Twsited异步网络框架"></a>二、Twsited异步网络框架</h2><h3 id="1-事件驱动"><a href="#1-事件驱动" class="headerlink" title="1.    事件驱动"></a>1.    事件驱动</h3><pre><code>将自定义的类和函数注册到事件列表中，事件驱动框架就会自行去列表中获取事件并执行。

第一，注册事件；第二，触发事件
![](http://i.imgur.com/6brDszu.png)
</code></pre><p>示例代码：</p>
<pre><code>#event_drive.py

#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
&apos;&apos;&apos;
模拟twsited异步网络框架的流程
&apos;&apos;&apos;
#创建一个事件列表
event_list = []

#创建一个事件驱动动作
def run():
    for event in event_list:
        obj = event()
        obj.execute()

#创建事件定义规则，用户将自定义事件注册到事件列表中需要继承此类
class BaseHandler(object):
    &quot;&quot;&quot;
    用户必须继承该类，从而规范所有类的方法（类似于接口的功能）
    &quot;&quot;&quot;
    def execute(self):
        raise Exception(&apos;you must overwrite execute&apos;)


#event_run.py


#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
import event_drive

#自定义事件，继承事件驱动自定义类
class MyHandler(event_drive.BaseHandler):

    #重写执行函数
    def execute(self):
        print(&apos;event-drive execute MyHandler&apos;)
class YourHandler(event_drive.BaseHandler):

    def execute(self):
        print(&apos;event-drive ezecute YourHandler&apos;)

event_drive.event_list.append(MyHandler) #将事件注册到事件列表中
event_drive.event_list.append(YourHandler)
event_drive.run()
</code></pre><h3 id="2-Twisted框架"><a href="#2-Twisted框架" class="headerlink" title="2.    Twisted框架"></a>2.    Twisted框架</h3><pre><code>Echo_server

    #!/usr/local/env python3
    &apos;&apos;&apos;
    Author:@南非波波
    Blog:http://www.cnblogs.com/songqingbo/
    E-mail:qingbo.song@gmail.com
    &apos;&apos;&apos;
    from twisted.internet import protocol
    from twisted.internet import reactor

    class Echo(protocol.Protocol):
        &apos;&apos;&apos;
        定义一个类，处理客户端传递的数据
        &apos;&apos;&apos;
        def dataReceived(self, data):
            &apos;&apos;&apos;
            一旦接收到客户端传递的数据就要调用该方法
            :param data: 客户端传递过来的数据，python3版本传递的数据需要转换成bytes
            :return: 返回的数据是将客户端传递过来的数据返回给客户端
            &apos;&apos;&apos;
            print(&quot;Client said:&quot;,data)
            self.transport.write(data)

    def main():
        &apos;&apos;&apos;
        主函数，程序执行时直接从该函数调用事件类
        :return:
        &apos;&apos;&apos;
        factory = protocol.ServerFactory() #定义基础工厂类
        factory.protocol = Echo #相当于socketserver中的Handler方法，工厂协议直接引用自定义的Echo类

        reactor.listenTCP(5000,factory) #reactor自动重复去做一件事情。使用listenTCP监听端口
        reactor.run() #运行

    if __name__ == &apos;__main__&apos;:
        main()


Echo_client:

    #!/usr/local/env python3
    &apos;&apos;&apos;
    Author:@南非波波
    Blog:http://www.cnblogs.com/songqingbo/
    E-mail:qingbo.song@gmail.com
    &apos;&apos;&apos;
    from twisted.internet import reactor, protocol


    # a client protocol

    class EchoClient(protocol.Protocol):
        &apos;&apos;&apos;
        客户端Echo事件
        &apos;&apos;&apos;
        def connectionMade(self):
            &apos;&apos;&apos;
            连接建立执行该方法，客户端发送数据
            :return:
            &apos;&apos;&apos;
            self.transport.write(b&quot;hello alex!&quot;)

        def dataReceived(self, data):
            &apos;&apos;&apos;
            客户端接收服务端的数据
            :param data:
            :return:
            &apos;&apos;&apos;
            print(&quot;Server said:&quot;, data)
            self.transport.loseConnection()
        def connectionLost(self, reason):
            &apos;&apos;&apos;
            客户端接收完数据断开连接，主动执行该方法断开连接
            :param reason:
            :return:
            &apos;&apos;&apos;
            print(&quot;connection lost&quot;)

    class EchoFactory(protocol.ClientFactory):
        &apos;&apos;&apos;
        自定义工厂类，继承prorocol.ClientFactory类
        &apos;&apos;&apos;
        protocol = EchoClient #hanld。自己重写了protocol类

        def clientConnectionFailed(self, connector, reason):
            print(&quot;Connection failed - goodbye!&quot;)
            reactor.stop()

        def clientConnectionLost(self, connector, reason):
            print(&quot;Connection lost - goodbye!&quot;)
            reactor.stop()


    # this connects the protocol to a server running on port 8000
    def main():
        f = EchoFactory()
        reactor.connectTCP(&quot;localhost&quot;, 5000, f)
        reactor.run()

    # this only runs if the module was *not* imported
    if __name__ == &apos;__main__&apos;:
        main()
</code></pre><h3 id="3-深入学习"><a href="#3-深入学习" class="headerlink" title="3.深入学习"></a>3.深入学习</h3><p><a href="http://blog.csdn.net/hanhuili/article/details/9389433" target="_blank" rel="external">http://blog.csdn.net/hanhuili/article/details/9389433</a> </p>
<p><a href="http://krondo.com/an-introduction-to-asynchronous-programming-and-twisted/" target="_blank" rel="external">http://krondo.com/an-introduction-to-asynchronous-programming-and-twisted/</a> </p>
<h3 id="三、非关系型数据库"><a href="#三、非关系型数据库" class="headerlink" title="三、非关系型数据库"></a>三、非关系型数据库</h3><h3 id="1-Redis"><a href="#1-Redis" class="headerlink" title="1.    Redis"></a>1.    Redis</h3><p>参考：<a href="http://www.cnblogs.com/wupeiqi/articles/5132791.html" target="_blank" rel="external">http://www.cnblogs.com/wupeiqi/articles/5132791.html</a></p>
<pre><code>数据（键值对）存储在内存中，一个独立的内存管理器，可以使多个程序共享数据    

默认是非持久化的，但是可以在配置文件中进行设置

1. redis基础使用

        cli&gt;keys * #查看所有的键
        cli&gt;set name swht ex 5 #设置一个键值对，其有效时间为5秒
        cli&gt;get name #获取键值

2. redis连接

        import redis
        redis_cli = redis.Redis(&quot;localhost&quot;)
        print(redis_cli.get(&apos;name&apos;)) #b&apos;swht&apos;  get方法只能获取字符
3. redis连接池

        import redis
        pool = redis.ConnectionPool(host = &apos;localhost&apos;,port = 6379)
        redis_cli = redis.Redis(connection_pool=pool)
        redis_cli.set(&apos;age&apos;,56)
        print(redis_cli.get(&apos;age&apos;)) #b&apos;56&apos;
4. 操作

    set(name, value, ex=None, px=None, nx=False, xx=False)

        在Redis中设置值，默认，不存在则创建，存在则修改
        参数：
             ex，过期时间（秒）
             px，过期时间（毫秒）
             nx，如果设置为True，则只有name不存在时，当前set操作才执行
             xx，如果设置为True，则只有name存在时，岗前set操作才执行
    setnx(name, value)

        设置值，只有name不存在时，执行设置操作（添加）
    setex(name, value, time)

        # 设置值
        # 参数：
            # time，过期时间（数字秒 或 timedelta对象）
    psetex(name, time_ms, value)

        # 设置值
        # 参数：
            # time_ms，过期时间（数字毫秒 或 timedelta对象）
    mset(*args, **kwargs)

        批量设置值
        如：
            mset(k1=&apos;v1&apos;, k2=&apos;v2&apos;)
            或
            mget({&apos;k1&apos;: &apos;v1&apos;, &apos;k2&apos;: &apos;v2&apos;})
    get(name)

        获取值
    mget(keys, *args)

        批量获取
        如：
            mget(&apos;ylr&apos;, &apos;wupeiqi&apos;)
            或
            r.mget([&apos;ylr&apos;, &apos;wupeiqi&apos;])
    getset(name, value)

        设置新值并获取原来的值
    getrange(key, start, end)


        # 获取子序列（根据字节获取，非字符）
        # 参数：
            # name，Redis 的 name
            # start，起始位置（字节）
            # end，结束位置（字节）
        # 如： &quot;武沛齐&quot; ，0-3表示 &quot;武&quot;
    setrange(name, offset, value)

        # 修改字符串内容，从指定字符串索引开始向后替换（新值太长时，则向后添加）
        # 参数：
            # offset，字符串的索引，字节（一个汉字三个字节）
            # value，要设置的值
    setbit(name, offset, value)    
        # 对name对应值的二进制表示的位进行操作

        # 参数：
            # name，redis的name
            # offset，位的索引（将值变换成二进制后再进行索引）
            # value，值只能是 1 或 0

        # 注：如果在Redis中有一个对应： n1 = &quot;foo&quot;，
                那么字符串foo的二进制表示为：01100110 01101111 01101111
            所以，如果执行 setbit(&apos;n1&apos;, 7, 1)，则就会将第7位设置为1，
                那么最终二进制则变成 01100111 01101111 01101111，即：&quot;goo&quot;

        # 扩展，转换二进制表示：

            # source = &quot;武沛齐&quot;
            source = &quot;foo&quot;

            for i in source:
                num = ord(i)
                print bin(num).replace(&apos;b&apos;,&apos;&apos;)

            特别的，如果source是汉字 &quot;武沛齐&quot;怎么办？
            答：对于utf-8，每一个汉字占 3 个字节，那么 &quot;武沛齐&quot; 则有 9个字节
               对于汉字，for循环时候会按照 字节 迭代，那么在迭代时，将每一个字节转换 十进制数，然后再将十进制数转换成二进制    
    假定统计UV，使用setbit可以进行相应UV数统计。

        #!/usr/local/env python3
        &apos;&apos;&apos;
        Author:@南非波波
        Blog:http://www.cnblogs.com/songqingbo/
        E-mail:qingbo.song@gmail.com
        &apos;&apos;&apos;
        import redis

        pool = redis.ConnectionPool(host = &apos;localhost&apos;,port = 6379)
        redis_cli = redis.Redis(connection_pool=pool)
        redis_cli.setbit(&apos;ip&apos;,5,1)
        redis_cli.setbit(&apos;ip&apos;,45,1)
        redis_cli.setbit(&apos;ip&apos;,15,1)
        redis_cli.setbit(&apos;ip&apos;,45,1)
        print(&quot;uv_count:&quot;,redis_cli.bitcount(&apos;ip&apos;))    
    getbit(name, offset)


        # 获取name对应的值的二进制表示中的某位的值 （0或1）
        bitcount(key, start=None, end=None)

        # 获取name对应的值的二进制表示中 1 的个数
        # 参数：
            # key，Redis的name
            # start，位起始位置
            # end，位结束位置
    bitop(operation, dest, *keys)

        # 获取多个值，并将值做位运算，将最后的结果保存至新的name对应的值

        # 参数：
            # operation,AND（并） 、 OR（或） 、 NOT（非） 、 XOR（异或）
            # dest, 新的Redis的name
            # *keys,要查找的Redis的name

        # 如：
            bitop(&quot;AND&quot;, &apos;new_name&apos;, &apos;n1&apos;, &apos;n2&apos;, &apos;n3&apos;)
            # 获取Redis中n1,n2,n3对应的值，然后讲所有的值做位运算（求并集），然后将结果保存 new_name 对应的值中
    strlen(name)

        # 返回name对应值的字节长度（一个汉字3个字节）
    incr(self, name, amount=1)

        做pv统计比较有用
        # 自增 name对应的值，当name不存在时，则创建name＝amount，否则，则自增。

        # 参数：
            # name,Redis的name
            # amount,自增数（必须是整数）

        # 注：同incrby
    incrbyfloat(self, name, amount=1.0)

        # 自增 name对应的值，当name不存在时，则创建name＝amount，否则，则自增。

        # 参数：
            # name,Redis的name
            # amount,自增数（浮点型）
    decr(self, name, amount=1)

        # 自减 name对应的值，当name不存在时，则创建name＝amount，否则，则自减。

        # 参数：
            # name,Redis的name
            # amount,自减数（整数）
    append(key, value)

        # 在redis name对应的值后面追加内容

        # 参数：
            key, redis的name
            value, 要追加的字符串        

5. Hash操作

    hset(name, key, value)

        # name对应的hash中设置一个键值对（不存在，则创建；否则，修改）

        # 参数：
            # name，redis的name
            # key，name对应的hash中的key
            # value，name对应的hash中的value

        # 注：
            # hsetnx(name, key, value),当name对应的hash中不存在当前key时则创建（相当于添加）
    hmset(name, mapping)

        # 在name对应的hash中批量设置键值对

        # 参数：
            # name，redis的name
            # mapping，字典，如：{&apos;k1&apos;:&apos;v1&apos;, &apos;k2&apos;: &apos;v2&apos;}

        # 如：
            # r.hmset(&apos;xx&apos;, {&apos;k1&apos;:&apos;v1&apos;, &apos;k2&apos;: &apos;v2&apos;})
    hget(name,key)

        # 在name对应的hash中获取根据key获取value
        hmget(name, keys, *args)

        # 在name对应的hash中获取多个key的值

        # 参数：
            # name，reids对应的name
            # keys，要获取key集合，如：[&apos;k1&apos;, &apos;k2&apos;, &apos;k3&apos;]
            # *args，要获取的key，如：k1,k2,k3

        # 如：
            # r.mget(&apos;xx&apos;, [&apos;k1&apos;, &apos;k2&apos;])
            # 或
            # print r.hmget(&apos;xx&apos;, &apos;k1&apos;, &apos;k2&apos;)
    hgetall(name)

        获取name对应hash的所有键值
    hlen(name)

        # 获取name对应的hash中键值对的个数
    hkeys(name)

        # 获取name对应的hash中所有的key的值
    hvals(name)

        # 获取name对应的hash中所有的value的值
    hexists(name, key)

        # 检查name对应的hash是否存在当前传入的key
    hdel(name,*keys)

        # 将name对应的hash中指定key的键值对删除
    hincrby(name, key, amount=1)

        # 自增name对应的hash中的指定key的值，不存在则创建key=amount
        # 参数：
            # name，redis中的name
            # key， hash对应的key
            # amount，自增数（整数）
    hincrbyfloat(name, key, amount=1.0)

        # 自增name对应的hash中的指定key的值，不存在则创建key=amount

        # 参数：
            # name，redis中的name
            # key， hash对应的key
            # amount，自增数（浮点数）

        # 自增name对应的hash中的指定key的值，不存在则创建key=amount
    hscan(name, cursor=0, match=None, count=None)

        # 增量式迭代获取，对于数据大的数据非常有用，hscan可以实现分片的获取数据，并非一次性将数据全部获取完，从而放置内存被撑爆

        # 参数：
            # name，redis的name
            # cursor，游标（基于游标分批取获取数据）
            # match，匹配指定key，默认None 表示所有的key
            # count，每次分片最少获取个数，默认None表示采用Redis的默认分片个数

        # 如：
            # 第一次：cursor1, data1 = r.hscan(&apos;xx&apos;, cursor=0, match=None, count=None)
            # 第二次：cursor2, data1 = r.hscan(&apos;xx&apos;, cursor=cursor1, match=None, count=None)
            # ...
            # 直到返回值cursor的值为0时，表示数据已经通过分片获取完毕
    hscan_iter(name, match=None, count=None)

        # 利用yield封装hscan创建生成器，实现分批去redis中获取数据

        # 参数：
            # match，匹配指定key，默认None 表示所有的key
            # count，每次分片最少获取个数，默认None表示采用Redis的默认分片个数

        # 如：
            # for item in r.hscan_iter(&apos;xx&apos;):
            #     print item
6. List操作

    lpush(name,values)

        # 在name对应的list中添加元素，每个新的元素都添加到列表的最左边

        # 如：
            # r.lpush(&apos;oo&apos;, 11,22,33)
            # 保存顺序为: 33,22,11

        # 扩展：
            # rpush(name, values) 表示从右向左操作
    lpushx(name,value)

        # 在name对应的list中添加元素，只有name已经存在时，值添加到列表的最左边

        # 更多：
            # rpushx(name, value) 表示从右向左操作
    llen(name)

        # name对应的list元素的个数
    linsert(name, where, refvalue, value))

        # 在name对应的列表的某一个值前或后插入一个新值

        # 参数：
            # name，redis的name
            # where，BEFORE或AFTER
            # refvalue，标杆值，即：在它前后插入数据
            # value，要插入的数据
    r.lset(name, index, value)

        # 对name对应的list中的某一个索引位置重新赋值

        # 参数：
            # name，redis的name
            # index，list的索引位置
            # value，要设置的值
    r.lrem(name, value, num)

        # 在name对应的list中删除指定的值

        # 参数：
            # name，redis的name
            # value，要删除的值
            # num，  num=0，删除列表中所有的指定值；
                   # num=2,从前到后，删除2个；
                   # num=-2,从后向前，删除2个
    lpop(name)

        # 在name对应的列表的左侧获取第一个元素并在列表中移除，返回值则是第一个元素

        # 更多：
            # rpop(name) 表示从右向左操作
    lindex(name, index)

        在name对应的列表中根据索引获取列表元素
    lrange(name, start, end)

        # 在name对应的列表分片获取数据
        # 参数：
            # name，redis的name
            # start，索引的起始位置
            # end，索引结束位置
    ltrim(name, start, end)

        # 在name对应的列表中移除没有在start-end索引之间的值
        # 参数：
            # name，redis的name
            # start，索引的起始位置
            # end，索引结束位置
    rpoplpush(src, dst)

        # 从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边
        # 参数：
            # src，要取数据的列表的name
            # dst，要添加数据的列表的name
    blpop(keys, timeout)

        # 将多个列表排列，按照从左到右去pop对应列表的元素

        # 参数：
            # keys，redis的name的集合
            # timeout，超时时间，当元素所有列表的元素获取完之后，阻塞等待列表内有数据的时间（秒）, 0 表示永远阻塞

        # 更多：
            # r.brpop(keys, timeout)，从右向左获取数据
    brpoplpush(src, dst, timeout=0)

        # 从一个列表的右侧移除一个元素并将其添加到另一个列表的左侧

        # 参数：
            # src，取出并要移除元素的列表对应的name
            # dst，要插入元素的列表对应的name
            # timeout，当src对应的列表中没有数据时，阻塞等待其有数据的超时时间（秒），0 表示永远阻塞
    自定义增量迭代

        # 由于redis类库中没有提供对列表元素的增量迭代，如果想要循环name对应的列表的所有元素，那么就需要：
            # 1、获取name对应的所有列表
            # 2、循环列表
        # 但是，如果列表非常大，那么就有可能在第一步时就将程序的内容撑爆，所有有必要自定义一个增量迭代的功能：

        def list_iter(name):
            &quot;&quot;&quot;
            自定义redis列表增量迭代
            :param name: redis中的name，即：迭代name对应的列表
            :return: yield 返回 列表元素
            &quot;&quot;&quot;
            list_count = r.llen(name)
            for index in xrange(list_count):
                yield r.lindex(name, index)

        # 使用
        for item in list_iter(&apos;pp&apos;):
            print item
7. Set操作，Set集合就是不允许重复的列表

    sadd(name,values)

        # name对应的集合中添加元素
    scard(name)

        获取name对应的集合中元素个数
    sdiff(keys, *args)

        在第一个name对应的集合中且不在其他name对应的集合的元素集合
    sdiffstore(dest, keys, *args)

        # 获取第一个name对应的集合中且不在其他name对应的集合，再将其新加入到dest对应的集合中
    sinter(keys, *args)

        # 获取多一个name对应集合的并集
    sinterstore(dest, keys, *args)

        # 获取多一个name对应集合的并集，再讲其加入到dest对应的集合中
    sismember(name, value)

        # 检查value是否是name对应的集合的成员
    smembers(name)

        # 获取name对应的集合的所有成员
    smove(src, dst, value)

        # 将某个成员从一个集合中移动到另外一个集合
    spop(name)

        # 从集合的右侧（尾部）移除一个成员，并将其返回
    srandmember(name, numbers)

        # 从name对应的集合中随机获取 numbers 个元素
    srem(name, values)

        # 在name对应的集合中删除某些值
    sunion(keys, *args)

        # 获取多一个name对应的集合的并集
    sunionstore(dest,keys, *args)

        # 获取多一个name对应的集合的并集，并将结果保存到dest对应的集合中
    sscan(name, cursor=0, match=None, count=None)
    sscan_iter(name, match=None, count=None)

        # 同字符串的操作，用于增量迭代分批获取元素，避免内存消耗太大


8. 有序集合，在集合的基础上，为每元素排序；元素的排序需要根据另外一个值来进行比较，所以，对于有序集合，每一个元素有两个值，即：值和分数，分数专门用来做排序。

    zadd(name, *args, **kwargs)

        # 在name对应的有序集合中添加元素
        # 如：
             # zadd(&apos;zz&apos;, &apos;n1&apos;, 1, &apos;n2&apos;, 2)
             # 或
             # zadd(&apos;zz&apos;, n1=11, n2=22)
    zcard(name)

        # 获取name对应的有序集合元素的数量
    zcount(name, min, max)

        # 获取name对应的有序集合中分数 在 [min,max] 之间的个数
    zincrby(name, value, amount)

        # 自增name对应的有序集合的 name 对应的分数
    r.zrange( name, start, end, desc=False, withscores=False, score_cast_func=float)

        # 按照索引范围获取name对应的有序集合的元素

        # 参数：
            # name，redis的name
            # start，有序集合索引起始位置（非分数）
            # end，有序集合索引结束位置（非分数）
            # desc，排序规则，默认按照分数从小到大排序
            # withscores，是否获取元素的分数，默认只获取元素的值
            # score_cast_func，对分数进行数据转换的函数

        # 更多：
            # 从大到小排序
            # zrevrange(name, start, end, withscores=False, score_cast_func=float)

            # 按照分数范围获取name对应的有序集合的元素
            # zrangebyscore(name, min, max, start=None, num=None, withscores=False, score_cast_func=float)
            # 从大到小排序
            # zrevrangebyscore(name, max, min, start=None, num=None, withscores=False, score_cast_func=float)
    zrank(name, value)

        # 获取某个值在 name对应的有序集合中的排行（从 0 开始）

        # 更多：
            # zrevrank(name, value)，从大到小排序
    zrangebylex(name, min, max, start=None, num=None)

        # 当有序集合的所有成员都具有相同的分值时，有序集合的元素会根据成员的 值 （lexicographical ordering）来进行排序，而这个命令则可以返回给定的有序集合键 key 中， 元素的值介于 min 和 max 之间的成员
        # 对集合中的每个成员进行逐个字节的对比（byte-by-byte compare）， 并按照从低到高的顺序， 返回排序后的集合成员。 如果两个字符串有一部分内容是相同的话， 那么命令会认为较长的字符串比较短的字符串要大

        # 参数：
            # name，redis的name
            # min，左区间（值）。 + 表示正无限； - 表示负无限； ( 表示开区间； [ 则表示闭区间
            # min，右区间（值）
            # start，对结果进行分片处理，索引位置
            # num，对结果进行分片处理，索引后面的num个元素

        # 如：
            # ZADD myzset 0 aa 0 ba 0 ca 0 da 0 ea 0 fa 0 ga
            # r.zrangebylex(&apos;myzset&apos;, &quot;-&quot;, &quot;[ca&quot;) 结果为：[&apos;aa&apos;, &apos;ba&apos;, &apos;ca&apos;]

        # 更多：
            # 从大到小排序
            # zrevrangebylex(name, max, min, start=None, num=None)
    zrem(name, values)

        # 删除name对应的有序集合中值是values的成员

        # 如：zrem(&apos;zz&apos;, [&apos;s1&apos;, &apos;s2&apos;])
    zremrangebyrank(name, min, max)

        # 根据排行范围删除
    zremrangebyscore(name, min, max)

        # 根据分数范围删除
    zremrangebylex(name, min, max)

        # 根据值返回删除
    zscore(name, value)

        # 获取name对应有序集合中 value 对应的分数
    zinterstore(dest, keys, aggregate=None)

        # 获取两个有序集合的交集，如果遇到相同值不同分数，则按照aggregate进行操作
        # aggregate的值为:  SUM  MIN  MAX
    zunionstore(dest, keys, aggregate=None)

        # 获取两个有序集合的并集，如果遇到相同值不同分数，则按照aggregate进行操作
        # aggregate的值为:  SUM  MIN  MAX
    zscan(name, cursor=0, match=None, count=None, score_cast_func=float)
    zscan_iter(name, match=None, count=None,score_cast_func=float)

        # 同字符串相似，相较于字符串新增score_cast_func，用来对分数进行操作

　　9. redis的发布与订阅

基础类：

    #!/usr/local/env python3
    &apos;&apos;&apos;
    Author:@南非波波
    Blog:http://www.cnblogs.com/songqingbo/
    E-mail:qingbo.song@gmail.com
    &apos;&apos;&apos;
    import redis


    class RedisHelper:

        def __init__(self):
            self.__conn = redis.Redis(host=&apos;localhost&apos;,port=6379)
            self.chan_sub = &apos;fm104.5&apos;
            self.chan_pub = &apos;fm104.5&apos;

        def public(self, msg):
            self.__conn.publish(self.chan_pub, msg)
            return True

        def subscribe(self):
            pub = self.__conn.pubsub()
            pub.subscribe(self.chan_sub)
            pub.parse_response()
            return pub

redis_sub.py

    #!/usr/local/env python3
    &apos;&apos;&apos;
    Author:@南非波波
    Blog:http://www.cnblogs.com/songqingbo/
    E-mail:qingbo.song@gmail.com
    &apos;&apos;&apos;
    from RedisHelper import RedisHelper

    obj = RedisHelper()
    redis_sub = obj.subscribe()

    while True:
        msg= redis_sub.parse_response()
        print(msg)

redis_pub.py

    #!/usr/local/env python3
    &apos;&apos;&apos;
    Author:@南非波波
    Blog:http://www.cnblogs.com/songqingbo/
    E-mail:qingbo.song@gmail.com
    &apos;&apos;&apos;
    from RedisHelper import RedisHelper

    obj = RedisHelper()
    obj.public(&apos;hello&apos;)
</code></pre><h3 id="2-memcached"><a href="#2-memcached" class="headerlink" title="2.    memcached"></a>2.    memcached</h3><pre><code>非持久化轻量级缓存，使用第三方工具可以实现数据的持久化存储
</code></pre><h3 id="3-mongodb"><a href="#3-mongodb" class="headerlink" title="3.    mongodb"></a>3.    mongodb</h3><pre><code>天生的数据持久化，默认将数据持久化存储在本地磁盘。
</code></pre><h2 id="四、消息队列rabbitmq"><a href="#四、消息队列rabbitmq" class="headerlink" title="四、消息队列rabbitmq"></a>四、消息队列rabbitmq</h2><p>通信模式：</p>
<h3 id="1-简单生产者消费者模型"><a href="#1-简单生产者消费者模型" class="headerlink" title="1. 简单生产者消费者模型"></a>1. 简单生产者消费者模型</h3><pre><code>rabbit_send

    #!/usr/local/env python3
    &apos;&apos;&apos;
    Author:@南非波波
    Blog:http://www.cnblogs.com/songqingbo/
    E-mail:qingbo.song@gmail.com
    &apos;&apos;&apos;
    import pika
    #与消息队列建立一个连接
    connection = pika.BlockingConnection(pika.ConnectionParameters(
                   &apos;localhost&apos;))
    #创建一个管道
    channel = connection.channel()

    #在管道中声明一个名称为&apos;name&apos;的队列
    channel.queue_declare(queue=&apos;name&apos;)

    #一个消息不能直接发送给消息队列，需要通过一个路由器进行转发，这个路由器就是由exchange进行设置
    channel.basic_publish(exchange=&apos;&apos;, #路由器
                          routing_key=&apos;name&apos;, #队列名称
                          body=&apos;swht&apos;) #消息
    print(&quot; [swht] Sent a message&quot;)
    connection.close()

rabbit_recive

    #!/usr/local/env python3
    &apos;&apos;&apos;
    Author:@南非波波
    Blog:http://www.cnblogs.com/songqingbo/
    E-mail:qingbo.song@gmail.com
    &apos;&apos;&apos;
    import pika

    #与消息队列服务器建立连接
    connection = pika.BlockingConnection(pika.ConnectionParameters(
                   &apos;localhost&apos;))
    #创建一个管道
    channel = connection.channel()
    #消费者声明一个队列，为了防止生产者还没有启动没有完成创建队列时代码出错的问题。如果队列已存在，则忽略该操作，否则则创建队列
    channel.queue_declare(queue=&apos;name&apos;)

    def callback(ch, method, properties, body):
        print(&quot; [x] Received %r&quot; % body)

    channel.basic_consume(callback,
                          queue=&apos;name&apos;,
                          no_ack=True) #接收消息不进行确认

    print(&apos; [*] Waiting for messages. To exit press CTRL+C&apos;)
    channel.start_consuming()
</code></pre><h3 id="2-消息持久化"><a href="#2-消息持久化" class="headerlink" title="2. 消息持久化"></a>2. 消息持久化</h3><pre><code>    channel.queue_declare(queue=&apos;name&apos;,durable=True)
已经存在的队列是不能再进行持久化设置的，所以在只有创建队列的时候设置持久化选项
    basc_ack = (delivery_tag= method.delivry_tag)

查看当前所有的queue  XX
</code></pre><h3 id="3-消息公平分发"><a href="#3-消息公平分发" class="headerlink" title="3. 消息公平分发"></a>3. 消息公平分发</h3><p><img src="http://i.imgur.com/qBwPkju.png" alt=""></p>
<pre><code>只在消费者添加
channel.basic_qos(prefetch_count=1)

示例代码：

rabbit_slb_send.py
    #!/usr/local/env python3
    &apos;&apos;&apos;
    Author:@南非波波
    Blog:http://www.cnblogs.com/songqingbo/
    E-mail:qingbo.song@gmail.com
    &apos;&apos;&apos;
    import pika

    connection = pika.BlockingConnection(pika.ConnectionParameters(
                   &apos;192.168.137.6&apos;))
    channel = connection.channel()

    #声明queue
    channel.queue_declare(queue=&apos;task_queue&apos;)

    #n RabbitMQ a message can never be sent directly to the queue, it always needs to go through an exchange.
    import sys

    message = &apos; &apos;.join(sys.argv[1:]) or &quot;Hello World!&quot;
    channel.basic_publish(exchange=&apos;&apos;,
                          routing_key=&apos;task_queue&apos;,
                          body=message,
                          properties=pika.BasicProperties(
                          delivery_mode = 2, # make message persistent
                          ))
    print(&quot; [x] Sent %r&quot; % message)
    connection.close()
</code></pre><h3 id="4-exchange路由"><a href="#4-exchange路由" class="headerlink" title="4. exchange路由"></a>4. exchange路由</h3><p><img src="http://i.imgur.com/MFX1LTo.png" alt=""></p>
<p>代码：</p>
<pre><code>publisher.py

    #!/usr/local/env python3
    &apos;&apos;&apos;
    Author:@南非波波
    Blog:http://www.cnblogs.com/songqingbo/
    E-mail:qingbo.song@gmail.com
    &apos;&apos;&apos;
    import pika
    import sys

    connection = pika.BlockingConnection(pika.ConnectionParameters(
            host=&apos;localhost&apos;))
    channel = connection.channel()

    channel.exchange_declare(exchange=&apos;logs&apos;,
                             type=&apos;fanout&apos;)

    message = &apos; &apos;.join(sys.argv[1:]) or &quot;info: Hello World!&quot;
    channel.basic_publish(exchange=&apos;logs&apos;,
                          routing_key=&apos;&apos;,
                          body=message)
    print(&quot; [x] Sent %r&quot; % message)
    connection.close()

subscriber.py

    import pika

    connection = pika.BlockingConnection(pika.ConnectionParameters(
            host=&apos;localhost&apos;))
    channel = connection.channel()

    channel.exchange_declare(exchange=&apos;logs&apos;,
                             type=&apos;fanout&apos;)

    result = channel.queue_declare(exclusive=True) #不指定queue名字,rabbit会随机分配一个名字,exclusive=True会在使用此queue的消费者断开后,自动将queue删除
    queue_name = result.method.queue

    channel.queue_bind(exchange=&apos;logs&apos;,
                       queue=queue_name)

    print(&apos; [*] Waiting for logs. To exit press CTRL+C&apos;)

    def callback(ch, method, properties, body):
        print(&quot; [x] %r&quot; % body)

    channel.basic_consume(callback,
                          queue=queue_name,
                          no_ack=True)

    channel.start_consuming()
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python自动化开发 day09]]></title>
      <url>http://blog.songqingbo.cn/2016/03/12/s12-20160312-day09/</url>
      <content type="html"><![CDATA[<p>Author:@南非波波</p>
<p>课程大纲：</p>
<p>day08</p>
<p><a href="http://www.cnblogs.com/alex3714/articles/5227251.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5227251.html</a></p>
<p>day09</p>
<p><a href="http://www.cnblogs.com/alex3714/articles/5248247.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5248247.html</a></p>
<p>###推荐电影###</p>
<pre><code>&lt;权利的游戏:冰与火之歌&gt;  &lt;纸牌屋&gt; &lt;绝命毒师&gt;
《林大看美国》
</code></pre><h2 id="一、回顾进程、线程"><a href="#一、回顾进程、线程" class="headerlink" title="一、回顾进程、线程"></a>一、回顾进程、线程</h2><pre><code>python调用C的原生线程
GIL(全局解释器)防止数据被修改异常。使用线程锁控制同时仅有一个线程对数据有操作权限
全局解释器限制的是原生C线程，
python同一时刻只有一个线程
python会处理不同cpu核之间的进程切换
父进程与子进程之间默认不能共享数据
</code></pre><p>获取线程的数据</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
import time,threading

data = [] #列表是一个安全的内存空间，可以不用加线程锁
def run(n):
    &apos;&apos;&apos;
    定义一个run方法，返回的n的n次方
    :param n:
    :return:
    &apos;&apos;&apos;
    data.append(n**n)
    return n**n
#创建一个多线程
t = threading.Thread(target=run,args=[8,])
t.start()
t.join() #起阻塞作用，让主进程等待线程执行完再执行主进程  默认无限期的等待，添加一个超时时间timeout=3.在守护线程下面是不好使的
print(data)
</code></pre><h2 id="二、-队列"><a href="#二、-队列" class="headerlink" title="二、 队列"></a>二、 队列</h2><h3 id="1-先进先出"><a href="#1-先进先出" class="headerlink" title="1.    先进先出"></a>1.    先进先出</h3><pre><code>python队列queue默认的是先进先出。
import queue
Queue = queue.Queue(maxsize=5)
Queue.put((2,[&quot;swht&quot;,&quot;shen&quot;]))
Queue.put((5,{&quot;name&quot;:&quot;swht&quot;}))
Queue.put((1,&quot;sdsd&quot;),timeout=2)
for i in range(Queue._qsize()):
    print(&quot;data%s:%s&quot; % (i,Queue.get()))
返回结果：
data0:(2, [&apos;swht&apos;, &apos;shen&apos;])
data1:(5, {&apos;name&apos;: &apos;swht&apos;})
data2:(1, &apos;sdsd&apos;)    
</code></pre><h3 id="2-后进先出"><a href="#2-后进先出" class="headerlink" title="2.    后进先出"></a>2.    后进先出</h3><pre><code>python队列支持后面进去的消息最先被取出。
    python队列queue默认的是先进先出。
import queue
Queue = queue.LifoQueue(maxsize=5)
Queue.put((2,[&quot;swht&quot;,&quot;shen&quot;]))
Queue.put((5,{&quot;name&quot;:&quot;swht&quot;}))
Queue.put((1,&quot;sdsd&quot;),timeout=2)
for i in range(Queue._qsize()):
    print(&quot;data%s:%s&quot; % (i,Queue.get()))
返回结果：
data0:(1, &apos;sdsd&apos;)
data1:(5, {&apos;name&apos;: &apos;swht&apos;})
data2:(2, [&apos;swht&apos;, &apos;shen&apos;])
</code></pre><h3 id="3-按照优先级"><a href="#3-按照优先级" class="headerlink" title="3.    按照优先级"></a>3.    按照优先级</h3><pre><code>python queue支持设置优先级，取消息可以安装优先级顺序取出消息
import queue
Queue = queue.PriorityQueue(maxsize=5)
Queue.put((2,[&quot;swht&quot;,&quot;shen&quot;]))
Queue.put((5,{&quot;name&quot;:&quot;swht&quot;}))
Queue.put((1,&quot;sdsd&quot;),timeout=2)
for i in range(Queue._qsize()):
    print(&quot;data%s:%s&quot; % (i,Queue.get()))
返回结果：
data0:(1, &apos;sdsd&apos;)
data1:(2, [&apos;swht&apos;, &apos;shen&apos;])
data2:(5, {&apos;name&apos;: &apos;swht&apos;})
</code></pre><h3 id="生产者-消费者模型："><a href="#生产者-消费者模型：" class="headerlink" title="生产者-消费者模型："></a>生产者-消费者模型：</h3><h4 id="1-一对一："><a href="#1-一对一：" class="headerlink" title="1.一对一："></a>1.一对一：</h4><pre><code>import threading,queue,time
def consumer(n):
&apos;&apos;&apos;
消费者，消费生产者产生的消息、数据
:param n: 消费者标志
:return:
&apos;&apos;&apos;
while True:
print(&quot;\033[32;1m消费者[%s]\033[0m 获取消息 %s&quot; % (n,q.get()))
time.sleep(1)
q.task_done() #消费者等待生产者生产消息

def prodeucer(n):
&apos;&apos;&apos;
生产者，生产消息、数据
:param n: 生产者标志
:return:
&apos;&apos;&apos;
count = 1
while True:
print(&quot;\033[31;1m生产者[%s]\033[0m 生产消息 %s&quot; % (n,count))
q.put(count)
count += 1
q.join() #生产者阻塞
print(&quot;==================&quot;) #发出信号：消息已经生产

q = queue.Queue()
c1 = threading.Thread(target=consumer,args=[1,])

p1 = threading.Thread(target=prodeucer,args=[&quot;swht&quot;,])

c1.start()
p1.start()

结果：

生产者[swht] 生产消息 1
消费者[1] 获取消息 1
==================
生产者[swht] 生产消息 2
消费者[1] 获取消息 2
==================
生产者[swht] 生产消息 3
消费者[1] 获取消息 3
==================
生产者[swht] 生产消息 4
消费者[1] 获取消息 4
==================
生产者[swht] 生产消息 5
消费者[1] 获取消息 5
==================
生产者[swht] 生产消息 6
消费者[1] 获取消息 6
==================
生产者[swht] 生产消息 7
消费者[1] 获取消息 7
==================
</code></pre><h4 id="2-一对多："><a href="#2-一对多：" class="headerlink" title="2.一对多："></a>2.一对多：</h4><pre><code>import threading,queue,time
def consumer(n):
    &apos;&apos;&apos;
    消费者，消费生产者产生的消息、数据
    :param n: 消费者标志
    :return:
    &apos;&apos;&apos;
    while True:
        print(&quot;\033[32;1m消费者[%s]\033[0m 获取消息 %s&quot; % (n,q.get()))
        time.sleep(1)
        q.task_done() #消费者等待生产者生产消息

def prodeucer(n):
    &apos;&apos;&apos;
    生产者，生产消息、数据
    :param n: 生产者标志
    :return:
    &apos;&apos;&apos;
    count = 1
    while True:
        print(&quot;\033[31;1m生产者[%s]\033[0m 生产消息 %s&quot; % (n,count))
        q.put(count)
        count += 1
        q.join() #生产者阻塞
        print(&quot;==================&quot;) #发出信号：消息已经生产

q = queue.Queue()
c1 = threading.Thread(target=consumer,args=[1,])
c2 = threading.Thread(target=consumer,args=[2,])
c3 = threading.Thread(target=consumer,args=[3,])
p1 = threading.Thread(target=prodeucer,args=[&quot;swht&quot;,])

c1.start()
c2.start()
c3.start()
p1.start()

结果：

生产者[swht] 生产消息 1
消费者[1] 获取消息 1
==================
生产者[swht] 生产消息 2
消费者[2] 获取消息 2
==================
生产者[swht] 生产消息 3
消费者[3] 获取消息 3
==================
生产者[swht] 生产消息 4
消费者[1] 获取消息 4
==================
生产者[swht] 生产消息 5
消费者[2] 获取消息 5
==================
生产者[swht] 生产消息 6
消费者[3] 获取消息 6
==================
生产者[swht] 生产消息 7
消费者[1] 获取消息 7
==================
</code></pre><h4 id="3-多对多："><a href="#3-多对多：" class="headerlink" title="3.多对多："></a>3.多对多：</h4><pre><code>import threading,queue,time
def consumer(n):
    &apos;&apos;&apos;
    消费者，消费生产者产生的消息、数据
    :param n: 消费者标志
    :return:
    &apos;&apos;&apos;
    while True:
        print(&quot;\033[32;1m消费者[%s]\033[0m 获取消息 %s&quot; % (n,q.get()))
        time.sleep(1)
        q.task_done() #消费者等待生产者生产消息

def prodeucer(n):
    &apos;&apos;&apos;
    生产者，生产消息、数据
    :param n: 生产者标志
    :return:
    &apos;&apos;&apos;
    count = 1
    while True:
        print(&quot;\033[31;1m生产者[%s]\033[0m 生产消息 %s&quot; % (n,count))
        q.put(count)
        count += 1
        q.join() #生产者阻塞
        print(&quot;==================&quot;) #发出信号：消息已经生产

q = queue.Queue()
c1 = threading.Thread(target=consumer,args=[1,])
c2 = threading.Thread(target=consumer,args=[2,])
c3 = threading.Thread(target=consumer,args=[3,])
p1 = threading.Thread(target=prodeucer,args=[&quot;swht&quot;,])
p2 = threading.Thread(target=prodeucer,args=[&quot;shen&quot;,])
p3 = threading.Thread(target=prodeucer,args=[&quot;alex&quot;,])

c1.start()
c2.start()
c3.start()
p1.start()
p2.start()
p3.start()

结果：

生产者[swht] 生产消息 1
生产者[shen] 生产消息 1
消费者[1] 获取消息 1
生产者[alex] 生产消息 1
消费者[2] 获取消息 1
消费者[3] 获取消息 1
==================
生产者[swht] 生产消息 2
消费者[1] 获取消息 2
==================
生产者[swht] 生产消息 3
消费者[2] 获取消息 3
==================
生产者[swht] 生产消息 4
消费者[3] 获取消息 4
==================
生产者[alex] 生产消息 2
消费者[1] 获取消息 2
==================
生产者[swht] 生产消息 5
==================
生产者[shen] 生产消息 2
消费者[2] 获取消息 2
消费者[3] 获取消息 5
==================
生产者[swht] 生产消息 6
==================
生产者[shen] 生产消息 3
消费者[1] 获取消息 3
消费者[3] 获取消息 6
==================
生产者[shen] 生产消息 4
消费者[2] 获取消息 4
==================
生产者[shen] 生产消息 5
消费者[1] 获取消息 5
==================
生产者[shen] 生产消息 6
消费者[3] 获取消息 6
==================
生产者[shen] 生产消息 7
消费者[2] 获取消息 7
==================
</code></pre><h2 id="三、协程"><a href="#三、协程" class="headerlink" title="三、协程"></a>三、协程</h2><p>协程是一种用户态的轻量级线程。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。</p>
<p>通过协程进行线程内切换，虽然还是串行的执行，但是因为切换速度快，可以达到一种并发的效果。用户自行控制</p>
<p>协程的好处：</p>
<pre><code>无需线程上下文切换的开销
无需原子操作锁定及同步的开销
方便切换控制流，简化编程模型
高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。
</code></pre><p>缺点：</p>
<pre><code>无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。
进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序
</code></pre><p>通过<strong>yeild</strong>简单模拟协程</p>
<pre><code>import time
import queue
def consumer(name):
    print(&quot;---&gt;starting eating baozi...&quot;)
    while True:
        new_baozi = yield
        print(&quot;[%s] is eating baozi %s&quot; % (name,new_baozi))
        #time.sleep(1)

def producer():

    r = con.__next__()
    r = con2.__next__()
    n = 0
    while n &lt; 5:
        n +=1
        con.send(n)
        con2.send(n)
        print(&quot;\033[32;1m[producer]\033[0m is making baozi %s&quot; %n )


if __name__ == &apos;__main__&apos;:
    con = consumer(&quot;c1&quot;)
    con2 = consumer(&quot;c2&quot;)
    p = producer()

&apos;&apos;&apos;    
结果：
---&gt;starting eating baozi...
---&gt;starting eating baozi...
[c1] is eating baozi 1
[c2] is eating baozi 1
[producer] is making baozi 1
[c1] is eating baozi 2
[c2] is eating baozi 2
[producer] is making baozi 2
[c1] is eating baozi 3
[c2] is eating baozi 3
[producer] is making baozi 3
[c1] is eating baozi 4
[c2] is eating baozi 4
[producer] is making baozi 4
[c1] is eating baozi 5
[c2] is eating baozi 5
[producer] is making baozi 5
&apos;&apos;&apos;
</code></pre><p><strong>greenlet模块</strong></p>
<p>greenlet模块可以简单的实现协程之间的切换</p>
<p>示例代码：</p>
<pre><code>from greenlet import greenlet
def test1():
    print(12)
    gr2.switch()
    print(34)
    gr2.switch()
def test2():
    print(56)
    gr1.switch()
    print(78)

gr1 = greenlet(test1)
gr2 = greenlet(test2)
gr1.switch()
</code></pre><p><strong>gevent模块</strong></p>
<p>Gevent 是一个第三方库，可以轻松通过gevent实现并发同步或异步编程，在gevent中用到的主要模式是Greenlet, 它是以C扩展模块形式接入Python的轻量级协程。 Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。</p>
<p>gevent模块实现协程在遇到IO阻塞时进行切换的功能。避免了协程的致命缺点：一个协程阻塞，整个线程宕掉</p>
<p>示例代码：</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
import gevent

def foo():
    print(&apos;\033[32;1mRunning in foo\033[0m&apos;)
    gevent.sleep(1)
    print(&apos;\033[32;1mExplicit context switch to foo again\033[0m&apos;)

def bar():
    print(&apos;Explicit context to bar&apos;)
    gevent.sleep(1)
    print(&apos;Implicit context switch back to bar&apos;)

def exe():
    print(&apos;\033[31;1mExplicit context to bar\033[0m&apos;)
    gevent.sleep(1)
    print(&apos;\033[31;1mImplicit context switch back to bar\033[0m&apos;)

gevent.joinall([
    gevent.spawn(foo),
    gevent.spawn(bar),
    gevent.spawn(exe),
])
</code></pre><p>附注：</p>
<pre><code>gevent模块安装：
1. windows环境：

    使用pip进行安装：pip2 install gevent 
                   pip3 install gevent

2. Linux环境：

    使用pip进行安装：pip2 install gevent 
                      pip3 install gevent
    使用源码包编译安装：
</code></pre><h2 id="四、select、poll、epoll多路IO阻塞"><a href="#四、select、poll、epoll多路IO阻塞" class="headerlink" title="四、select、poll、epoll多路IO阻塞"></a>四、select、poll、epoll多路IO阻塞</h2><h3 id="1-select"><a href="#1-select" class="headerlink" title="1.select"></a>1.select</h3><pre><code>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点，事实上从现在看来，这也是它所剩不多的优点之一。

select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，不过可以通过修改宏定义甚至重新编译内核的方式提升这一限制。

select()所维护的存储大量文件描述符的数据结构，随着文件描述符数量的增大，其复制的开销也线性增长。同时，由于网络响应时间的延迟使得大量TCP连接处于非活跃状态，但调用select()会对所有socket进行一次线性扫描，所以这也浪费了一定的开销。
</code></pre><h3 id="2-poll"><a href="#2-poll" class="headerlink" title="2.poll"></a>2.poll</h3><pre><code>poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。

select()和poll()将就绪的文件描述符告诉进程后，如果进程没有对其进行IO操作，那么下次调用select()和poll()的时候将再次报告这些文件描述符，所以它们一般不会丢失就绪的消息，这种方式称为水平触发（Level Triggered）。    
</code></pre><h3 id="3-epoll"><a href="#3-epoll" class="headerlink" title="3.epoll"></a>3.epoll</h3><pre><code>epoll可以同时支持水平触发和边缘触发（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。

epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表就绪描述符数量的值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射（mmap）技术，这样便彻底省掉了这些文件描述符在系统调用时复制的开销。

另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。
</code></pre><h3 id="select示例："><a href="#select示例：" class="headerlink" title="select示例："></a>select示例：</h3><pre><code>server端

#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
&apos;&apos;&apos;
通过echo server例子了解select 是如何通过单进程实现同时处理多个非阻塞的socket连接
&apos;&apos;&apos;

import select
import socket
import sys
import queue

# 创建一个TCP/IP socket
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.setblocking(False) #设置非阻塞 ==&gt;server.setblocking(0)

# 绑定端口和ip地址
server_address = (&apos;localhost&apos;, 10000)
print(sys.stderr, &apos;starting up on %s port %s&apos; % server_address) #
# print &gt;&gt; sys.stderr,&apos;starting up on %s port %s&apos; % server_address
server.bind(server_address)

# 监听连接，允许同时有5个链接
server.listen(5)
#select()方法接收并监控3个通信列表
#1.所有的输入数据，即外部发过来的数据；
#2.监控和监听所要发出去的数据；
#3.监控错误信息
# 创建输入列表将输入的信息传递给select()
inputs = [ server ]

# 创建输出列表将输出的信息传递给select()
outputs = [ ]

#创建一个缓存队列，用来存储每个连接的输入或输出的数据，然后由select去出来再发出去。
message_queues = {}
#程序的主循环，当调用select()时会阻塞和等待直到新的连接和数据进来
while inputs:

    # Wait for at least one of the sockets to be ready for processing
    print( &apos;\nwaiting for the next event&apos;)
    #readable 代表socket连接有数据可以接收(resv)
    #writable 代表socket连接有可以进行发送(send)的数据
    #exceptional 存放连接通信出现的error错误信息。这里使用inputs信息代替
    readable, writable, exceptional = select.select(inputs, outputs, inputs)
    # Handle inputs
    #readsble list中可以有3种可能状态，第一种是如果这个socket是main&quot;server&quot; socket,它负责监听客户端的连接，
    for s in readable:
        # 如果这个main server socket出现在readable里，那代表这是server端已经ready来接收一个新的连接进来了
        if s is server:
            # A &quot;readable&quot; server socket is ready to accept a connection
            connection, client_address = s.accept() #接收一个新的连接
            print(&apos;new connection from&apos;, client_address) #打印客户端连接的地址
            connection.setblocking(False) #设置成非阻塞状态
            inputs.append(connection) #将链接添加到inputs链表中

            # Give the connection a queue for data we want to send
            message_queues[connection] = queue.Queue()
        #这种情况是这个socket是已经建立了的连接，它把数据发了过来，这个时候就可以通过recv()来接收它发过来的数据，
        # 然后把接收到的数据放到queue里，这样就可以把接收到的数据再传回给客户端了。
        else:
            data = s.recv(1024) #接收客户端传递的数据
            if data: #如果接收的数据不为空
                # A readable client socket has data
                print(sys.stderr, &apos;received &quot;%s&quot; from %s&apos; % (data, s.getpeername()) )
                message_queues[s].put(data) #从缓存队列里获取数据然后将其传递给客户端
                # 如果连接不在发送列表中，则将其添加到发送列表中
                if s not in outputs:
                    outputs.append(s)
            else: #如果接收的数据为空
                # Interpret empty result as closed connection
                print(&apos;closing&apos;, client_address, &apos;after reading no data&apos;)
                # Stop listening for input on the connection
                #停止监听这个连接
                # 这种情况就是这个客户端已经断开了，所以你再通过recv()接收到的数据就为空了，
                # 所以这个时候你就可以把这个跟客户端的连接关闭了。
                if s in outputs:
                    outputs.remove(s)  #既然客户端都断开了，我就不用再给它返回数据了，所以这时候如果这个客户端的连接对象还在outputs列表中，就把它删掉
                inputs.remove(s)    #inputs中也删除掉
                s.close()           #把这个连接关闭掉

                # Remove message queue
                del message_queues[s]
    # 对于writable list中的socket，也有几种状态，如果这个客户端连接在跟它对应的queue里有数据，就把这个数据取出来再发回给这个客户端，否则就把这个连接从output list中移除，
    # 这样下一次循环select()调用时检测到outputs list中没有这个连接，那就会认为这个连接还处于非活动状态
    for s in writable:
        try:
            next_msg = message_queues[s].get_nowait() #获取信息不阻塞等待
        except queue.Empty:
            # No messages waiting so stop checking for writability.
            print(&apos;output queue for&apos;, s.getpeername(), &apos;is empty&apos;)
            outputs.remove(s) #队列为空，则从发送列表中删除连接
        else:
            print( &apos;sending &quot;%s&quot; to %s&apos; % (next_msg, s.getpeername()))
            s.send(next_msg) #当从队列中获取到信息时将其发送给客户端
    #果在跟某个socket连接通信过程中出了错误，就把这个连接对象在inputs\outputs\message_queue中都删除，
    # 再把连接关闭掉
    for s in exceptional:
        print(&apos;handling exceptional condition for&apos;, s.getpeername() )
        # Stop listening for input on the connection
        inputs.remove(s)
        if s in outputs:
            outputs.remove(s)
        s.close()

        # Remove message queue
        del message_queues[s]

client端
#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
import socket
import sys

messages = [ &apos;This is the message. &apos;,
             &apos;It will be sent &apos;,
             &apos;in parts.&apos;,
             ]
server_address = (&apos;localhost&apos;, 10000)

# Create a TCP/IP socket
socks = [ socket.socket(socket.AF_INET, socket.SOCK_STREAM),
          socket.socket(socket.AF_INET, socket.SOCK_STREAM),
          ]

# Connect the socket to the port where the server is listening
print(sys.stderr, &apos;connecting to %s port %s&apos; % server_address)
for s in socks:
    s.connect(server_address)

for message in messages:

    # Send messages on both sockets
    for s in socks:
        print(sys.stderr, &apos;%s: sending &quot;%s&quot;&apos; % (s.getsockname(), message))
        s.send(bytes(message,&apos;utf8&apos;))

    # Read responses on both sockets
    for s in socks:
        data = s.recv(1024)
        print(sys.stderr, &apos;%s: received &quot;%s&quot;&apos; % (s.getsockname(), data))
        if not data:
            print(sys.stderr, &apos;closing socket&apos;, s.getsockname())
            s.close()
</code></pre><h2 id="五、堡垒机模块"><a href="#五、堡垒机模块" class="headerlink" title="五、堡垒机模块"></a>五、堡垒机模块</h2><p>参考：<a href="http://www.cnblogs.com/wupeiqi/articles/5095821.html" target="_blank" rel="external">http://www.cnblogs.com/wupeiqi/articles/5095821.html</a></p>
<h3 id="1-模块安装："><a href="#1-模块安装：" class="headerlink" title="1.模块安装："></a>1.模块安装：</h3><pre><code>pip2 install paramiko

pip3 install paramiko  
 #win下python3安装paramiko模块涉及到编译工具的问题没有安装成功，在Linux环境下面测试下面的代码正常。
</code></pre><h3 id="2-示例代码"><a href="#2-示例代码" class="headerlink" title="2.示例代码"></a>2.示例代码</h3><pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
import paramiko
&apos;&apos;&apos;
基于用户名密码连接
&apos;&apos;&apos;
# 创建SSH对象
ssh = paramiko.SSHClient()
# 允许连接不在know_hosts文件中的主机
ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
# 连接服务器
ssh.connect(hostname=&apos;192.168.137.5&apos;, port=22, username=&apos;root&apos;, password=&apos;shen1234&apos;)

# 执行命令
stdin, stdout, stderr = ssh.exec_command(&apos;df -h&apos;)
# 获取命令结果
result = stdout.read()
#打印结果
print(result.decode())
# 关闭连接
ssh.close()

import paramiko

transport = paramiko.Transport((&apos;192.168.137.5&apos;, 22))
transport.connect(username=&apos;root&apos;, password=&apos;shen1234&apos;)

ssh = paramiko.SSHClient()
ssh._transport = transport

stdin, stdout, stderr = ssh.exec_command(&apos;ifconfig&apos;)
print(stdout.read().decode())

transport.close()

import paramiko

def ssh_connet(host,user,shell):
    &apos;&apos;&apos;
    实现ssh远程登录服务器进行相关操作
    :param host: 远程服务器地址和端口号 host_ip:port
    :param user: 远程服务器用户名密码 user:passwd
    :parm shell: 需要执行的shell命令
    :return: 返回用户执行shell命令的
    &apos;&apos;&apos;
    host = host.split(&quot;:&quot;)
    user = user.split(&quot;:&quot;)
    transport = paramiko.Transport((host[0], int(host[1])))
    transport.connect(username=user[0], password=user[1])
    ssh = paramiko.SSHClient()
    ssh._transport = transport
    stdin, stdout, stderr = ssh.exec_command(shell)
    reaults = stdout.read().decode()
    transport.close()
    return reaults
print(ssh_connet(&quot;192.168.137.5:22&quot;,&quot;root:shen1234&quot;,&quot;df -h&quot;))
</code></pre><h3 id="基于公钥密钥连接："><a href="#基于公钥密钥连接：" class="headerlink" title="基于公钥密钥连接："></a>基于公钥密钥连接：</h3><pre><code>import paramiko

def ssh_connet(host,user,private_key,shell):
    &apos;&apos;&apos;
    实现ssh远程登录服务器进行相关操作
    :param host: 远程服务器地址和端口号 host_ip:port
    :param user: 远程服务器用户名密码 user:passwd
    :param private_key: 基于公钥的形式登录
    :parm shell: 需要执行的shell命令
    :return: 返回用户执行shell命令的
    &apos;&apos;&apos;
    host = host.split(&quot;:&quot;)
    transport = paramiko.Transport((host[0], int(host[1])))
    transport.connect(username=user[0], key=private_key)
    ssh = paramiko.SSHClient()
    ssh._transport = transport
    stdin, stdout, stderr = ssh.exec_command(shell)
    reaults = stdout.read().decode()
    transport.close()
    return reaults
private_key = paramiko.RSAKey.from_private_key_file(&apos;/home/auto/.ssh/id_rsa&apos;)
print(ssh_connet(&quot;192.168.137.5:22&quot;,&quot;root&quot;,private_key,&quot;df -h&quot;))
</code></pre><h2 id="六、mysql操作模块"><a href="#六、mysql操作模块" class="headerlink" title="六、mysql操作模块"></a>六、mysql操作模块</h2><pre><code>rollback()事务回滚
excutemany()
</code></pre><p><strong>作业：</strong></p>
<pre><code>1.    select（）代码，注释
2.    主机批量管理工具
    1.    saltstack文档阅读（常用架构弄清楚）
    2.    修改主机批量管理工具的架构
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python自动化开发 day08]]></title>
      <url>http://blog.songqingbo.cn/2016/03/05/s12-20160305-day08/</url>
      <content type="html"><![CDATA[<p>Author:@南非波波</p>
<p>课程大纲：</p>
<p>day07</p>
<p><a href="http://www.cnblogs.com/alex3714/articles/5213184.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5213184.html</a></p>
<p>day08</p>
<p><a href="http://www.cnblogs.com/alex3714/articles/5227251.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5227251.html</a></p>
<p>###推荐电影###</p>
<pre><code>绝美之城  上帝之城 | 千与千寻  龙猫 卡尔的移动城堡
</code></pre><p>通过实例私有变量，需要将在类中封装一个方法，该方法返回私有变量的值</p>
<h2 id="一、socket深入"><a href="#一、socket深入" class="headerlink" title="一、socket深入"></a>一、socket深入</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><pre><code>Unix的进程通信机制。一个完整的socket有一个本地唯一的socket号，由操作系统分配。socket是面向客户/服务器模型而设计的，针对客户和服务器程序提供不同的socket系统调用。socket利用客户/服务器模式巧妙的解决了进程之间建立通信连接的问题。

套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。
</code></pre><h3 id="2-地址簇"><a href="#2-地址簇" class="headerlink" title="2.地址簇"></a>2.地址簇</h3><pre><code>socket.AF_UNIX unix本机进程间通信 
socket.AF_INET　使用IPV4地址协议进行进程间通信
socket.AF_INET6  使用IPV6地址协议进行进程间通信
</code></pre><h3 id="3-套接字类型"><a href="#3-套接字类型" class="headerlink" title="3.套接字类型"></a>3.套接字类型</h3><pre><code>socket.SOCK_STREAM  #使用tcp协议
socket.SOCK_DGRAM   #使用udp协议
socket.SOCK_RAW     #原始套接字，普通的套接字无法处理ICMP、IFMP等网络报文，而SOCK_RAM可以。其次SOCK_RAM也可以处理特殊的IPV4报文,此外，利用原始套接字可以通过IP_HDRINCL套接字选项由用户构造IP头。
socket.SOCK_RDM    #是一种可靠的UDP形式，即保证交付数据报但不保证顺序。SOCK_RAW用来提供对原始协议的低级访问，在需要执行某些特殊操作时使用，如发送ICMP报文。SOCK_RAW通常仅限于高级用户或管理员运行的程序使用。
</code></pre><h3 id="4-socket方法"><a href="#4-socket方法" class="headerlink" title="4.socket方法"></a>4.socket方法</h3><pre><code>1. socket.socket(family=AF_INET, type=SOCK_STREAM, proto=0, fileno=None)
2. socket.socketpair([family[, type[, proto]]])
3. socket.create_connection(address[, timeout[, source_address]])
4. socket.getaddrinfo(host, port, family=0, type=0, proto=0, flags=0) 
    获取要连接的对端主机地址
5. sk.bind(address) 
    将套接字绑定到地址，地址的格式取决于地址簇。在AF_INET下，以元组(host.port)的形式表示地址。
6. sk.listen(backlog) 
    开始监听传入的连接，backlog指定在拒绝连接之前，可以挂起的最大连接数量。backlog等于5，表示内核已经连接到连接请求，但服务器还没有调用accept进行处理的连接个数最大为5.这个值根据内核和服务器物理配置进行设置。
7. sk.setblocking(bool) 
    是否阻塞（默认True），如果设置为False，那么accept和recv时一旦无数据则报错。
8. sk.accept() 
    接受连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据，address是连接客户端的地址。接收TCP客户的连接（阻塞式）等待连接的到来。
9. sk.connect(address)
    连接到address处的套接字。一般，address的格式为元组（hostname,port），如果连接出错，返回socket.err错误。
10. sk.connect_ex(address)
    同上，只是会有返回值，连接成功时返回0，连接失败时会返回编码，例如：10061
11. sk.close()
    关闭套接字
12. sk.recv(bufsize[,flag])
    接收套接字的数据，数据以字符串形式返回。bufsize指定最多可以接收的数量，建议不要超过1024*8。flag提供有关消息的其他信息。通常可以忽略。
13. sk.recvfrom(bufsize[.flag])
    与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址
14. sk.send(string[,flag])
    将string中的数据发送到连接的套接字，返回值是要发送的字节数量，该数量可能小于string的字节大小，即：可能未壮指定内容全部发送
15. sk.sendall(string[,flag])
    将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则跑出异常。内部通过递归调用send将所有内容发送出去。
16.    sk.sendto(string[,flag],address)
    将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。该函数主要用于UDP协议。
17. sk.settimeout(timeout)
    设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如 client 连接最多等待5s ）
18. sk.getpeername()
    返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）
19.    sk.getsockname()
    返回套接字自己的地址，通常在是一个元组（ipaddr,port）
20. socket.gethostname()
    获取程序运行所在计算机的主机名
21.    gethostbyname(name) 
    尝试将给定的主机名解释为一个IP地址。首先将检查当前计算机是否能够解释。如果不能，一个解释请求将发送给一个远程的DNS服务器（远程的DNS服务器 还可能将解释请求转发给另一个DNS服务器，直到该请求可以被处理）。gethostbyname函数返回这个IP地址或在查找失败后引发一个异常。例如： socket.gethostbyname(&apos;www.apicloud.com&apos;)
    扩展形式：socket.gethostbyname_ex(&apos;www.apicloud.com&apos;)
    (&apos;98e86f98d416f10c.7cname.com&apos;, [&apos;www.apicloud.com&apos;], [&apos;117.25.140.17&apos;])
    它返回一个包含三个元素的元组，分别是给定地址的主要的主机名、同一IP地址的可选的主机名的一个列表、关于同一主机的同一接口的其它IP地址的一个列表（列表可能都是空的）。
22. gethostbyaddr(address)
    函数的作用与gethostbyname_ex相同，只是你提供给它的参数是一个IP地址字符串。
    socket.gethostbyaddr(&apos;202.165.102.205&apos;)
    (&apos;homepage.vip.cnb.yahoo.com&apos;, [&apos;www.yahoo.com.cn&apos;], [&apos;202.165.102.205&apos;])
23.    getservbyname(service,protocol)
    函数要求一个服务名（如&apos;telnet&apos;或&apos;ftp&apos;）和一个协议（如&apos;tcp&apos;或&apos;udp&apos;），返回服务所使用的端口号：
    &gt;&gt;&gt; socket.getservbyname(&apos;http&apos;,&apos;tcp&apos;)
    80
    &gt;&gt;&gt; socket.getservbyname(&apos;https&apos;,&apos;tcp&apos;)
    443
    &gt;&gt;&gt; socket.getservbyname(&apos;telnet&apos;,&apos;tcp&apos;)
24.    sk.fileno()
    套接字的文件描述符
    socket.sendfile(file, offset=0, count=None)
    发送文件 ，但目前多数情况下并无什么卵用
</code></pre><h2 id="二、socketserver"><a href="#二、socketserver" class="headerlink" title="二、socketserver"></a>二、socketserver</h2><p>参考链接：<a href="http://my.oschina.net/u/1433482/blog/190612" target="_blank" rel="external">http://my.oschina.net/u/1433482/blog/190612</a></p>
<p>SocketServer简化了网络服务器的编写。它有4个类：TCPServer，UDPServer，UnixStreamServer，UnixDatagramServer。这4个类是同步进行处理的，另外通过ForkingMixIn和ThreadingMixIn类来支持异步。</p>
<h3 id="创建服务器的步骤"><a href="#创建服务器的步骤" class="headerlink" title="创建服务器的步骤"></a>创建服务器的步骤</h3><pre><code>首先，你必须创建一个请求处理类，它是BaseRequestHandler的子类并重载其handle()方法。其次，你必须实例化一个服务器类，传入服务器的地址和请求处理程序类。最后，调用handle_request()(一般是调用其他事件循环或者使用select())或serve_forever()。
</code></pre><h3 id="服务器类型"><a href="#服务器类型" class="headerlink" title="服务器类型"></a>服务器类型</h3><pre><code>5种类型：BaseServer，TCPServer，UnixStreamServer，UDPServer，UnixDatagramServer。 注意：BaseServer不直接对外服务。
</code></pre><h3 id="服务器对象"><a href="#服务器对象" class="headerlink" title="服务器对象"></a>服务器对象</h3><pre><code>class SocketServer.BaseServer：这是模块中的所有服务器对象的超类。它定义了接口，如下所述，但是大多数的方法不实现，在子类中进行细化。

BaseServer.fileno()：返回服务器监听套接字的整数文件描述符。通常用来传递给select.select(), 以允许一个进程监视多个服务器。

BaseServer.handle_request()：处理单个请求。处理顺序：get_request(), verify_request(), process_request()。如果用户提供handle()方法抛出异常，将调用服务器的handle_error()方法。如果self.timeout内没有请求收到， 将调用handle_timeout()并返回handle_request()。

BaseServer.serve_forever(poll_interval=0.5): 处理请求，直到一个明确的shutdown()请求。每poll_interval秒轮询一次shutdown。忽略self.timeout。如果你需要做周期性的任务，建议放置在其他线程。

BaseServer.shutdown()：告诉serve_forever()循环停止并等待其停止。python2.6版本。

BaseServer.address_family: 地址家族，比如socket.AF_INET和socket.AF_UNIX。

BaseServer.RequestHandlerClass：用户提供的请求处理类，这个类为每个请求创建实例。

BaseServer.server_address：服务器侦听的地址。格式根据协议家族地址的各不相同，请参阅socket模块的文档。

BaseServer.socketSocket：服务器上侦听传入的请求socket对象的服务器。

服务器类支持下面的类变量：

BaseServer.allow_reuse_address：服务器是否允许地址的重用。默认为false ，并且可在子类中更改。

BaseServer.request_queue_size

请求队列的大小。如果单个请求需要很长的时间来处理，服务器忙时请求被放置到队列中，最多可以放request_queue_size个。一旦队列已满，来自客户端的请求将得到 “Connection denied”错误。默认值通常为5 ，但可以被子类覆盖。

BaseServer.socket_type：服务器使用的套接字类型; socket.SOCK_STREAM和socket.SOCK_DGRAM等。

BaseServer.timeout：超时时间，以秒为单位，或 None表示没有超时。如果handle_request()在timeout内没有收到请求，将调用handle_timeout()。

下面方法可以被子类重载，它们对服务器对象的外部用户没有影响。

BaseServer.finish_request()：实际处理RequestHandlerClass发起的请求并调用其handle()方法。 常用。

BaseServer.get_request()：接受socket请求，并返回二元组包含要用于与客户端通信的新socket对象，以及客户端的地址。

BaseServer.handle_error(request, client_address)：如果RequestHandlerClass的handle()方法抛出异常时调用。默认操作是打印traceback到标准输出，并继续处理其他请求。

BaseServer.handle_timeout()：超时处理。默认对于forking服务器是收集退出的子进程状态，threading服务器则什么都不做。

BaseServer.process_request(request, client_address) :调用finish_request()创建RequestHandlerClass的实例。如果需要，此功能可以创建新的进程或线程来处理请求,ForkingMixIn和ThreadingMixIn类做到这点。常用。

BaseServer.server_activate()：通过服务器的构造函数来激活服务器。默认的行为只是监听服务器套接字。可重载。

BaseServer.server_bind()：通过服务器的构造函数中调用绑定socket到所需的地址。可重载。

BaseServer.verify_request(request, client_address)：返回一个布尔值，如果该值为True ，则该请求将被处理，反之请求将被拒绝。此功能可以重写来实现对服务器的访问控制。默认的实现始终返回True。client_address可以限定客户端，比如只处理指定ip区间的请求。 常用。
</code></pre><h3 id="请求处理器"><a href="#请求处理器" class="headerlink" title="请求处理器"></a>请求处理器</h3><pre><code>处理器接收数据并决定如何操作。它负责在socket层之上实现协议（i.e., HTTP, XML-RPC, or AMQP)，读取数据，处理并写反应。可以重载的方法如下：

setup(): 准备请求处理. 默认什么都不做，StreamRequestHandler中会创建文件类似的对象以读写socket.

handle(): 处理请求。解析传入的请求，处理数据，并发送响应。默认什么都不做。常用变量：self.request，self.client_address，self.server。

finish(): 环境清理。默认什么都不做，如果setup产生异常，不会执行finish。

通常只需要重载handle。self.request的类型和数据报或流的服务不同。对于流服务，self.request是socket 对象；对于数据报服务，self.request是字符串和socket 。可以在子类StreamRequestHandler或DatagramRequestHandler中重载，重写setup()和finish() ，并提供self.rfile和self.wfile属性。 self.rfile和self.wfile可以读取或写入，以获得请求数据或将数据返回到客户端。
</code></pre><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><pre><code>1.server

    #!/usr/local/env python3
    &apos;&apos;&apos;
    Author:@南非波波
    Blog:http://www.cnblogs.com/songqingbo/
    E-mail:qingbo.song@gmail.com
    &apos;&apos;&apos;
    import socketserver

    class MyHandleServer(socketserver.BaseRequestHandler):
        &apos;&apos;&apos;
        定义一个测试socketserver类
        &apos;&apos;&apos;
        def handle(self):
            &apos;&apos;&apos;
            定义一个函数，用来处理每个客户端发来的请求
            :return:
            &apos;&apos;&apos;
            print(&quot;新建立一个连接：&quot;,self.client_address)
            while True:
                try:
                    client_data = self.request.recv(1024)
                    if not client_data:
                        print(&quot;客户端发送的数据为空,主动断开!&quot;,self.client_address)
                        break
                    print(&quot;客户端发来的请求:&quot;,client_data.decode())
                    self.request.send(client_data)
                except ConnectionResetError:
                    print(&quot;客户端主动断开!&quot;,self.client_address)
                    break

    if __name__ == &quot;__main__&quot;:
        HOST,PORT = &quot;127.0.0.1&quot;,5000
        server = socketserver.ThreadingTCPServer((HOST,PORT),MyHandleServer)
        server.serve_forever()


2.client

    #!/usr/local/env python3
    &apos;&apos;&apos;
    Author:@南非波波
    Blog:http://www.cnblogs.com/songqingbo/
    E-mail:qingbo.song@gmail.com
    &apos;&apos;&apos;
    import socket

    ip_port = (&quot;127.0.0.1&quot;,5000)

    sk = socket.socket()
    sk.connect(ip_port)
    while True:
        msg = input(&quot;&gt;&gt;:&quot;).strip()
        if not msg:
            break
        sk.sendall(bytes(msg,&quot;utf8&quot;))
        server_reply = sk.recv(1024)
        print(&quot;服务端返回:&quot;,str(server_reply,&quot;utf8&quot;))
    sk.close()
</code></pre><h2 id="三、异常处理"><a href="#三、异常处理" class="headerlink" title="三、异常处理"></a>三、异常处理</h2><p><a href="http://www.cnblogs.com/wupeiqi/articles/5017742.html" target="_blank" rel="external">http://www.cnblogs.com/wupeiqi/articles/5017742.html</a></p>
<h3 id="1-异常基础-python3的写法"><a href="#1-异常基础-python3的写法" class="headerlink" title="1.异常基础(python3的写法)"></a>1.异常基础(python3的写法)</h3><pre><code>在编程过程中为了增加友好性，在程序出现bug时一般不会将错误信息显示给用户，而是显示一个提示的页面，通俗来说就是不让用户看见代码出错的页面

    try:
        pass
    except Exception as ex:
        pass
</code></pre><h3 id="2-异常种类"><a href="#2-异常种类" class="headerlink" title="2.异常种类"></a>2.异常种类</h3><pre><code>常用异常：

    AttributeError 试图访问一个对象没有的树形，比如foo.x，但是foo没有属性x
    IOError 输入/输出异常；基本上是无法打开文件
    ImportError 无法引入模块或包；基本上是路径问题或名称错误
    IndentationError 语法错误（的子类） ；代码没有正确对齐
    IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问x[5]
    KeyError 试图访问字典里不存在的键
    KeyboardInterrupt Ctrl+C被按下
    NameError 使用一个还未被赋予对象的变量
    SyntaxError Python代码非法，代码不能编译(个人认为这是语法错误，写错了）
    TypeError 传入对象类型与要求的不符合
    UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的全局变量，
    导致你以为正在访问它
    ValueError 传入一个调用者不期望的值，即使值的类型是正确的
更多种类：

    ArithmeticError
    AssertionError
    AttributeError
    BaseException
    BufferError
    BytesWarning
    DeprecationWarning
    EnvironmentError
    EOFError
    Exception  #捕获一般的所有异常
    FloatingPointError
    FutureWarning
    GeneratorExit
    ImportError  #捕获导入模块异常
    ImportWarning
    IndentationError
    IndexError  #捕获索引异常
    IOError  #捕获IO异常
    KeyboardInterrupt  #捕获键盘组合键异常
    KeyError
    LookupError
    MemoryError
    NameError
    NotImplementedError
    OSError
    OverflowError
    PendingDeprecationWarning
    ReferenceError
    RuntimeError
    RuntimeWarning
    StandardError
    StopIteration
    SyntaxError
    SyntaxWarning
    SystemError
    SystemExit
    TabError
    TypeError
    UnboundLocalError
    UnicodeDecodeError
    UnicodeEncodeError
    UnicodeError
    UnicodeTranslateError
    UnicodeWarning
    UserWarning
    ValueError
    Warning
    ZeroDivisionError
</code></pre><h3 id="3-自定义异常类"><a href="#3-自定义异常类" class="headerlink" title="3.自定义异常类"></a>3.自定义异常类</h3><pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
class SwhtError(Exception):
    &apos;&apos;&apos;
    自定义异常
    &apos;&apos;&apos;
    def __init__(self,msg):
        &apos;&apos;&apos;
        初始化函数
        :param msg:用户输入message
        :return:
        &apos;&apos;&apos;
        self.message = msg

    def __str__(self): #名称可以自行定义，只是通过该方法返回message的值
        &apos;&apos;&apos;
        返回用户输入的信息
        :return:
        &apos;&apos;&apos;
        return self.message

try:
    raise SwhtError(&quot;这是一个致命的错误！&quot;)
except Exception as e:
    print(&quot;dsdsd&quot;,e)
</code></pre><h3 id="4-示例代码："><a href="#4-示例代码：" class="headerlink" title="4.示例代码："></a>4.示例代码：</h3><pre><code>dic = [&quot;swht&quot;, &apos;shen&apos;]
try:
    dic[10]
except IndexError as e:
    print(&quot;IndexError:&quot;,e)

dic = {&apos;k1&apos;:&apos;v1&apos;}
try:
    dic[&apos;k20&apos;]
except KeyError as e:
    print(&quot;keyError:&quot;,e)

s1 = &apos;hello&apos;
try:
    int(s1)
except ValueError as e:
    print(&quot;ValueError:&quot;,e)
</code></pre><h3 id="5-特殊异常"><a href="#5-特殊异常" class="headerlink" title="5.特殊异常"></a>5.特殊异常</h3><pre><code>虽然python自带的一个处理万能异常类Exception，但是并不是有一些异常都能被捕获的。如果要想捕获这些特殊的异常，就需要进行自定义异常类
</code></pre><h3 id="6-异常其他架构"><a href="#6-异常其他架构" class="headerlink" title="6.异常其他架构"></a>6.异常其他架构</h3><pre><code>try:
    # 主代码块
    pass
except KeyError as e:
    # 异常时，执行该块
    pass
else:
    # 主代码块执行完，执行该块
    pass
finally:
    # 无论异常与否，最终执行该块
    pass
</code></pre><h3 id="7-主动触发异常"><a href="#7-主动触发异常" class="headerlink" title="7.主动触发异常"></a>7.主动触发异常</h3><pre><code>try:
    raise Exception(&apos;错误了。。。&apos;)
except Exception as e:
    print(&quot;Error&quot;,e)
</code></pre><h3 id="8-Asser断言："><a href="#8-Asser断言：" class="headerlink" title="8.Asser断言："></a>8.Asser断言：</h3><pre><code>至关重要的判断，强制判断前面的业务结果是否符合要求，否则就抛出异常

    a = 1
    try:
        assert a == 2
        print(&quot;True&quot;)
    except Exception as e:
        print(&quot;False&quot;,e)
</code></pre><h2 id="四、进程与线程"><a href="#四、进程与线程" class="headerlink" title="四、进程与线程"></a>四、进程与线程</h2><h3 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1.概念"></a>1.概念</h3><pre><code>1.进程

        一个具有一定独立功能的程序关于某个数据集合的一次运行活动，是系统进行资源分配和调度运行的基本单位
2.线程

        线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务

3.进程与线程的区别

        1. 进程是一个动态的概念

        进程是程序的一次执行过程，是动态概念

        程序是一组有序的指令集和，是静态概念

        2. 不同的进程可以执行同一个程序

        区分进程的条件：所执行的程序和数据集合。

        两个进程即使执行在相同的程序上，只要他们运行在不同的数据集合上，他们也是两个进程。例如：多个用户同时调用同一个编译程序编译他们编写的C语言源程序，由于编译程序运行在不同的数据集合（不同的C语言源程序）上，于是产生了一个个不同的进程

        3. 每个进程都有自己的生命周期

        当操作系统要完成某个任务时，它会创建一个进程。当进程完成任务之后，系统就会撤销这个进程，收回它所占用的资源。从创建到撤销的时间段就是进程的生命期

        4. 进程之间存在并发性

        在一个系统中，同时会存在多个进程。他们轮流占用CPU和各种资源

        5. 进程间会相互制约

        进程是系统中资源分配和运行调度的单位，在对资源的共享和竞争中，必然相互制约，影响各自向前推进的速度

        6. 进程可以创建子进程，程序不能创建子程序

        7. 从结构上讲，每个进程都由程序、数据和一个进程控制块（Process Control Block, PCB）组成
</code></pre><h3 id="2-进程锁"><a href="#2-进程锁" class="headerlink" title="2.进程锁"></a>2.进程锁</h3><p> Python threading模块</p>
<pre><code>1.线程的两种调用方式
    1.    直接调用
    2.    继承式调用
2.join&amp;&amp;Demo
3.线程锁
    1.    互斥锁：同时仅且只有一个线程在运行
    2.    共享锁：同时可以有多个线程共同运行，可以实现一个线程池的效果
    2.    递归锁
    3.    Semaphore(信号量)
</code></pre><h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><pre><code>#!/usr/local/env python3

import threading,time

def addNum():
    global num #声明修改全局变量
    print(&quot;--get num:&quot;,num)
    time.sleep(1)
    lock.acquire()
    num -=1
    lock.release()

lock = threading.Lock()
num = 100
threading_list = []
for i in range(2040):
    t = threading.Thread(target=addNum)
    t.start()
    threading_list.append(t)
for t in threading_list: #等待所有线程执行完毕
    t.join()

print(&quot;num:&quot;,num)
</code></pre><p>event</p>
<p>多进程</p>
<p>进程间通讯</p>
<pre><code>队列
管道
manager
    Manager 所有的子进程和父进程之间都能进行数据的共享
    Manager 是一个安全的进程管理池，不需要加进程锁
</code></pre><p>进程同步</p>
<p>进程池</p>
<pre><code>开启一个进程的系统开销太大，设置进程池限制启动的进程数，以达到保护系统的目的。另外在线程池内的进程可以实现同步或异步调用。
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python自动化开发 day07]]></title>
      <url>http://blog.songqingbo.cn/2016/02/27/s12-20160227-day07/</url>
      <content type="html"><![CDATA[<p>Author:@南非波波</p>
<p>课程大纲：</p>
<p>day06</p>
<p><a href="http://www.cnblogs.com/alex3714/articles/5188179.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5188179.html</a></p>
<p>day07</p>
<p><a href="http://www.cnblogs.com/alex3714/articles/5213184.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5213184.html</a></p>
<h2 id="一、类的多态、继承"><a href="#一、类的多态、继承" class="headerlink" title="一、类的多态、继承"></a>一、类的多态、继承</h2><h3 id="类的多态：统一接口调用"><a href="#类的多态：统一接口调用" class="headerlink" title="类的多态：统一接口调用"></a>类的多态：统一接口调用</h3><pre><code>#!/usr/bin/env python
# -*- coding:utf-8 -*-
class Animal:
    def __init__(self, name):    # Constructor of the class
        self.name = name
    def talk(self):              # Abstract method, defined by convention only
        raise NotImplementedError(&quot;Subclass must implement abstract method&quot;)
    hobbie = &apos;ddd&apos;
class Cat(Animal):
    def talk(self):
        return &apos;Meow!&apos;
class Dog(Animal):
    def talk(self):
        return &apos;Woof! Woof!&apos;

animals = [Cat(&apos;Missy&apos;),
           Dog(&apos;Lassie&apos;)]

for animal in animals:
    print(animal.name + &apos;: &apos; + animal.talk())
</code></pre><h3 id="类的方法：示例"><a href="#类的方法：示例" class="headerlink" title="类的方法：示例"></a>类的方法：示例</h3><pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
class Animal(object):
    &apos;&apos;&apos;
    定义一个动物类
    &apos;&apos;&apos;
    def __init__(self,name):
        self.name = name
        self.__num = None #定义成私有变量，只能在类中访问

    # def talk(self):
    #     print(&quot;%s is talking!&quot; % self.name)
    hobbie = &quot;shen&quot; #类变量，静态字段
    @classmethod  #类方法，不能访问实例变量
    def talk(self):
        print(&quot;%s is talking!&quot; % self.hobbie)
    # def work(self):
    #     print(&quot;%s is working!&quot; % self.name)

    @staticmethod #静态方法，不能访问类变量和实例变量
    def work():
        print(&quot;It is working!&quot;)

    # def walk(self):
    #     print(&quot;%s is walking!&quot; % self.name)
    @property #把方法编程静态属性
    def walk(self,num):
        return self.__num
    @walk.setter #传值
    def walk(self,num):
        self.__num = num
        print(self.__num)
    @walk.deleter  #删值
    def walk(self):
        print(&quot;del num&quot;)
c = Animal(&quot;swht&quot;)
# c.talk()
# c.work()
c.walk = 3
del c.walk
print(&quot;OUT:&quot;,c._Animal__num)  #特例情况下可以通过这种方式访问私有变量
</code></pre><h3 id="经典类与新式类"><a href="#经典类与新式类" class="headerlink" title="经典类与新式类"></a>经典类与新式类</h3><p>经典类和新式类区别：</p>
<p>经典类：使用深度优先进行继承<br>新式类：使用广度优先进行继承</p>
<p>另外：经典类和新式类在python-3.X平台上会默认使用广度优先进行继承，而在python-2.X中则体现上述区别</p>
<h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;

class A:
    print(&quot;A&quot;)
    def f2(self):
        print(&quot;f2 from A&quot;)
class B(A):
    print(&quot;B&quot;)
    def f1(self):
        print(&quot;f1 from B&quot;)
    def f2(self):
        print(&quot;f2 from B&quot;)
class C(A):
    print(&quot;C&quot;)
    def f2(self):
        print(&quot;f2 from C&quot;)

class D(B,C):
    pass

d = D()
d.f1()
d.f2()

&apos;&apos;&apos;
广度优先算法继承。先将B类中的f2()注释掉，D自动继承C.f2()，如果再将C类中的f2()，D自动继承A.f2()
&apos;&apos;&apos;
</code></pre><h3 id="类的特殊成员"><a href="#类的特殊成员" class="headerlink" title="类的特殊成员"></a>类的特殊成员</h3><pre><code>__doc__:查看类的注释
__init__:构造方法，通过类创建对象时，自动触发执行。
__module__:表示当前操作的对象在那个模块
__class__:表示当前操作的对象的类是什么
__del__:析构方法,解释器进行垃圾回收时自动触发
__call__:对象加()执行call方法
__new__：实例化时new方法执行了__init__
__metaclass__：通过改写metaclass方法达到构建自己需要的类的目的
__dict__:以字典的形式显示类对象中的成员。使用场景：查看类中有多少成员（只显示类变量，不显示实例变量）
__str__:如果一个类中定义了__str__方法，那么在打印 对象 时，默认输出该方法的返回值。
__iter__:用于迭代器，之所以列表、字典、元组可以进行for循环，是因为类型内部定义了 __iter__ 
</code></pre><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;

class People(object):
    &apos;&apos;&apos;
    定义一个人类
    &apos;&apos;&apos;
    def __init__(self,name,age):
        &apos;&apos;&apos;
        定义属性
        :param name: 人类的名字
        :param age: 人类的年龄属性
        :return:
        &apos;&apos;&apos;
        self.name = name
        self.age = age

    def china_man(self):
        pass

chinese = People(&quot;swht&quot;,27)
#__doc__:查看类的注释
print(chinese.__doc__) #  定义一个人类
#__dict__:以字典的形式显示类对象中的成员。使用场景：查看类中有多少成员（只显示类变量，不显示实例变量）
print(chinese.__dict__) #{&apos;age&apos;: 27, &apos;name&apos;: &apos;swht&apos;}
#__module__:表示当前操作的对象在那个模块
print(chinese.__module__) #__main__
#__class__:表示当前操作的对象的类是什么
print(chinese.__class__) #&lt;class &apos;__main__.People&apos;&gt;
</code></pre><h3 id="构造类的方法"><a href="#构造类的方法" class="headerlink" title="构造类的方法"></a>构造类的方法</h3><p><a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python" target="_blank" rel="external">http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python</a></p>
<p>一句话构建一个类</p>
<pre><code>Foo = type(&apos;Foo&apos;,(object,), {&apos;func&apos;: func}) 
    #type第一个参数：类名
    #type第二个参数：当前类的基类
    #type第三个参数：类的成员
</code></pre><p><img src="http://i.imgur.com/dmSh15M.png" alt=""></p>
<h3 id="反射方法"><a href="#反射方法" class="headerlink" title="反射方法"></a>反射方法</h3><p>hasattr：判断实例中是否存在指定输入的方法</p>
<pre><code>hasattr(server,sys.argv[1])  返回值是布尔型 True or False
</code></pre><p>getattr:获取实例中的方法</p>
<pre><code>func = getattr(server,sys.argv[1])  获取对象方法的内存地址
</code></pre><p>setattr:将自定义的某个方法设定到特定实例中去使用</p>
<pre><code>setattr(server,&apos;run&apos;,test_run) 将特定方法test_run绑定给实例server，并重命名为run方法
server.run()  实例server可以指定调用方法run
</code></pre><p>delattr:删除实例的成员变量或者类的方法，不能删除实例的方法</p>
<pre><code>#delattr可以删除类的方法、实例的成员变量
# delattr(server,&apos;start&apos;) #尝试删除实例的方法是错误的
# delattr(server,&quot;host&quot;) #删除实例的变量
# delattr(Webserver,&apos;start&apos;)
# server.start() #AttributeError: &apos;Webserver&apos; object has no attribute &apos;start&apos;
</code></pre><p>完整示例代码：</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;

import sys
class Webserver(object):
    &apos;&apos;&apos;
    定义一个web server启动、关闭类
    &apos;&apos;&apos;
    def __init__(self,host,port):
        &apos;&apos;&apos;
        初始化类
        :param host: 主机地址
        :param port: 主机端口号
        :return:
        &apos;&apos;&apos;
        self.host = host
        self.port = port
    def start(self):
        &apos;&apos;&apos;
        服务启动方法
        :return:
        &apos;&apos;&apos;
        print(&quot;service is starting...&quot;)

    def stop(self):
        &apos;&apos;&apos;
        服务停止方法
        :return:
        &apos;&apos;&apos;
        print(&quot;service is stopping ...&quot;)

    def restart(self):
        &apos;&apos;&apos;
        服务重启方法
        :return:
        &apos;&apos;&apos;
        self.stop()
        self.start()

#定义一个特殊运行的函数，绑定到实例server上去
def test_run():
    print(&quot;测试运行...&quot;)

server = Webserver(&quot;localhost&quot;,80)
if hasattr(server,sys.argv[1]):
    func = getattr(server,sys.argv[1])
    func()
#setattr主要作用是将一个单独定义的函数添加到实例中，对于类或者其他实例而言，该函数对其不生效
setattr(server,&apos;run&apos;,test_run)
server.run()

#delattr可以删除类的方法、实例的成员变量
# delattr(server,&apos;start&apos;) #尝试删除实例的方法是错误的
# delattr(server,&quot;host&quot;) #删除实例的变量
# delattr(Webserver,&apos;start&apos;)
# server.start() #AttributeError: &apos;Webserver&apos; object has no attribute &apos;start&apos;
</code></pre><h2 id="二、socket网络编程"><a href="#二、socket网络编程" class="headerlink" title="二、socket网络编程"></a>二、socket网络编程</h2><h3 id="简单实现C-S交互实例："><a href="#简单实现C-S交互实例：" class="headerlink" title="简单实现C/S交互实例："></a>简单实现C/S交互实例：</h3><p>示例代码：</p>
<pre><code>实现简单的client与server端数据交互（一句话）
</code></pre><p>socket_server</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;

import socket

ip_port = (&quot;127.0.0.1&quot;,5000)
sk = socket.socket()
sk.bind(ip_port)
sk.listen(5)

while True:
    print(&quot;南非波波server is Listening....&quot;)
    conn,addr = sk.accept()
    client_data = conn.recv(1024)
    print(str(client_data,&quot;utf8&quot;))
    conn.sendall(bytes(&quot;落花不是无情物，化作春泥更护花！&quot;,&quot;utf8&quot;))
    conn.close()
</code></pre><p>socket_client</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;

import socket
ip_port = (&quot;127.0.0.1&quot;,5000)

sk = socket.socket()
sk.connect(ip_port)

sk.sendall(bytes(&quot;夕阳无限好，只是近黄昏&quot;,&quot;utf8&quot;))

server_reply = sk.recv(1024)
print(str(server_reply,&quot;utf8&quot;))
sk.close()
</code></pre><p>改善代码1：</p>
<pre><code>实现多个client与server进行串行交互
</code></pre><p>socket-server1 </p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;

import socket

ip_port = (&quot;127.0.0.1&quot;,5000)
sk = socket.socket()
sk.bind(ip_port)
sk.listen(5)

while True:
    print(&quot;南非波波server is Listening....&quot;)
    conn,addr = sk.accept()
    client_data = conn.recv(1024)
    print(str(client_data,&quot;utf8&quot;))
    # conn.sendall(bytes(&quot;落花不是无情物，化作春泥更护花！&quot;,&quot;utf8&quot;))
    while True:
        try:
            client_data = conn.recv(1024)
            if not client_data:
                break
            print(&quot;recv:&quot;,str(client_data,&quot;utf8&quot;))
            conn.send(client_data)
        except Exception:
            print(&quot;客户端断开!&quot;)
            break
    conn.close()
</code></pre><p>socket-client1</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;

import socket
ip_port = (&quot;127.0.0.1&quot;,5000)

sk = socket.socket()
sk.connect(ip_port)

# sk.sendall(bytes(&quot;夕阳无限好，只是近黄昏&quot;,&quot;utf8&quot;))

server_reply = sk.recv(1024)
print(str(server_reply,&quot;utf8&quot;))
while True:
    client_data = input(&quot;&gt;&gt;:&quot;).strip()
    if not client_data:
        continue
    if client_data == &apos;q&apos;:
        break
    sk.send(bytes(client_data,&quot;utf8&quot;))
    print(client_data)
sk.close()
</code></pre><p>最终代码：</p>
<pre><code>实现简单的ssh命令交互，获取Linux系统的相关信息
</code></pre><p>socket-server2</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
import socket
import subprocess

ip_port = (&quot;127.0.0.1&quot;,5000)  #定义服务监听的ip地址和端口
ssh = socket.socket()
ssh.bind(ip_port) #进行地址和端口绑定
ssh.listen(5) #设定做多5个并发连接

while True:
    print(&quot;南非波波Server is waiting...&quot;)
    conn,addr = ssh.accept()
    while True:
        client_data = conn.recv(1024)  #介绍client发过来的数据，最大接收字节1024
        if not client_data: #如果client_data为空，则跳出循环
            break
        cmd = str(client_data,&quot;utf8&quot;) #获取client_data数据并进行类型和编码转换
        print(&quot;server recv:&quot;,cmd)
        cmd_call = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE) #以原生shell命令的形式指定client的强求指定，并将结果输出到cmd_result
        cmd_result = cmd_call.stdout.read()
        if len(cmd_result) == 0: #如果命令没有结果返回，则需要给client返回一个提示，否则控制台会阻塞
            cmd_result = b&quot;cmd execution has no output..&quot;

        #client不能一次性接收过多的数据包，需要server端先告知client端需要传输的数据多少。然后由client端分开接收
        ack_msg = bytes(&quot;CMD_RESULT_SIZE|%s&quot; % len(cmd_result),&quot;utf8&quot;) #发送数据传输认证标志
        conn.send(ack_msg)
        client_ack = conn.recv(50)
        if client_ack.decode() == &apos;CLIENT_READY_TO_RECV&apos;:
            conn.send(cmd_result) #数据传输
    conn.close()
</code></pre><p>socket-client2</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
import socket

ip_port = (&quot;127.0.0.1&quot;,5000)
ssh_client = socket.socket()
ssh_client.connect(ip_port)

while True:
    user_input = input(&quot;ssh-client:&quot;).strip()
    if len(user_input) == 0:
        continue
    if user_input == &apos;q&apos;:
        break
    ssh_client.send(bytes(user_input,&apos;utf8&apos;))
    #ack_msg = b&quot;CMD_RESULT_SIZE|%s&quot; % len(cmd_result)
    server_ack_msg = ssh_client.recv(100)
    cmd_res_msg = str(server_ack_msg.decode()).split(&quot;|&quot;)
    if cmd_res_msg[0] == &quot;CMD_RESULT_SIZE&quot;:
        cmd_res_size = int(cmd_res_msg[1])
        ssh_client.send(b&quot;CLIENT_READY_TO_RECV&quot;)
    res = &apos;&apos;
    received_size = 0
    while received_size &lt; cmd_res_size:
        server_data = ssh_client.recv(500)
        received_size += len(server_data)
        res += str(server_data.decode())
    else:
        print(res)
        print(&quot;-----------recv don----------&quot;)
ssh_client.close()
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python自动化开发 day06]]></title>
      <url>http://blog.songqingbo.cn/2016/02/20/s12-20160130-day06/</url>
      <content type="html"><![CDATA[<p>Author:@南非波波</p>
<p>课程大纲：</p>
<p>day05</p>
<p><a href="http://www.cnblogs.com/alex3714/articles/5161349.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5161349.html</a></p>
<p>day06</p>
<p><a href="http://www.cnblogs.com/alex3714/articles/5188179.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5188179.html</a></p>
<h2 id="一、模块回顾"><a href="#一、模块回顾" class="headerlink" title="一、模块回顾"></a>一、模块回顾</h2><h3 id="1-os模块"><a href="#1-os模块" class="headerlink" title="1. os模块"></a>1. os模块</h3><h3 id="2-sys模块"><a href="#2-sys模块" class="headerlink" title="2. sys模块"></a>2. sys模块</h3><h3 id="3-shutil模块"><a href="#3-shutil模块" class="headerlink" title="3. shutil模块"></a>3. shutil模块</h3><p>高级的 文件、文件夹、压缩包 处理模块</p>
<p>shutil.copyfileobj(fsrc, fdst[, length])</p>
<pre><code>功能：将文件内容拷贝到另一个文件中，可以部分内容
</code></pre><p>shutil.copyfile(src, dst)</p>
<pre><code>功能：仅拷贝文件
</code></pre><p>shutil.copymode(src, dst)</p>
<pre><code>功能：仅拷贝权限，内容、组、用户均不变
</code></pre><p>shutil.copystat(src, dst)</p>
<pre><code>功能：拷贝状态的信息，包括：mode bits, atime, mtime, flags
</code></pre><p>shutil.copy(src, dst)</p>
<pre><code>功能：拷贝文件和权限
</code></pre><p>shutil.copy2(src, dst)</p>
<pre><code>功能：拷贝文件和状态信息

1. zipfile


2. tarfile
</code></pre><h3 id="4-shelve模块"><a href="#4-shelve模块" class="headerlink" title="4. shelve模块"></a>4. shelve模块</h3><p>二次封装pickle模块功能，对比pickle而言，shelve实现了按照‘键’来取值</p>
<p>示例：</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
import shelve

name = [&apos;swht&apos;,&apos;shen&apos;,&apos;test&apos;]
class Test(object):
    def __init__(self,n):
        self.n = n
t1 = Test(1234)
t2 = Test(123456)

#存数据
# shelve_file = shelve.open(&apos;ret.txt&apos;)
# shelve_file[&apos;use&apos;] = name
# shelve_file[&apos;t1&apos;] = t1
# shelve_file[&apos;t2&apos;] = t2
# shelve_file.close()

#取数据
shelve_load = shelve.open(&apos;ret.txt&apos;)
a = shelve_load.get(&apos;use&apos;)
print(a)
b = shelve_load.get(&apos;t1&apos;)
print(b.n)
c = shelve_load.get(&apos;t2&apos;)
print(c.n)
shelve_load.close()
</code></pre><h3 id="5-configparser模块"><a href="#5-configparser模块" class="headerlink" title="5.configparser模块"></a>5.configparser模块</h3><p>示例：</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
import configparser

#生成文档
#[&quot;DEFAULT&quot;]是一个全局模块，对所有的模块生效
&apos;&apos;&apos;
config = configparser.ConfigParser()
config[&quot;DEFAULT&quot;] = {&apos;ServerAliveInterval&apos;: &apos;45&apos;,
                      &apos;Compression&apos;: &apos;yes&apos;,
                     &apos;CompressionLevel&apos;: &apos;9&apos;}

config[&apos;bitbucket.org&apos;] = {}
config[&apos;bitbucket.org&apos;][&apos;User&apos;] = &apos;hg&apos;
config[&apos;topsecret.server.com&apos;] = {}
topsecret = config[&apos;topsecret.server.com&apos;]
topsecret[&apos;Host Port&apos;] = &apos;50022&apos;     # mutates the parser
topsecret[&apos;ForwardX11&apos;] = &apos;no&apos;  # same here
config[&apos;DEFAULT&apos;][&apos;ForwardX11&apos;] = &apos;yes&apos;
with open(&apos;example.ini&apos;, &apos;w&apos;) as configfile:
   config.write(configfile)
&apos;&apos;&apos;

#查询
&apos;&apos;&apos;
config = configparser.ConfigParser()
config.read(&apos;example.ini&apos;)
print(config.sections())  #[&apos;bitbucket.org&apos;, &apos;topsecret.server.com&apos;]
if &apos;bitbucket.org&apos; in config:
    print(&apos;True&apos;)
print(&quot;[&apos;bitbucket.org&apos;][&apos;User&apos;]:&quot;,config[&apos;bitbucket.org&apos;][&apos;User&apos;])
print(&quot;[&apos;bitbucket.org&apos;][&apos;Compression&apos;]:&quot;,config[&apos;bitbucket.org&apos;][&apos;Compression&apos;])
for key in config[&apos;bitbucket.org&apos;]:
    print(key)
&apos;&apos;&apos;
#读
&apos;&apos;&apos;
config = configparser.ConfigParser()
config.read(&apos;example.ini&apos;)
secs = config.sections()
print(secs) #[&apos;bitbucket.org&apos;, &apos;topsecret.server.com&apos;]

options = config.options(&apos;topsecret.server.com&apos;)
print(options) #[&apos;host port&apos;, &apos;forwardx11&apos;, &apos;compression&apos;, &apos;serveraliveinterval&apos;, &apos;compressionlevel&apos;]

item_list = config.items(&apos;bitbucket.org&apos;)
print(item_list) #[(&apos;compression&apos;, &apos;yes&apos;), (&apos;serveraliveinterval&apos;, &apos;45&apos;), (&apos;compressionlevel&apos;, &apos;9&apos;), (&apos;forwardx11&apos;, &apos;yes&apos;), (&apos;user&apos;, &apos;hg&apos;)]

val = config.get(&apos;bitbucket.org&apos;,&apos;compression&apos;)
print(val)
&apos;&apos;&apos;

#改写
config = configparser.ConfigParser()
config.read(&apos;example.ini&apos;)

#实现从原来的文件中读取，删除[bitbucket.org]模块后将其他内容写到example_new.ini文件中
# sec = config.remove_section(&apos;bitbucket.org&apos;)
# config.write(open(&apos;example_new.ini&apos;, &quot;w&quot;))

#添加[swht]模块
# sec = config.has_section(&apos;swht&apos;)
# sec = config.add_section(&apos;swht&apos;)
# config.write(open(&apos;example_new1.ini&apos;, &quot;w&quot;))
</code></pre><h3 id="6-hashlib模块"><a href="#6-hashlib模块" class="headerlink" title="6. hashlib模块"></a>6. hashlib模块</h3><p>该模块提供了多个算法对字符串进行加密操作。</p>
<p>示例代码：</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
import hashlib

&apos;&apos;&apos;
#md5加密
md5num = hashlib.md5()
md5num.update(b&quot;shendiaoxia1278@sohu.com&quot;)
print(md5num.hexdigest()) #7e023c9fafc96423da854e4923f466a1
&apos;&apos;&apos;

&apos;&apos;&apos;
#sha1加密
sha1num = hashlib.sha1()
sha1num.update(b&quot;shendiaoxia1278@sohu.com&quot;)
print(sha1num.hexdigest()) #dd8d5deaa16c2dde03785aac99943f8f75bfaba9
&apos;&apos;&apos;

&apos;&apos;&apos;
#sha256加密
hash = hashlib.sha256()
hash.update(b&quot;shendiaoxia1278@sohu.com&quot;)
print(hash.hexdigest()) #14b03e2271da2cc9b0cc3ff73727c6d3ba6ba17077470a92162f7b46c9d1d968
&apos;&apos;&apos;

&apos;&apos;&apos;
#sha384加密
hash = hashlib.sha384()
hash.update(b&quot;shendiaoxia1278@sohu.com&quot;)
print(hash.hexdigest()) #a27bbc0d66d6b8b00a7ebfcad662ebed385fe2098898dfe23b88ffa88e1b6565d82e7eee5c9950c90231d0c0aa286e00
&apos;&apos;&apos;

&apos;&apos;&apos;
#sha512加密
hash = hashlib.sha512()
hash.update(b&quot;shendiaoxia1278@sohu.com&quot;)
print(hash.hexdigest()) #42bb1886bba49373c8f8177fba32a58a1f31af7272219789db52776428789f4a39970da9a36fdef6ab76651ed9f07e0fa140e4fa7dd325cb52559389bb80ceab
&apos;&apos;&apos;
</code></pre><p>高级加密代码</p>
<pre><code>&apos;&apos;&apos;
# import hashlib

# ######## md5 #######
hash = hashlib.md5(b&apos;898oaFs09f&apos;)
hash.update(b&quot;shendiaoxia1278@sohu.com&quot;)
print(hash.hexdigest()) #2aa29d812ca08b39d96f9441775420ba
&apos;&apos;&apos;

&apos;&apos;&apos;
import hmac

#可以使用在用户登录的时候，使用用户输入的用户名和密码进行加密后作为用户的密码

hash = hmac.new(b&quot;shendiaoxia1278@sohu.com&quot;)
hash.update(b&quot;swht&quot;)
print(hash.hexdigest()) #c65d9bc3f37d6cfb9a9c959a18463bf4

&apos;&apos;&apos;
</code></pre><h3 id="7-subprocess模块"><a href="#7-subprocess模块" class="headerlink" title="7. subprocess模块"></a>7. subprocess模块</h3><pre><code>1. python2.7

    import subprocess
    #默认状态shell = False，必须使用一个列表的方式将shell命令传递进去
    ret = subprocess.call([&quot;ls&quot;, &quot;-l&quot;], shell=False)
    #使用shell = True告诉subprocess模块对用户传入的shell命令不转义，即使用原生shell命令
    ret = subprocess.call(&quot;ls -l&quot;, shell=True)


2. python3.5
</code></pre><h4 id="8-logging模块"><a href="#8-logging模块" class="headerlink" title="8. logging模块"></a>8. logging模块</h4><p>示例：</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
import logging

# logging.warning(&quot;user [swht] is start the systerm!&quot;)
# logging.critical(&quot;server is down!&quot;)
#创建日志
logger = logging.getLogger(&apos;[Test-Log]&apos;)
logger.setLevel(logging.DEBUG) #全局级别优先级较高

#创建一个控制台的handler并设置日志级别
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)

#创建一个文件的handler并设置日志级别
fh = logging.FileHandler(&quot;access.log&quot;)
fh.setLevel(logging.WARNING)
#创建日期格式

fomatter = logging.Formatter(&apos;%(asctime)s %(name)s %(levelname)s %(message)s&apos;,datefmt=&apos;%Y-%m-%d %H:%M:%S&apos;)

#add formatter to ch and fh
ch.setFormatter(fomatter)
fh.setFormatter(fomatter)

logger.addHandler(ch)
logger.addHandler(fh)

# &apos;application&apos; code
logger.debug(&apos;debug message&apos;)
logger.info(&apos;info message&apos;)
logger.warn(&apos;warn message&apos;)
logger.error(&apos;error message&apos;)
logger.critical(&apos;critical message&apos;)

#输出格式：
&apos;&apos;&apos;
2016-02-20 16:53:27 [Test-Log] DEBUG debug message
2016-02-20 16:53:27 [Test-Log] INFO info message
2016-02-20 16:53:27 [Test-Log] WARNING warn message
2016-02-20 16:53:27 [Test-Log] ERROR error message
2016-02-20 16:53:27 [Test-Log] CRITICAL critical message
&apos;&apos;&apos;
</code></pre><h2 id="二、面向对象编程"><a href="#二、面向对象编程" class="headerlink" title="二、面向对象编程"></a>二、面向对象编程</h2><h3 id="1-面向对象的介绍"><a href="#1-面向对象的介绍" class="headerlink" title="1. 面向对象的介绍"></a>1. 面向对象的介绍</h3><pre><code>1.    不要写重复的代码
2.    代码易扩展，程序遵循易读、易改的原则
</code></pre><h3 id="2-面向对象的特性"><a href="#2-面向对象的特性" class="headerlink" title="2. 面向对象的特性"></a>2. 面向对象的特性</h3><pre><code>1.    封装
2.    继承
    1.    基类或父类或超类
    2.    子类或派生类
    一般情况下，一个子类只能有一个基类，但在python中，一个子类是可以继承多个基类，实现多重继承，可以通过多级继承来实现；继承的过程就是从一般到特殊的过程
3.    多态
    实现接口的重用
</code></pre><h3 id="3-类、方法"><a href="#3-类、方法" class="headerlink" title="3. 类、方法"></a>3. 类、方法</h3><h4 id="类-class"><a href="#类-class" class="headerlink" title="类 class"></a>类 class</h4><p>示例：</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
class Role(object):
    def __init__(self,name,role,weapon,life_value):
        self.name = name
        self.role = role
        self.weapon = weapon
        self.life_value = life_value
    def buy_weapon(self,weapon):
        self.weapon = weapon
        print(&quot;%s 成功购买[%s]&quot; % (self.name,weapon))

#实例化
p1 = Role(&apos;swht&apos;,&apos;p&apos;,&apos;A11&apos;,100)
t1 = Role(&apos;shen&apos;,&apos;t&apos;,&apos;A11&apos;,100)

print(&quot;p1[weapon]初始值:&quot;,p1.weapon)
print(&quot;t1[weapon]初始值:&quot;,t1.weapon)

#买枪行为
p1.buy_weapon(&quot;AK65&quot;)
t1.buy_weapon(&quot;AK60&quot;)

print(&quot;p1[weapon]当前值:&quot;,p1.weapon)
print(&quot;t1[weapon]当前值:&quot;,t1.weapon)
</code></pre><h4 id="作业："><a href="#作业：" class="headerlink" title="作业："></a>作业：</h4><pre><code>模拟人生游戏

    1.    至少有两个不同的角色
    2.    玩的过程中，必须有交互
    3.    根据不同的交互产生不同的行为
    4.    一定要用到面向对象编程的语法及思想
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python自动化开发 day05]]></title>
      <url>http://blog.songqingbo.cn/2016/01/30/s12-20160130-day05/</url>
      <content type="html"><![CDATA[<p>Author:@南非波波</p>
<p>课程大纲：</p>
<p>day04</p>
<p><a href="http://www.cnblogs.com/alex3714/articles/5143440.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5143440.html</a></p>
<p>day05</p>
<p><a href="http://www.cnblogs.com/alex3714/articles/5161349.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5161349.html</a></p>
<h2 id="一、正则深入"><a href="#一、正则深入" class="headerlink" title="一、正则深入"></a>一、正则深入</h2><h3 id="re"><a href="#re" class="headerlink" title="re"></a>re</h3><p>匹配数字开头</p>
<pre><code>import re
#匹配以数字开头
p = re.compile(&quot;^[0-9]&quot;) #使用compile进行编译正则表达式，在大量匹配处理的时候非常有效
m = p.match(&quot;14534Abc&quot;)
print(m.group()) #输出结果：1
&apos;&apos;&apos;
m = re.match(&quot;^[0-9]&quot;,&quot;14534Abc&quot;)
print(m.group()) #输出结果：1
&apos;&apos;&apos;
</code></pre><p>匹配数字、字母等开头</p>
<pre><code>import re
#匹配以数字和字母开头
p = re.compile(&quot;^[0-9A-Za-z]&quot;)
m = p.match(&quot;AK14534Abc&quot;)
print(m.group()) #输出结果：A
</code></pre><p>匹配IP地址：</p>
<pre><code>#匹配IP地址
string = &apos;180.115.183.45 - - [03/Feb/2016:10:35:50 +0800] &quot;CONNECT imppl.tradedoubler.com:443 HTTP/1.0&quot; 400 172 &quot;-&quot; &quot;-&quot;&apos;
p = re.compile(&quot;([0-9]{1,3}\.){3}\d{1,3}&quot;)
ip = p.match(string).group()
# ip = re.match(&quot;([0-9]{1,3}\.){3}\d{1,3}&quot;,string).group()
print(ip)
</code></pre><p><strong>正则表达式常用5种操作</strong></p>
<p>re.match(pattern,string) #从头匹配</p>
<p>re.search(pattern,string) #匹配整个字符串，直到找到一个匹配</p>
<p>re.split() #将匹配到的格式当做分隔点对字符串分成列表类型</p>
<pre><code>示例：
import re
string = &quot;2016 02 02  00:26:35 Statistic_Svncommit.py[line:50] INFO [&apos;A6909850956019&apos;, &apos;A6997448878578&apos;, &apos;A6909712867884&apos;, &apos;A6996408725555&apos;, &apos;A6908651568946&apos;, &apos;A6996150172637&apos;, &apos;A6909747538711&apos;, &apos;A6994084740002&apos;, &apos;A6908427730549&apos;, &apos;A6982187752993&apos;, &apos;A6909861345295&apos;, &apos;A6909860252981&apos;, &apos;A6905214359647&apos;, &apos;A6995115894134&apos;]&quot;
strlist = re.search(&quot;\[\&apos;.*?\&apos;\]&quot;,string).group().lstrip(&quot;[&quot;).rstrip(&quot;]&quot;)
list1 = re.sub(&quot;[\&apos;&apos; &apos;]&quot;,&quot;&quot;,strlist).split(&quot;,&quot;)
print(list1)

返回结果：[&apos;A6909850956019&apos;, &apos;A6997448878578&apos;, &apos;A6909712867884&apos;, &apos;A6996408725555&apos;, &apos;A6908651568946&apos;, &apos;A6996150172637&apos;, &apos;A6909747538711&apos;, &apos;A6994084740002&apos;, &apos;A6908427730549&apos;, &apos;A6982187752993&apos;, &apos;A6909861345295&apos;, &apos;A6909860252981&apos;, &apos;A6905214359647&apos;, &apos;A6995115894134&apos;]
列表类型

m = re.split(&quot;[0-9]&quot;, &quot;swht1swht2jack3helenrachel8&quot;)
print(m) #[&apos;swht&apos;, &apos;swht&apos;, &apos;jack&apos;, &apos;helenrachel&apos;, &apos;&apos;]
</code></pre><p>re.findall()　# 找到所有要匹配的字符并返回列表格式</p>
<pre><code>示例：
import re
string = &quot;sdsdss(welcome)dff(china)&quot;
m = re.findall(&apos;\(.*?\)&apos;,string) #匹配所有以（开头和以）结尾的字符串,返回类型为list
print(m) #[&apos;(welcome)&apos;, &apos;(china)&apos;]
print(type(m))  #&lt;class &apos;list&apos;&gt;
</code></pre><p>re.sub(pattern, repl, string, count,flag) # 替换匹配到的字符</p>
<pre><code>示例：
import re
string = &quot;sdsdss(welcome)dff(china)&quot;
m = re.sub(&quot;\(|\)&quot;,&quot;\&quot;&quot;,string) #匹配&quot;(&quot;或者&quot;)&quot;，然后将其替换成双引号
print(m) #sdsdss&quot;welcome&quot;dff&quot;china&quot;
print(type(m)) #&lt;class &apos;str&apos;&gt;
</code></pre><p><strong>模式</strong></p>
<p>re.I #大小写不敏感</p>
<pre><code>import rz
string = &quot;swht&quot;
m = re.search(&quot;[A-Z]&quot;,string,flags = re.I)
print(m.group()) #s
</code></pre><h4 id="匹配手机号："><a href="#匹配手机号：" class="headerlink" title="匹配手机号："></a>匹配手机号：</h4><pre><code>import re
string = &quot;sdssaawa15865921165sdsdscf&quot;
m = re.search(&quot;(1)([358]\d{9})&quot;,string)
print(m.group())
</code></pre><h4 id="匹配IP地址"><a href="#匹配IP地址" class="headerlink" title="匹配IP地址:"></a>匹配IP地址:</h4><pre><code>import re
ip_addr = &quot;inet 192.168.60.223 netmask 0xffffff00 broadcast 192.168.60.255&quot;
IP = re.search(&quot;(([1-9]|[1-9][0-9]|[1][0-9][0-9]|[2][0-5][0-5])\.){3}[0-9]{1,3}&quot;,ip_addr)
print(IP.group()) #192.168.60.223
</code></pre><h4 id="匹配邮箱地址："><a href="#匹配邮箱地址：" class="headerlink" title="匹配邮箱地址："></a>匹配邮箱地址：</h4><pre><code>import re
emailstr = &quot;qingbo.song@gmail.com www.baidu.com&quot;
email = re.search(&quot;^[a-z]([0-9a-z]|\.){4,20}@[0-9a-z]{0,10}\.[0-9a-z]{0,8}&quot;,emailstr)
print(email.group()) #qingbo.song@gmail.com

#只匹配gmail邮箱
import
emailstr = &quot;qingbo.song@gmail.com www.baidu.com&quot;
email = re.search(&quot;^[a-z]([0-9a-z]|\.){4,20}@gmail\.com&quot;,emailstr)
if email:
    print(email.group()) #qingbo.song@gmail.com
else:
    print(&quot;系统只接受gamil邮箱注册,感谢你的支持!&quot;)
</code></pre><h2 id="二、冒泡排序算法"><a href="#二、冒泡排序算法" class="headerlink" title="二、冒泡排序算法"></a>二、冒泡排序算法</h2><pre><code>示例代码：
#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;

li = [11,78,45,12,90,34,56]

# for m in range(1,len(li)):
#     for i in range(len(li) - 1):
#         if li[i] &gt; li[i+1]:
#             temp = li[i]
#             li[i] = li[i+1]
#             li[i+1] = temp
# print(li)

for m in range(len(li) - 1):
    for n in range(m+1,len(li)):
        if li[m] &gt; li[n]:
            temp = li[m]
            li[m] = li[n]
            li[n] = temp
print(li) #[11, 12, 34, 45, 56, 78, 90]

#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;

data = [11,78,45,12,90,34,56]
for i in range(1,len(data)):
    for j in range(len(data) - i):
        if data[j] &gt; data[j+1]:
            tmp = data[j]
            data[j+1] = data[j]
            data[j] = tmp
print(data)
</code></pre><h2 id="三、模块"><a href="#三、模块" class="headerlink" title="三、模块"></a>三、模块</h2><h3 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h3><pre><code>模块：用一坨代码实现了某个功能的代码集合。
类似于函数式编程和面向过程编程，函数式编程则完成一个功能，其他代码用来处理和代码间的耦合。可能需要多个.py的文件组成。

模块类型：
    1. 自定义模块
    2. 内置标准模块（标准库）
    3. 开源模块
        1. 下载：
            1. yum
            2. apt-get
            3. pip
            4. easy_install
            5. 源码编译安装 python stup.py install
</code></pre><h3 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h3><pre><code>import module
from module.xx.xx import xx
from module.xx.xx import xx as rename  
#不推荐下面的导入方式，如果被导入的模块中含有与当前文件中相同名称的函数，容易产生调用混乱。
from module.xx.xx import * 
</code></pre><h2 id="四、自定义模块"><a href="#四、自定义模块" class="headerlink" title="四、自定义模块"></a>四、自定义模块</h2><h3 id="模块框架"><a href="#模块框架" class="headerlink" title="模块框架"></a>模块框架</h3><pre><code>1. backend
    1. logic
        handle.py
            #!/usr/local/env python3
            &apos;&apos;&apos;
            Author:@南非波波
            Blog:http://www.cnblogs.com/songqingbo/
            E-mail:qingbo.song@gmail.com
            &apos;&apos;&apos;
            from backend.database.sql_select import select
            def home():
                print(&quot;welcome to home page!&quot;)
                q_data = select(&quot;user&quot;,&quot;test&quot;)
                print(&quot;query res:%s&quot; % q_data)

            def tv():
                print(&quot;welcome to tv page!&quot;)

            def moive():
                print(&quot;welcome to moive page!&quot;)
    2. database
        1. sql_select.py
            #!/usr/local/env python3
            &apos;&apos;&apos;
            Author:@南非波波
            Blog:http://www.cnblogs.com/songqingbo/
            E-mail:qingbo.song@gmail.com
            &apos;&apos;&apos;
            &apos;&apos;&apos;
            增加模块的路径。下面的语句增加的是dj路径
            该功能解决的是在子模块中的文件单独调试的时候无法获取父模块路径，导致在导入其他模块的时候报错
            &apos;&apos;&apos;
            import sys,os
            #获取dj的绝对路径
            base_dir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
            #将获取的路径添加到系统环境变量中
            sys.path.append(base_dir)


            from config import settings
            from backend.database.user_auth import db_auth

            def select(table,column):
                if db_auth(settings):
                    if table == &quot;user&quot;:
                        user_info = {
                            &quot;001&quot;:[&quot;swht&quot;,24,&quot;yunwei&quot;],
                            &quot;002&quot;:[&quot;shen&quot;,26,&quot;dba&quot;],
                            &quot;003&quot;:[&quot;test&quot;,28,&quot;student&quot;],
                        }
                        return user_info
        2. user_auth.py
            #!/usr/local/env python3
            &apos;&apos;&apos;
            Author:@南非波波
            Blog:http://www.cnblogs.com/songqingbo/
            E-mail:qingbo.song@gmail.com
            &apos;&apos;&apos;
            def db_auth(configs):
                if configs.DATABASES[&quot;user&quot;] == &quot;root&quot; and configs.DATABASES[&quot;password&quot;] == 123:
                    print(&quot;验证通过!&quot;)
                    return True
                else:
                    print(&quot;验证错误!&quot;)

2. frontend
3. config
    settings
        #!/usr/local/env python3
        &apos;&apos;&apos;
        Author:@南非波波
        Blog:http://www.cnblogs.com/songqingbo/
        E-mail:qingbo.song@gmail.com
        &apos;&apos;&apos;

        DATABASES = {
            &quot;engine&quot;:&quot;mysql&quot;,
            &quot;host&quot;:&quot;localhost&quot;,
            &quot;port&quot;:3306,
            &quot;user&quot;:&quot;root&quot;,
            &quot;password&quot;:123,
        }
4. user_main.py
    #!/usr/local/env python3
    &apos;&apos;&apos;
    Author:@南非波波
    Blog:http://www.cnblogs.com/songqingbo/
    E-mail:qingbo.song@gmail.com
    &apos;&apos;&apos;

    from backend.logic import handle

    handle.home()
</code></pre><h2 id="五、标准模块"><a href="#五、标准模块" class="headerlink" title="五、标准模块"></a>五、标准模块</h2><p>参考：<a href="http://www.cnblogs.com/wupeiqi/articles/4963027.html" target="_blank" rel="external">http://www.cnblogs.com/wupeiqi/articles/4963027.html</a></p>
<h3 id="time-amp-datetime模块"><a href="#time-amp-datetime模块" class="headerlink" title="time &amp; datetime模块"></a>time &amp; datetime模块</h3><pre><code>import time
import datetime

#作用：计算一个程序从执行到结束用的时间 
print(time.clock()) #返回处理器时间,3.3开始已废弃
print(time.process_time()) #返回处理器时间,3.3开始已废弃

#获取系统的当前时间，从1970年1月1日0：00到当前时间的秒数
print(time.time()) #返回当前系统时间戳

#格式化输出的时间
print(time.ctime()) #输出Tue Jan 26 18:23:48 2016 ,当前系统时间
print(time.ctime(time.time()-86640)) #将时间戳转为字符串格式，输出昨天的时间Tue Jan 25 18:23:48 2016

#time.struct_time(tm_year=2016, tm_mon=2,c=48, tm_wday=5, tm_yday=44, tm_isdst=0)
#gmtime是从零时区算起的格林时间
print(time.gmtime(time.time()-86640)) #将时间戳转换成struct_time格式
#当前时间，是按照系统当前时区算起的
print(time.localtime(time.time()-86640)) #将时间戳转换成struct_time格式,但返回 的本地时间
print(time.mktime(time.localtime())) #与time.localtime()功能相反,将struct_time格式转回成时间戳格式
#time.sleep(4) #sleep

#格式化输出时间
print(time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,time.gmtime()) ) #将struct_time格式转成指定的字符串格式
#time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,time.localtime())
#&apos;2016-02-14 12:45:49&apos;

print(time.strptime(&quot;2016-01-28&quot;,&quot;%Y-%m-%d&quot;) ) #将字符串格式转换成struct_time格式

#datetime module

#将时间戳转换成日期格式
print(datetime.date.today()) #输出格式python2 2016-01-26  python3：datetime.date(2016, 2, 14)
print(datetime.date.fromtimestamp(time.time()-864400) ) #2016-01-16 将时间戳转成日期格式
current_time = datetime.datetime.now() #
print(current_time) #输出2016-01-26 19:04:30.335935
print(current_time.timetuple()) #返回struct_time格式

#datetime.replace([year[, month[, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]]]]])
#将当前的时间替换成输入的时间
print(current_time.replace(2014,9,12)) #输出2014-09-12 19:06:24.074900,返回当前时间,但指定的值将被替换

str_to_date = datetime.datetime.strptime(&quot;21/11/06 16:30&quot;, &quot;%d/%m/%y %H:%M&quot;) #将字符串转换成日期格式
new_date = datetime.datetime.now() + datetime.timedelta(days=10) #比现在加10天
new_date = datetime.datetime.now() + datetime.timedelta(days=-10) #比现在减10天
new_date = datetime.datetime.now() + datetime.timedelta(hours=-10) #比现在减10小时
new_date = datetime.datetime.now() + datetime.timedelta(seconds=120) #比现在+120s
print(new_date)
</code></pre><h3 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a>random模块</h3><h4 id="产生随机数"><a href="#产生随机数" class="headerlink" title="产生随机数"></a>产生随机数</h4><pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
import random

#产生随机小数
print(random.random())
&apos;&apos;&apos;
0.8426794741026359
0.8703558703687821
&apos;&apos;&apos;

#产生随机整数
print(random.randint(1,10))
print(random.randrange(1,10))
&apos;&apos;&apos;
1
9
&apos;&apos;&apos;
</code></pre><h4 id="生成随机验证码"><a href="#生成随机验证码" class="headerlink" title="生成随机验证码"></a>生成随机验证码</h4><pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
&apos;&apos;&apos;
生成n位随机数，包含大写字母和数字
&apos;&apos;&apos;
import random
def checkcode(n):
    checkcode = &apos;&apos;
    for i in range(n):
        current = random.randrange(0,4)
        if current != i:
            tmp = chr(random.randint(65,90))
        else:
            tmp = random.randint(0,9)
        checkcode += str(tmp)
    return checkcode

print(checkcode(6))
</code></pre><h3 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h3><p>提供对操作系统进行调用的接口</p>
<pre><code>os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径
os.chdir(&quot;dirname&quot;)  改变当前脚本工作目录；相当于shell下cd
os.curdir  返回当前目录: (&apos;.&apos;)
os.pardir  获取当前目录的父目录字符串名：(&apos;..&apos;)
os.makedirs(&apos;dirname1/dirname2&apos;)    可生成多层递归目录
os.removedirs(&apos;dirname1&apos;) 删除空的目录，或多级空目录
os.mkdir(&apos;dirname&apos;)    生成单级目录；相当于shell中mkdir dirname
os.rmdir(&apos;dirname&apos;)    删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname
os.listdir(&apos;dirname&apos;)    列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印
os.remove()  删除一个文件
os.rename(&quot;oldname&quot;,&quot;newname&quot;)  重命名文件/目录，或者移动，相当于shell命令mv
os.stat(&apos;path/filename&apos;)  获取文件/目录信息
os.sep    输出操作系统特定的路径分隔符，win下为&quot;\\&quot;,Linux下为&quot;/&quot;
os.linesep    输出当前平台使用的行终止符，win下为&quot;\t\n&quot;,Linux下为&quot;\n&quot;
os.pathsep    输出用于分割文件路径的字符串
os.name    输出字符串指示当前使用平台。win-&gt;&apos;nt&apos;; Linux-&gt;&apos;posix&apos;
os.system(&quot;bash command&quot;)  运行shell命令，直接显示，只是单个shell命令的执行
os.environ  获取系统环境变量
os.path.abspath(path)  返回path规范化的绝对路径
os.path.split(path)  将path分割成目录和文件名二元组返回
os.path.dirname(path)  返回path的目录。其实就是os.path.split(path)的第一个元素
os.path.basename(path)  返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素
os.path.exists(path)  如果path存在，返回True；如果path不存在，返回False
os.path.isabs(path)  如果path是绝对路径，返回True
os.path.isfile(path)  如果path是一个存在的文件，返回True。否则返回False
os.path.isdir(path)  如果path是一个存在的目录，则返回True。否则返回False
os.path.join(path1[, path2[, ...]])  将多个路径组合后返回，第一个绝对路径之前的参数将被忽略
os.path.getatime(path)  返回path所指向的文件或者目录的最后存取时间
os.path.getmtime(path)  返回path所指向的文件或者目录的最后修改时间
</code></pre><h3 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h3><pre><code>sys.argv           命令行参数List，第一个元素是程序本身路径
sys.exit(n)        退出程序，正常退出时exit(0)
sys.version        获取Python解释程序的版本信息
sys.maxint         最大的Int值
sys.path           返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值
sys.platform       返回操作系统平台名称
sys.stdout.write(&apos;please:&apos;)
val = sys.stdin.readline()[:-1] #输入一行内容，减去后面的最后一个\n
</code></pre><h4 id="使用sys和time模块生成进度条"><a href="#使用sys和time模块生成进度条" class="headerlink" title="使用sys和time模块生成进度条"></a>使用sys和time模块生成进度条</h4><pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
&apos;&apos;&apos;
生成进度条。调用函数输入的参数为进度条长度
&apos;&apos;&apos;
import sys,time
def processbar(rangenum):
    for i in range(rangenum):
        if i == 0:
            sys.stdout.write(&quot;0%[#&quot;)
        elif i == rangenum - 1:
            sys.stdout.write(&quot;#]100%&quot;)
        else:
            sys.stdout.write(&quot;#&quot;)
            #刷新缓存，使其实时显示出来
            sys.stdout.flush()
            time.sleep(0.5)

processbar(16)
</code></pre><h3 id="json-和-pickle"><a href="#json-和-pickle" class="headerlink" title="json 和 pickle"></a>json 和 pickle</h3><h4 id="json和pickle是用于序列化的两个模块："><a href="#json和pickle是用于序列化的两个模块：" class="headerlink" title="json和pickle是用于序列化的两个模块："></a>json和pickle是用于序列化的两个模块：</h4><pre><code>json：用于处理字符串和python数据类型间的转换
pickle：用于处理python特有类型和python数据类型间的转换
</code></pre><h4 id="json"><a href="#json" class="headerlink" title="json"></a>json</h4><pre><code>json模块提供了四个功能：dumps、dump、loads、load
json在所有的语言中都通用，存取的直接字符
</code></pre><h4 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h4><pre><code>pickle模块提供了四个功能：dumps、dump、loads、load
在python中独有一个模块，存取二进制字符
不仅仅可以序列化简单的字符、列表、字典，还能序列化函数、类以至于整个程序
</code></pre><h4 id="关于dump和dumps的区别"><a href="#关于dump和dumps的区别" class="headerlink" title="关于dump和dumps的区别"></a>关于dump和dumps的区别</h4><pre><code>dump直接将序列化后的字符写到文件中，dumps是将序列化后的字符先赋给一个变量，然后再有write方法将其写入到文件中
</code></pre><h4 id="关于load和loads的区别"><a href="#关于load和loads的区别" class="headerlink" title="关于load和loads的区别"></a>关于load和loads的区别</h4><pre><code>load直接从文件中读取内容，loads是从内存中获取文件的内容
</code></pre><h3 id="shutil模块"><a href="#shutil模块" class="headerlink" title="shutil模块"></a>shutil模块</h3><p>高级的 文件、文件夹、压缩包 处理模块</p>
<p>shutil.copyfileobj(fsrc, fdst[, length])</p>
<pre><code>功能：将文件内容拷贝到另一个文件中，可以部分内容
</code></pre><p>shutil.copyfile(src, dst)</p>
<pre><code>功能：仅拷贝文件
</code></pre><p>shutil.copymode(src, dst)</p>
<pre><code>功能：仅拷贝权限，内容、组、用户均不变
</code></pre><p>shutil.copystat(src, dst)</p>
<pre><code>功能：拷贝状态的信息，包括：mode bits, atime, mtime, flags
</code></pre><p>shutil.copy(src, dst)</p>
<pre><code>功能：拷贝文件和权限
</code></pre><p>shutil.copy2(src, dst)</p>
<pre><code>功能：拷贝文件和状态信息
</code></pre><h3 id="作业需求："><a href="#作业需求：" class="headerlink" title="作业需求："></a>作业需求：</h3><pre><code>模拟实现一个ATM + 购物商城程序

额度 15000或自定义
实现购物商城，买东西加入 购物车，调用信用卡接口结账
可以提现，手续费5%
每月22号出账单，每月10号为还款日，过期未还，按欠款总额 万分之5 每日计息
支持多账户登录
支持账户间转账
记录每月日常消费流水
提供还款接口
ATM记录操作日志
提供管理接口，包括添加账户、用户额度，冻结账户等。
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python自动化开发 day04]]></title>
      <url>http://blog.songqingbo.cn/2016/01/23/s12-20160123-day04/</url>
      <content type="html"><![CDATA[<p>Author:@南非波波</p>
<p>课程大纲：</p>
<p>day03</p>
<p><a href="http://www.cnblogs.com/wupeiqi/articles/5133343.html" target="_blank" rel="external">http://www.cnblogs.com/wupeiqi/articles/5133343.html</a></p>
<p>day04</p>
<p><a href="http://www.cnblogs.com/alex3714/articles/5143440.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5143440.html</a></p>
<h2 id="一、迭代器-amp-amp-生成器"><a href="#一、迭代器-amp-amp-生成器" class="headerlink" title="一、迭代器 &amp;&amp; 生成器"></a>一、迭代器 &amp;&amp; 生成器</h2><h3 id="1-迭代器"><a href="#1-迭代器" class="headerlink" title="1.迭代器"></a>1.迭代器</h3><pre><code>迭代器是访问集合元素的一种方式。迭代器只能往前不能往后。迭代器对象从集合的第一个集合开始访问，直到所有的元素被访问完。
优点：不需要事先准备整个迭代过程中的所有元素
</code></pre><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;

names = iter([&apos;swht&apos;,&apos;shen&apos;,&apos;jack&apos;])
print(names)
print(names.__next__())
print(names.__next__())
print(names.__next__())

返回结果：
    &lt;list_iterator object at 0x000000000114C7B8&gt;
    swht
    shen
    jack
</code></pre><h3 id="2-生成器"><a href="#2-生成器" class="headerlink" title="2.生成器"></a>2.生成器</h3><pre><code>定义：generator，一个函数调用时返回一个迭代器，那这个函数就叫做生成器。

作用：yield实现函数中断，并保存函数中断时的状态。中断后，程序可以继续执行下面的代码，而且可以随时可以回头再执行之前中断的函数。
    可以通过yield实现在单线程的情况下实现并发运算的效果
</code></pre><h4 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h4><pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;

def money(num):
    while num &gt; 0:
        print(&quot;取款100元!&quot;)
        num -= 100
        yield 100
        print(&quot;你当前还有%s元&quot; % num)

ATM = money(500)
print(type(ATM))
print(ATM.__next__())
print(ATM.__next__())
print(&quot;吃包子....&quot;)
print(ATM.__next__())
print(ATM.__next__())

返回结果：
    &lt;class &apos;generator&apos;&gt;
    取款100元!
    100
    你当前还有400元
    取款100元!
    100
    吃包子....
    你当前还有300元
    取款100元!
    100
    你当前还有200元
    取款100元!
    100
</code></pre><h3 id="实现异步：【生产者-消费者模型】"><a href="#实现异步：【生产者-消费者模型】" class="headerlink" title="实现异步：【生产者-消费者模型】"></a>实现异步：【生产者-消费者模型】</h3><p>yield参数可以实现返回参数和接收参数，使用send方法可以将值传递到生成器中去</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;

import time
def consumer(name):
    print(&quot;%s 开始准备吃包子!&quot; % name)
    while True:
        baozi = yield #yield可以返回一个值，也可以接收一个值
        print(&quot;第[%s]波包子来了,被[%s]吃了!&quot; % (baozi,name))

def producer(name):
    c1 = consumer(&apos;swht&apos;)
    c2 = consumer(&apos;shen&apos;)
    c1.__next__()
    c2.__next__()
    print(&quot;==%s开始准备做包子!==&quot; % name)
    for i in range(10):
        time.sleep(1)
        print(&quot;**%s做了两个包子!**&quot; % name)
        c1.send(i) #使用send方法将值传递给yield
        c2.send(i)

producer(&apos;alex&apos;)
</code></pre><p>返回结果：</p>
<pre><code>swht 开始准备吃包子!
shen 开始准备吃包子!
==alex开始准备做包子!==
**alex做了两个包子!**
第[0]波包子来了,被[swht]吃了!
第[0]波包子来了,被[shen]吃了!
**alex做了两个包子!**
第[1]波包子来了,被[swht]吃了!
第[1]波包子来了,被[shen]吃了!
**alex做了两个包子!**
第[2]波包子来了,被[swht]吃了!
第[2]波包子来了,被[shen]吃了!
**alex做了两个包子!**
第[3]波包子来了,被[swht]吃了!
第[3]波包子来了,被[shen]吃了!
**alex做了两个包子!**
第[4]波包子来了,被[swht]吃了!
第[4]波包子来了,被[shen]吃了!
**alex做了两个包子!**
第[5]波包子来了,被[swht]吃了!
第[5]波包子来了,被[shen]吃了!
**alex做了两个包子!**
第[6]波包子来了,被[swht]吃了!
第[6]波包子来了,被[shen]吃了!
**alex做了两个包子!**
第[7]波包子来了,被[swht]吃了!
第[7]波包子来了,被[shen]吃了!
**alex做了两个包子!**
第[8]波包子来了,被[swht]吃了!
第[8]波包子来了,被[shen]吃了!
**alex做了两个包子!**
第[9]波包子来了,被[swht]吃了!
第[9]波包子来了,被[shen]吃了!
</code></pre><h2 id="二、装饰器"><a href="#二、装饰器" class="headerlink" title="二、装饰器"></a>二、装饰器</h2><pre><code>装饰器又叫语法塘
</code></pre><h3 id="装饰器调用原理"><a href="#装饰器调用原理" class="headerlink" title="装饰器调用原理"></a>装饰器调用原理</h3><pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
def login(func):
    print(&quot;To passed!&quot;)
    return func

def home(name):
    print(&quot;Welcome [%s] to home page!&quot; % name)

def tv(name):
    print(&quot;Welcome [%s] to TV page!&quot; % name)

def moive(name):
    print(&quot;Welcome [%s] to Moive page!&quot; % name)

tv = login(tv)  #将tv函数的内存地址传递到login()函数中，然后将tv的内存地址返回并赋给变量tv
tv(&quot;swht&quot;) #变量调用相当于函数的调用
</code></pre><h3 id="装饰器实现"><a href="#装饰器实现" class="headerlink" title="装饰器实现"></a>装饰器实现</h3><pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
def login(func): #程序执行时返回inner函数的内存地址
    def inner(*arg,**kwargs):
        print(&quot;To passed!&quot;)
        return func(*arg,**kwargs)
    return inner

def home(name):
    print(&quot;Welcome [%s] to home page!&quot; % name)

@login
def tv(name):
    print(&quot;Welcome [%s] to TV page!&quot; % name)

def moive(name):
    print(&quot;Welcome [%s] to Moive page!&quot; % name)
tv(&quot;swht&quot;)
</code></pre><p>返回结果：</p>
<pre><code>To passed!
Welcome [swht] to TV page!
</code></pre><h3 id="多参数装饰器"><a href="#多参数装饰器" class="headerlink" title="多参数装饰器"></a>多参数装饰器</h3><pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;

def Before(request,kargs):
    print(&apos;before&apos;)

def After(request,kargs):
    print(&apos;after&apos;)


def Filter(before_func,after_func):
    def outer(main_func):
        def wrapper(request,kargs):

            before_result = before_func(request,kargs)
            if(before_result != None):
                return before_result

            main_result = main_func(request,kargs)
            if(main_result != None):
                return main_result

            after_result = after_func(request,kargs)
            if(after_result != None):
                return after_result

        return wrapper
    return outer

@Filter(Before, After)
def Index(request,kargs):
    print(&apos;index&apos;)

Index(&quot;swht&quot;,&quot;123&quot;)
</code></pre><h3 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h3><pre><code>&apos;&apos;&apos;
1.程序运行，读取顺序 @Filter --&gt; Index()
2.@Filter运行机制：
    1）将Before, After传递给Filter()，执行outer()；
    2）将Index传递给outer()函数，执行wrapper()，返回outer；
    3）将Index()中的两个参数request,kargs传递给wrapper()函数，执行：
        1）执行before_func()即Before()并判断返回值，打印before
        2）执行main_func()即Index()并判断返回值，打印index
        3）执行after_func()即After()并判断返回值，打印after
3.程序结束
&apos;&apos;&apos;
</code></pre><h2 id="三、递归"><a href="#三、递归" class="headerlink" title="三、递归"></a>三、递归</h2><h3 id="演示递归进出过程：【栈的实现：后进先出】"><a href="#演示递归进出过程：【栈的实现：后进先出】" class="headerlink" title="演示递归进出过程：【栈的实现：后进先出】"></a>演示递归进出过程：【栈的实现：后进先出】</h3><pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;

def calc(n):
    print(n)
    if n/2 &gt; 1:
        res = calc(n/2)
        print(&apos;res:&apos;,res)
    print(&apos;n:&apos;,n)
    return n
calc(10)
&apos;&apos;&apos;
递归进入多少层，最后函数结束退出的时候就是退出多少层
&apos;&apos;&apos;
</code></pre><p>返回结果：</p>
<pre><code>10
5.0
2.5
1.25
n: 1.25
res: 1.25
n: 2.5
res: 2.5
n: 5.0
res: 5.0
n: 10
</code></pre><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;

def sum(arg1,arg2,stop):
    if arg1 == 0:
        print(arg1,arg2)
    arg3 = arg1 + arg2
    print(arg3)
    if arg3 &lt; stop:
        sum(arg2,arg3,stop)

sum(0,1,500)
</code></pre><p>返回结果：</p>
<pre><code>0 1
1
2
3
5
8
13
21
34
55
89
144
233
377
610
</code></pre><h2 id="四、二分查找"><a href="#四、二分查找" class="headerlink" title="四、二分查找"></a>四、二分查找</h2><pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
def binary_search(data_source,find_num):
    mid = int(len(data_source)/2)  #列表折中
    if len(data_source) &gt;= 1: #如果列表的长度值大于1，则递归
        if data_source[mid] &gt; find_num: #如果中间值大于查找值，这说明查找值在中间值的左侧
            print(&quot;%s\tis\tthe\tleft\tof \t%s&quot; % (find_num,data_source[mid]))
            binary_search(data_source[:mid],find_num)
        elif data_source[mid] &lt; find_num: #如果中间值小于查找值，这说明查找值在中间值的右侧
            print(&quot;%s\tis\tthe\tright\tof \t%s&quot; % (find_num,data_source[mid]))
            binary_search(data_source[mid:],find_num)
        else:
            print(&quot;已经查找到\t%s&quot; % find_num)
    else: #否则返回值，查找不到
        print(&quot;查不到该数值!&quot;)

if __name__ == &quot;__main__&quot;:
    data = list(range(1,90000))
    binary_search(data,65535)
</code></pre><h2 id="五、二维数组"><a href="#五、二维数组" class="headerlink" title="五、二维数组"></a>五、二维数组</h2><p>二维数组的概念是在c、c++等语言中出现并定义，在python没有数组概念，对应的则是列表。所以我们这里称为二维数组则是对二维列表的称谓。</p>
<p>需求：</p>
<pre><code>转换二维数组
初始列表：
    [0, 1, 2, 3]
    [0, 1, 2, 3]
    [0, 1, 2, 3]
    [0, 1, 2, 3]
    =================
转换后列表：
    [0, 0, 0, 0]
    [1, 1, 1, 1]
    [2, 2, 2, 2]
    [3, 3, 3, 3]
</code></pre><p>代码实现：</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
data = [[col for col in range(4)] for row in range(4)]
# for i in a:
#     print(i)
for col in range(4):
    for row in range(col,4):
        data[col][row],data[row][col] = data[row][col],data[col][row]
for i in data:
    print(i)
print(a)
</code></pre><p>改进型：</p>
<pre><code>data = [[col for col in range(4)] for row in range(4)]
for col in range(len(data)):
    for row in data[col]:
        data[col][row],data[row][col] = data[row][col],data[col][row]
for i in data:
    print(i)
</code></pre><h2 id="六、正则表达式"><a href="#六、正则表达式" class="headerlink" title="六、正则表达式"></a>六、正则表达式</h2><pre><code>熟悉Linux环境的朋友肯定熟悉，用来操作字符或者文本文件时操作的快速匹配语言。正则表达式是用于处理字符串的强大工具，拥有自己独特的语法以及一个独立的处理引擎，效率上可能不如str自带的方法，但功能十分强大。
</code></pre><p>语法：</p>
<p><strong>一般字符</strong></p>
<pre><code>匹配自身
示例：
import re

str1 = &apos;23434sjsjdd523^&amp;(csd#@52&apos;
print(re.match(&apos;abc&apos;,str1))
返回值为：None #说明此时没有匹配到。
print(re.match(&apos;23&apos;,str1))
返回值为：&lt;_sre.SRE_Match object; span=(0, 2), match=&apos;23&apos;&gt; #匹配到自身并返回类型
</code></pre><p><strong>.</strong></p>
<pre><code>匹配任意除换行符&apos;\n&apos;外的字符，在DOALL模式中也能匹配换行符。
示例：
import re

str1 = &apos;23434sjsjdd523^&amp;(csd#@52&apos;
print(re.match(&apos;.&apos;,str1))
返回结果：&lt;_sre.SRE_Match object; span=(0, 1), match=&apos;2&apos;&gt; #匹配到任意字符&apos;2&apos;
</code></pre><p><strong>\</strong></p>
<pre><code>转义字符，使后一个字符改变原来的意思。如果字符串中有字符*需要匹配，可以使用\*或者字符集[*]
示例：
a\\c  --&gt;a\c
</code></pre><p><strong>[…]</strong></p>
<pre><code>字符集(字符类).对应的位置可以是字符集中任意字符。字符集中的字符可以逐个列出，也可以给出范围，如[abc]或[a-c]。第一个字符如果是^则表示取反，如[^abc]表示不是abc的其他字符。
所有的特殊字符在字符集中都失去其原有的特殊含义。在字符集中如果要使用]、-或^，都可以在前面加上反斜杠，或把]、-放在第一个字符，把^放在非第一个字符。
示例：a[bcd]e --&gt;abe ace ade
</code></pre><p><strong>预定义字符：</strong><br><img src="http://i.imgur.com/6Kgqmam.png" alt=""></p>
<p><strong>数量词：</strong><br><img src="http://i.imgur.com/DDsI4dU.png" alt=""></p>
<p><strong>边界匹配：</strong><br><img src="http://i.imgur.com/Ga3Fdf1.png" alt=""></p>
<p><strong>逻辑、分组</strong><br><img src="http://i.imgur.com/1qVGb25.png" alt=""></p>
<p>正则表达式模块<strong>re</strong></p>
<pre><code>Python通过re模块提供对正则表达式的支持。使用re的一般步骤是先将正则表达式的字符串形式编译为Pattern实例，然后使用Pattern实例处理文本并获得匹配结果（一个Match实例），最后使用Match实例获得信息，进行其他的操作。
</code></pre><p>示例：</p>
<pre><code>import re

test1 = re.compile(r&apos;hello&apos;)  #使用re.compile编译成Pattern实例
test12 = test1.match(&apos;hello world!&apos;) #使用Pattern匹配文本，获得匹配结果，无法匹配时返回None

if test12:
    print(test12.group()) #使用test12获得分组信息
#输出  hello

#the same as top
m = re.match(r&apos;hello&apos;, &apos;hello world!&apos;)
print(m.group())
</code></pre><h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><pre><code>match(string[,pos[endpos]])|re.match(patern,string[,flags]):
从string的pos下标处起尝试匹配pattern；如果pattern结束时仍可匹配，则返回一个Match对象；如果匹配过程中pattern无法匹配，或者匹配未结束就已到达endpos，则返回None。 
pos和endpos的默认值分别是0和len(sring);re.match()无法指定这两个参数，参数flags用于编译pattern时指定匹配模式。
（re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none.）
测试代码：
    m = re.match(&apos;hello&apos;, &apos;hello world!&apos;)
    print(m.group())
    返回值为：hello

    print(re.match(&apos;www&apos;,&apos;www.apicloud.com&apos;).span()) #在起始位置匹配
    print(re.match(&apos;com&apos;,&apos;www.apicloud.com&apos;)) #不在起始位置匹配

    返回结果：
    (0, 3)
    None

    import re

    line = &quot;Cats are smarter than dogs&quot;
    matchObj = re.match( r&apos;(.*) are (.*?) .*&apos;, line, re.M|re.I)
    #.* 匹配任意字符且匹配前一个字符0或无限次
    #.*? 匹配任意字符，且匹配前一个字符0或无限次，且匹配前一个字符0次或1次
    if matchObj:
       print(&quot;matchObj.group() : &quot;, matchObj.group())
       print(&quot;matchObj.group(1) : &quot;, matchObj.group(1))
       print(&quot;matchObj.group(2) : &quot;, matchObj.group(2))
    else:
       print(&quot;No match!!&quot;)

    返回结果：
    matchObj.group() :  Cats are smarter than dogs
    matchObj.group(1) :  Cats
    matchObj.group(2) :  smarter
</code></pre><h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><pre><code>功能：re.search 扫描整个字符串并返回第一个成功的匹配
语法：re.search(pattern, string, flags=0)
参数：pattern 匹配的正则表达式
     string  要匹配的字符串
     flags   标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。

测试代码：
    import re
    print(re.search(&apos;www&apos;, &apos;www.apicloud.com&apos;).span())  # 在起始位置匹配
    print(re.search(&apos;com&apos;, &apos;www.apicloud.com&apos;).span())         # 不在起始位置匹配
    返回结果：
    (0, 3)
    (13, 16)

    import re
    line = &quot;Cats are smarter than dogs&quot;
    searchObj = re.search( r&apos;(.*) are (.*?) .*&apos;, line, re.M|re.I)
    if searchObj:
       print(&quot;searchObj.group() : &quot;, searchObj.group())
       print(&quot;searchObj.group(1) : &quot;, searchObj.group(1))
       print(&quot;searchObj.group(2) : &quot;, searchObj.group(2))
    else:
       print(&quot;Nothing found!!&quot;)

    #返回结果：
    # searchObj.group() :  Cats are smarter than dogs
    # searchObj.group(1) :  Cats
    # searchObj.group(2) :  smarter
</code></pre><h3 id="对比match和search"><a href="#对比match和search" class="headerlink" title="对比match和search"></a>对比match和search</h3><pre><code>re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。
示例代码：
    import re
    line = &quot;Cats are smarter than dogs&quot;
    matchObj = re.match( r&apos;dogs&apos;, line, re.M|re.I)
    if matchObj:
       print(&quot;match --&gt; matchObj.group() : &quot;, matchObj.group())
    else:
       print(&quot;match --&gt; No match!!&quot;)

    searchObj = re.search( r&apos;dogs&apos;, line, re.M|re.I)
    if searchObj:
       print(&quot;search --&gt; searchObj.group() : &quot;, searchObj.group())
    else:
       print(&quot;search --&gt; No search!!&quot;)

    #返回结果：
    # match --&gt; No match!!
    # search --&gt; searchObj.group() :  dogs
</code></pre><p><strong>sub</strong></p>
<pre><code>功能：re.sub用户替换字符串中的匹配项
语法：re.sub(pattern, repl, string, max=0)
测试代码：
    import re
    phone = &quot;2004-959-559 # This is Phone Number&quot;
    # Delete Python-style comments
    num1 = re.sub(r&apos; .*$&apos;, &quot;&quot;, phone) #匹配&apos; &apos;空格到字符串默认的所有任意字符，删除
    print(&quot;Phone Num : &quot;, num1)  #Phone Num :  2004-959-559   最后一个字符后面没有空格
    num2 = re.sub(r&apos;#.*$&apos;, &quot;&quot;, phone) #匹配#到字符串默认的所有任意字符，删除
    print(&quot;Phone Num : &quot;, num2) #Phone Num :  2004-959-559  最后一个字符后面有一个空格

    # Remove anything other than digits
    num3 = re.sub(r&apos;\D&apos;, &quot;&quot;, phone) #匹配非数字字符，然后删除
    print(&quot;Phone Num : &quot;, num3) #Phone Num :  2004959559
</code></pre><h3 id="作业："><a href="#作业：" class="headerlink" title="作业："></a>作业：</h3><pre><code>计算器开发

1. 实现加减乘除及拓号优先级解析
2. 用户输入 1 - 2 * ( (60-30 +(-40/5) * (9-2*5/3 + 7 /3*99/4*2998 +10 * 568/14 )) - (-4*3)/ (16-3*2) )等类似公式后，必须自己解析里面的(),+,-,*,/符号和公式，运算后得出结果，结果必须与真实的计算器所得出的结果一致

博客地址：http://www.cnblogs.com/songqingbo/p/5168125.html
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python自动化开发 day03]]></title>
      <url>http://blog.songqingbo.cn/2016/01/16/s12-20160116-day03/</url>
      <content type="html"><![CDATA[<p>Author:@南非波波</p>
<p>课程大纲：</p>
<p>day2<br><a href="http://www.cnblogs.com/wupeiqi/articles/5115190.html" target="_blank" rel="external">http://www.cnblogs.com/wupeiqi/articles/5115190.html</a></p>
<p>day3<br><a href="http://www.cnblogs.com/wupeiqi/articles/5133343.html" target="_blank" rel="external">http://www.cnblogs.com/wupeiqi/articles/5133343.html</a></p>
<h2 id="一、set集合"><a href="#一、set集合" class="headerlink" title="一、set集合"></a>一、set集合</h2><p>博客链接：<a href="http://www.cnblogs.com/songqingbo/p/5128066.html" target="_blank" rel="external">http://www.cnblogs.com/songqingbo/p/5128066.html</a></p>
<pre><code>优点：访问速度快；
     自带一套解决元素重复的解决方案
</code></pre><p><strong>测试程序</strong></p>
<pre><code>old_dict = {
    &quot;#1&quot;:{ &apos;hostname&apos;:&apos;c1&apos;, &apos;cpu_count&apos;: 2, &apos;mem_capicity&apos;: 80 },
    &quot;#2&quot;:{ &apos;hostname&apos;:&apos;c1&apos;, &apos;cpu_count&apos;: 2, &apos;mem_capicity&apos;: 80 },
    &quot;#3&quot;:{ &apos;hostname&apos;:&apos;c1&apos;, &apos;cpu_count&apos;: 2, &apos;mem_capicity&apos;: 80 },
}
new_dict = {
    &quot;#1&quot;:{ &apos;hostname&apos;:&apos;c1&apos;, &apos;cpu_count&apos;: 2, &apos;mem_capicity&apos;: 800 },
    &quot;#3&quot;:{ &apos;hostname&apos;:&apos;c1&apos;, &apos;cpu_count&apos;: 2, &apos;mem_capicity&apos;: 80 },
    &quot;#4&quot;:{ &apos;hostname&apos;:&apos;c2&apos;, &apos;cpu_count&apos;: 2, &apos;mem_capicity&apos;: 80 },
}

获取三个列表：
    1. 需要更新的列表 update_list
    2. 需要删除的列表 del_list
    3. 需要增加的列表 add_list

代码实现：
    #!/usr/local/env python3
    &apos;&apos;&apos;
    Author:@南非波波
    Blog:http://www.cnblogs.com/songqingbo/
    E-mail:qingbo.song@gmail.com
    &apos;&apos;&apos;

    old_dict = {
        &quot;#1&quot;:{ &apos;hostname&apos;:&apos;c1&apos;, &apos;cpu_count&apos;: 2, &apos;mem_capicity&apos;: 80 },
        &quot;#2&quot;:{ &apos;hostname&apos;:&apos;c1&apos;, &apos;cpu_count&apos;: 2, &apos;mem_capicity&apos;: 80 },
        &quot;#3&quot;:{ &apos;hostname&apos;:&apos;c1&apos;, &apos;cpu_count&apos;: 2, &apos;mem_capicity&apos;: 80 },
    }
    new_dict = {
        &quot;#1&quot;:{ &apos;hostname&apos;:&apos;c1&apos;, &apos;cpu_count&apos;: 2, &apos;mem_capicity&apos;: 800 },
        &quot;#3&quot;:{ &apos;hostname&apos;:&apos;c1&apos;, &apos;cpu_count&apos;: 2, &apos;mem_capicity&apos;: 80 },
        &quot;#4&quot;:{ &apos;hostname&apos;:&apos;c2&apos;, &apos;cpu_count&apos;: 2, &apos;mem_capicity&apos;: 80 },
    }

    #设置set
    old_set = set(old_dict.keys())
    new_set = set(new_dict.keys())

    #更新的set
    update_set = new_set.intersection(old_dict)
    delate_set = old_set.difference(update_set)
    add_set = new_set.difference(update_set)

    update_list = []
    del_list = []
    add_list = []
    # print(update_set)
    # print(delate_set)
    # print(add_set)
    for i in update_set:
        update_list.append({i:new_dict[i]})
        print(&apos;需要更新的列表:%s&apos; % update_list)

    for i in delate_set:
        del_list.append({i:old_dict[i]})
        print(&quot;需要删除的列表:%s&quot; % del_list)

    for i in add_set:
        add_list.append({i:new_dict[i]})
        print(&quot;需要增加的列表:%s&quot; % add_list)
</code></pre><h2 id="二、collection系列"><a href="#二、collection系列" class="headerlink" title="二、collection系列"></a>二、collection系列</h2><p>博客链接：<a href="http://www.cnblogs.com/songqingbo/p/5137785.html" target="_blank" rel="external">http://www.cnblogs.com/songqingbo/p/5137785.html</a></p>
<pre><code>不常用功能，需要进行模块功能导入:
    import collection
</code></pre><h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><p>常用方法测试：</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
import collections

obj = collections.Counter(&apos;sjndsjkdsdmslaladsldsldms&apos;)

print(&quot;输出字符出现的次数字典:&quot;)
for k,v in obj.items():
    print(&quot;{%s:%s}&quot; % (k,v))

print(&quot;输出每一个字符:&quot;) #遍历获取原始字符元素
for k in obj.elements():
    print(k)

print(&quot;输出前四个出现次数最多的字符:&quot;)
for k in obj.most_common(4):
    print(k)


输出结果：
    输出字符出现的次数字典:
    {s:7}
    {l:4}
    {m:2}
    {d:6}
    {k:1}
    {n:1}
    {j:2}
    {a:2}
    输出每一个字符:
    s
    s
    s
    s
    s
    s
    s
    l
    l
    l
    l
    m
    m
    d
    d
    d
    d
    d
    d
    k
    n
    j
    j
    a
    a
    输出前四个出现次数最多的字符:
    (&apos;s&apos;, 7)
    (&apos;d&apos;, 6)
    (&apos;l&apos;, 4)
    (&apos;m&apos;, 2)
</code></pre><p><strong>__missing__</strong></p>
<pre><code>功能：对于不存在的元素，返回计数器为0
import collections
c = collections.Counter(&apos;adjsdkskdjksjaksklklakl&apos;)
c.__missing__(5)
返回结果：0
</code></pre><p><strong>most_common</strong></p>
<pre><code>功能：获取出现次数的前几个字母排名
import collections
c = collections.Counter(&apos;adjsdkskdjksjaksklklakl&apos;)
c.most_common(3)
[(&apos;k&apos;, 7), (&apos;s&apos;, 4), (&apos;a&apos;, 3)]
c.most_common(8)
[(&apos;k&apos;, 7), (&apos;s&apos;, 4), (&apos;a&apos;, 3), (&apos;j&apos;, 3), (&apos;l&apos;, 3), (&apos;d&apos;, 3)]
</code></pre><p><strong>elements</strong></p>
<pre><code>功能：计数器中的所有元素，并且按照ascii码进行了排序
    返回一个迭代器。元素被重复了多少次，在该迭代器中就包含多少个该元素。所有元素按照字母序排序，个数小于1的元素不被包含。
import collections
c = collections.Counter(&apos;adjsdkskdjksjaksklklakl&apos;)
sorted(c.elements())
返回结果：[&apos;a&apos;, &apos;a&apos;, &apos;a&apos;, &apos;d&apos;, &apos;d&apos;, &apos;d&apos;, &apos;j&apos;, &apos;j&apos;, &apos;j&apos;, &apos;k&apos;, &apos;k&apos;, &apos;k&apos;, &apos;k&apos;, &apos;k&apos;, &apos;k&apos;, &apos;k&apos;,&apos;l&apos;, &apos;l&apos;, &apos;l&apos;, &apos;s&apos;, &apos;s&apos;, &apos;s&apos;, &apos;s&apos;]
</code></pre><p><strong>计数值的访问与缺失的键</strong></p>
<pre><code>功能：默认将计数器中所有的字符认为一个键，然后统计键出现的次数，即键值。如果键不存在则返回0.
import collections
c = collections.Counter(&apos;adjsdkskdjksjaksklklakl&apos;)
&gt;&gt;&gt; c[&apos;a&apos;]
3
&gt;&gt;&gt; c[&apos;b&apos;]
0
&gt;&gt;&gt; c[&apos;l&apos;]
3
</code></pre><p><strong>update &amp;&amp; subtract</strong></p>
<pre><code>功能：都是更新计数器，update是增加，subtract是减少
import collections
&gt;&gt;&gt; c = collections.Counter(&apos;which&apos;)
&gt;&gt;&gt; c[&apos;h&apos;]  #这里的h出现2次
2
&gt;&gt;&gt; c.update(&apos;with&apos;)
&gt;&gt;&gt; c
Counter({&apos;h&apos;: 3, &apos;i&apos;: 2, &apos;w&apos;: 2, &apos;t&apos;: 1, &apos;c&apos;: 1})
&gt;&gt;&gt; c[&apos;h&apos;] #这里则完成了update操作，h出现了3次
3

&gt;&gt;&gt; c.subtract(&apos;with&apos;) 
&gt;&gt;&gt; c
Counter({&apos;h&apos;: 2, &apos;c&apos;: 1, &apos;i&apos;: 1, &apos;w&apos;: 1, &apos;t&apos;: 0})
&gt;&gt;&gt; c[&apos;h&apos;] #这里完成subtract操作之后，h出现的次数又恢复到2次
2
</code></pre><p><strong>del</strong></p>
<pre><code>功能：删除键
import collections
&gt;&gt;&gt; c = collections.Counter(&apos;which&apos;)
&gt;&gt;&gt; c[&apos;h&apos;]  #这里的h出现2次
2
&gt;&gt;&gt; del c[&apos;h&apos;]
&gt;&gt;&gt; c
Counter({&apos;c&apos;: 1, &apos;i&apos;: 1, &apos;w&apos;: 1, &apos;t&apos;: 0})
&gt;&gt;&gt; c[&apos;h&apos;]  #del操作删除了键&apos;h&apos;
0
</code></pre><p><strong>copy</strong></p>
<pre><code>功能：浅拷贝
import collections
&gt;&gt;&gt; c = collections.Counter(&apos;which&apos;)
&gt;&gt;&gt; d = c.copy()
&gt;&gt;&gt; d
Counter({&apos;h&apos;: 2, &apos;c&apos;: 1, &apos;i&apos;: 1, &apos;w&apos;: 1})
&gt;&gt;&gt; id(c)
7150792
&gt;&gt;&gt; id(d)
6511976
</code></pre><p><strong>算术和集合操作</strong></p>
<pre><code>功能：+、-、&amp;、|操作也可以用于Counter。其中&amp;和|操作分别返回两个Counter对象各元素的最小值和最大值。需要注意的是，得到的Counter对象将删除小于1的元素。
</code></pre><p><img src="http://i.imgur.com/dpBUpJJ.png" alt=""></p>
<p><strong>常用操作</strong></p>
<pre><code>说明：Counter继承dict的所有方法，常用的操作列在下面，仅供参考
</code></pre><p><img src="http://i.imgur.com/5EmjmX2.png" alt=""></p>
<h3 id="有序字典orderedDict"><a href="#有序字典orderedDict" class="headerlink" title="有序字典orderedDict"></a>有序字典orderedDict</h3><pre><code>有序字典继承字典的一切属性，只是在顺序上是有序的。
d = collections.OrderedDict({&apos;name&apos;:&apos;swht&apos;,&apos;age&apos;:18})
print(d)
返回结果：OrderedDict([(&apos;name&apos;, &apos;swht&apos;), (&apos;age&apos;, 18)])
print(type(d))
返回结果：&lt;class &apos;collections.OrderedDict&apos;&gt;
</code></pre><p><strong>move_to_end</strong></p>
<pre><code>功能：将指定的键值对从开头移动到末尾。
d = collections.OrderedDict({&apos;name&apos;:&apos;swht&apos;,&apos;age&apos;:18,&apos;address&apos;:&apos;shandong&apos;,})
d.move_to_end(&apos;name&apos;)
print(d)
返回结果：OrderedDict([(&apos;age&apos;, 18), (&apos;address&apos;, &apos;shandong&apos;), (&apos;name&apos;, &apos;swht&apos;)])
</code></pre><p><strong>pop</strong></p>
<pre><code>功能：移除字典键值，并返回删除键值的values
d = collections.OrderedDict({&apos;name&apos;:&apos;swht&apos;,&apos;age&apos;:18,&apos;address&apos;:&apos;shandong&apos;,})
d.pop(&apos;address&apos;)
print(d)
返回结果：OrderedDict([(&apos;age&apos;, 18), (&apos;name&apos;, &apos;swht&apos;)])
</code></pre><p><strong>clear</strong></p>
<pre><code>功能：清空有序字典的值
d = collections.OrderedDict({&apos;name&apos;:&apos;swht&apos;,&apos;age&apos;:18,&apos;address&apos;:&apos;shandong&apos;,})
d.clear()
print(d)
返回结果：OrderedDict()
</code></pre><p><strong>keys,values,items</strong></p>
<pre><code>功能：继承字典的属性，获取字典的所有键和所有值
d = collections.OrderedDict({&apos;name&apos;:&apos;swht&apos;,&apos;age&apos;:18,&apos;address&apos;:&apos;shandong&apos;,})
l1 = d.keys()
l2 = d.values()
l3 = d.items()
print(l1,l2，l3)
返回结果：odict_keys([&apos;address&apos;, &apos;age&apos;, &apos;name&apos;]) odict_values([&apos;shandong&apos;, 18, &apos;swht&apos;]) odict_items([(&apos;age&apos;, 18), (&apos;name&apos;, &apos;swht&apos;), (&apos;address&apos;, &apos;shandong&apos;)])
</code></pre><h3 id="默认字典defaultdict"><a href="#默认字典defaultdict" class="headerlink" title="默认字典defaultdict"></a>默认字典defaultdict</h3><pre><code>defaultdict是对字典的类型的补充，他默认给字典的值设置了一个类型。创建一个默认字典，value值类型为列表.
dic = collections.defaultdict(list)
</code></pre><h3 id="可命名元组nametuple"><a href="#可命名元组nametuple" class="headerlink" title="可命名元组nametuple"></a>可命名元组nametuple</h3><pre><code>没有现成的类，用户需要自行创建相应的类
</code></pre><p>测试代码</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
import collections
MytupleClass = collections.namedtuple(&quot;MytupleClass&quot;,[&apos;x&apos;,&apos;y&apos;,&apos;z&apos;])
obj = MytupleClass(11,22,33)
print(obj.x,obj.y,obj.z)
返回结果：11 22 33
总结：相当于在元组的基础上增加一个key，使其成为一个类字典的样子
</code></pre><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p><img src="http://i.imgur.com/DnEPoMR.png" alt=""></p>
<p>双向队列</p>
<pre><code>下面两种方法都可以创建双向列表，虽然在最初的引用的类不同，但最后创建的类型 都是collections.deque
#创建双向队列
import collections
d = collections.deque()
返回结果：&lt;class &apos;collections.deque&apos;&gt;

#but这样创建双向队列呢
import queue
p = queue.deque()
print(type(p))
#&lt;class &apos;collections.deque&apos;&gt;
</code></pre><p>单向队列</p>
<pre><code>#创建单向队列
import queue
q = queue.Queue()
print(type(q))
#&lt;class &apos;queue.Queue&apos;&gt;
</code></pre><h2 id="三、深浅拷贝"><a href="#三、深浅拷贝" class="headerlink" title="三、深浅拷贝"></a>三、深浅拷贝</h2><p>博客链接：<a href="http://www.cnblogs.com/songqingbo/p/5139015.html" target="_blank" rel="external">http://www.cnblogs.com/songqingbo/p/5139015.html</a></p>
<pre><code>#对于 数字 和 字符串 而言，赋值、浅拷贝和深拷贝无意义，因为其永远指向同一个内存地址
    import copy
    a1 = 22255
    a2 = 22255
    print(id(a1),id(a2)) #3428240 3428240

#对于字典、元祖、列表 而言，进行赋值、浅拷贝和深拷贝时，其内存地址的变化是不同的。

    import copy
    #字典
    n1 = {&quot;k1&quot;: &quot;wu&quot;, &quot;k2&quot;: 123, &quot;k3&quot;: [&quot;alex&quot;, 456]}
    ##赋值
    n2 = n1
    print(n1,n2) #{&apos;k1&apos;: &apos;wu&apos;, &apos;k2&apos;: 123, &apos;k3&apos;: [&apos;alex&apos;, 456]} {&apos;k1&apos;: &apos;wu&apos;, &apos;k2&apos;: 123, &apos;k3&apos;: [&apos;alex&apos;, 456]}
    print(id(n1),id(n2))  #6674440 6674440 #内存地址一样
    ##浅拷贝
    n3 = copy.copy(n1)
    print(n1,n3) #{&apos;k1&apos;: &apos;wu&apos;, &apos;k2&apos;: 123, &apos;k3&apos;: [&apos;alex&apos;, 456]} {&apos;k1&apos;: &apos;wu&apos;, &apos;k2&apos;: 123, &apos;k3&apos;: [&apos;alex&apos;, 456]}
    print(id(n1),id(n3)) #6936584 12067848  #浅拷贝第一级，内存地址相同
    print(id(n1[&apos;k3&apos;]),id(n3[&apos;k3&apos;])) #18741768 18741768
    ##深拷贝
    n4 = copy.deepcopy(n1)
    print(n1,n4) #{&apos;k3&apos;: [&apos;alex&apos;, 456], &apos;k2&apos;: 123, &apos;k1&apos;: &apos;wu&apos;} {&apos;k3&apos;: [&apos;alex&apos;, 456], &apos;k1&apos;: &apos;wu&apos;, &apos;k2&apos;: 123}
    print(id(n1),id(n4)) #6805512 11736904
    print(id(n1[&apos;k3&apos;]),id(n4[&apos;k3&apos;])) #7601032 7599496 #深拷贝第二级，内存地址也不相同

    #列表
    n1 = [1,2,3,4,5,[6,7],]
    ##赋值
    n2 = n1
    print(n1,n2) #[1, 2, 3, 4, 5, [6, 7]] [1, 2, 3, 4, 5, [6, 7]]
    print(id(n1),id(n2)) #18609928 18609928
    print(id(n1[5]),id(n2[5])) #18609544 18609544
    ##浅拷贝
    n3 = copy.copy(n1)
    print(n1,n3) #[1, 2, 3, 4, 5, [6, 7]] [1, 2, 3, 4, 5, [6, 7]]
    print(id(n1),id(n3)) #18609928 18232904
    print(id(n1[5]),id(n3[5])) #18609544 18609544
    ##深拷贝
    n4 = copy.deepcopy(n1)
    print(n1,n4) #[1, 2, 3, 4, 5, [6, 7]] [1, 2, 3, 4, 5, [6, 7]]
    print(id(n1),id(n4)) #18609928 18611848
    print(id(n1[5]),id(n4[5])) #18609544 18611912


    #元组
    一个小插曲：
        import copy
        n1 = (1,2,3,4,5,(6,7,),)
        #赋值
        n2 = n1
        print(&apos;n1:&apos;,n1,&apos;n2:&apos;,n2) #n1: (1, 2, 3, 4, 5, (6, 7)) n2: (1, 2, 3, 4, 5, (6, 7))
        print(id(n1),id(n2)) #10416584 10416584
        print(id(n1[5]),id(n2[5])) #18415304 18415304
        print(type(n1),type(2)) #&lt;class &apos;tuple&apos;&gt; &lt;class &apos;int&apos;&gt;
        #浅拷贝
        n3 = copy.copy(n1)
        print(&apos;n1:&apos;,n1,&apos;n3:&apos;,n3) #n1: (1, 2, 3, 4, 5, (6, 7)) n2: (1, 2, 3, 4, 5, (6, 7))
        print(id(n1),id(n3)) #10416584 10416584
        print(id(n1[5]),id(n3[5])) #18415304 18415304
        print(type(n1),type(3)) #&lt;class &apos;tuple&apos;&gt; &lt;class &apos;int&apos;&gt;
        #深拷贝
        n4 = copy.deepcopy(n1)
        print(&apos;n1:&apos;,n1,&apos;n4:&apos;,n4) #n1: (1, 2, 3, 4, 5, (6, 7)) n2: (1, 2, 3, 4, 5, (6, 7))
        print(id(n1),id(n4)) #10416584 10416584
        print(id(n1[5]),id(n4[5])) #18415304 18415304
        print(type(n1),type(5)) #&lt;class &apos;tuple&apos;&gt; &lt;class &apos;int&apos;&gt;
</code></pre><p><img src="http://i.imgur.com/SHmoN06.png" alt="">    </p>
<pre><code>再一个小插曲：
    import copy
    n1 = (1,2,3,4,5,[6,7,],)
    #赋值
    n2 = n1
    print(&apos;n1:&apos;,n1,&apos;n2:&apos;,n2) #(1, 2, 3, 4, 5, [6, 7]) n2: (1, 2, 3, 4, 5, [6, 7])
    print(id(n1),id(n2)) #11465160 11465160
    print(id(n1[5]),id(n2[5])) #18480456 18480456
    print(type(n1),type(2)) #&lt;class &apos;tuple&apos;&gt; &lt;class &apos;int&apos;&gt;
    #浅拷贝
    n3 = copy.copy(n1)
    print(&apos;n1:&apos;,n1,&apos;n3:&apos;,n3) #n1: (1, 2, 3, 4, 5, [6, 7]) n3: (1, 2, 3, 4, 5, [6, 7])
    print(id(n1),id(n3)) #11465160 11465160
    print(id(n1[5]),id(n3[5])) #18480456 18480456
    print(type(n1),type(3)) #&lt;class &apos;tuple&apos;&gt; &lt;class &apos;int&apos;&gt;
    #深拷贝
    n4 = copy.deepcopy(n1)
    print(&apos;n1:&apos;,n1,&apos;n4:&apos;,n4) #n1: (1, 2, 3, 4, 5, [6, 7]) n4: (1, 2, 3, 4, 5, [6, 7])
    print(id(n1),id(n4)) #11465160 18109736
    print(id(n1[5]),id(n4[5])) #18480456 18478920
    print(type(n1),type(5)) #&lt;class &apos;tuple&apos;&gt; &lt;class &apos;int&apos;&gt;
</code></pre><p><img src="http://i.imgur.com/DubYez7.png" alt=""><br>出现以上问题有可能跟下面的说法有关：<br><img src="http://i.imgur.com/XCsFOj6.png" alt=""></p>
<pre><code>案例代码

    import copy
    dic = {
        &quot;cpu&quot;:[80,],
        &quot;mem&quot;:[80,],
        &quot;disk&quot;:[80,],
    }

    print(&quot;old:&quot;,dic)
    new_dic1 = copy.copy(dic)
    new_dic1[&quot;cpu&quot;][0] = 50
    print(&quot;old:&quot;,dic)
    print(&quot;浅拷贝:&quot;,new_dic1)
    #返回结果：
    #old: {&apos;disk&apos;: [80], &apos;cpu&apos;: [80], &apos;mem&apos;: [80]}
    #浅拷贝: {&apos;disk&apos;: [80], &apos;cpu&apos;: [50], &apos;mem&apos;: [80]}

    new_dic2 = copy.deepcopy(dic)
    new_dic2[&quot;cpu&quot;][0] = 60
    print(&quot;old:&quot;,dic)
    print(&quot;深拷贝:&quot;,new_dic2)
    #返回结果
    # old: {&apos;mem&apos;: [80], &apos;cpu&apos;: [50], &apos;disk&apos;: [80]}
    # 深拷贝: {&apos;mem&apos;: [80], &apos;cpu&apos;: [60], &apos;disk&apos;: [80]}
</code></pre><h2 id="四、函数"><a href="#四、函数" class="headerlink" title="四、函数"></a>四、函数</h2><p>博客链接：<a href="http://www.cnblogs.com/songqingbo/p/5142957.html" target="_blank" rel="external">http://www.cnblogs.com/songqingbo/p/5142957.html</a></p>
<pre><code>定义：

    #!/usr/local/env python3
    &apos;&apos;&apos;
    Author:@南非波波
    Blog:http://www.cnblogs.com/songqingbo/
    E-mail:qingbo.song@gmail.com
    &apos;&apos;&apos;
    #定义函数，作用打印一个值
    def num_print():
        n = 456
        n += 1
        print(n)
使用：

    #函数调用
    num_print()
    #将f变量指向函数num_print，然后调用f()相当于调用num_print()
    f = num_print
    f()
</code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><pre><code>形参：函数中一个变量，在函数执行前无意义，在函数调用时必须指定实际参数。
实参：实际参数用户传递给所调用的函数的一个变量，其值赋值到函数中的形式参数，然后在函数中       作为变量参与函数执行
默认参数：必须放在最后
    def show(a1,a2,a3 = 5):
        print(a1,a2,a3)
    show(&quot;wu&quot;,&quot;ha&quot;)
    #返回结果：wu ha 5

指定参数：
    def show(a1,a2):
        print(a1,a2)
    show(a2=52,a1=8)
    #返回结果：8 52

动态参数：
    *arg --序列：自动转换成一个元组
        def show(*arg):
            print(arg,type(arg))
        show(23,45,67)
        #返回结果：(23, 45, 67) &lt;class &apos;tuple&apos;&gt;
        #or
        l = [23,45,67]
        show(*l)
        #返回结果：(23, 45, 67) &lt;class &apos;tuple&apos;&gt;

    **arg --字典：自动转换成一个字典
        #默认字典处理
        def show(**arg):
            print(arg,type(arg))
        show(name1=&apos;swht&apos;,name2=&apos;shen&apos;)
        #返回结果：{&apos;name1&apos;: &apos;swht&apos;, &apos;name2&apos;: &apos;shen&apos;} &lt;class &apos;dict&apos;&gt;
        #or
        d = {&quot;name1&quot;=&quot;swht&quot;,&quot;name2&quot;=&quot;shen&quot;}
        show(**d)
        #返回结果：{&apos;name1&apos;: &apos;swht&apos;, &apos;name2&apos;: &apos;shen&apos;} &lt;class &apos;dict&apos;&gt;

    *arg，**kwarges --序列和字典
        def show(*args,**kwargs):
            print(args,type(args),&apos;\n&apos;,kwargs,type(kwargs))
        show(23,45,67,82,name1=&apos;swht&apos;,name2=&apos;shen&apos;)
        #返回结果：(23, 45, 67, 82) &lt;class &apos;tuple&apos;&gt; 
                   {&apos;name2&apos;: &apos;shen&apos;, &apos;name1&apos;: &apos;swht&apos;} &lt;class &apos;dict&apos;&gt;        
        注意：使用*arg，**kwarges组合参数，必须是*arg在前，**kwarges在后，否则系统报错；另外实参在输入的时候也应该是按照上述顺序。
</code></pre><p><img src="http://i.imgur.com/NR71YzT.png" alt=""></p>
<p><strong>拓展：</strong></p>
<pre><code>def show(*args,**kwargs):
    print(args,type(args),&apos;\n&apos;,kwargs,type(kwargs))
l = [23,45,67,82]
d = {&apos;name1&apos;:&apos;swht&apos;,&apos;name2&apos;:&apos;shen&apos;}
show(l,d)
#返回结果：
([23, 45, 67, 82], {&apos;name1&apos;: &apos;swht&apos;, &apos;name2&apos;: &apos;shen&apos;}) &lt;class &apos;tuple&apos;&gt; 
{} &lt;class &apos;dict&apos;&gt;

def show(*args,**kwargs):
    print(args,type(args),&apos;\n&apos;,kwargs,type(kwargs))
l = [23,45,67,82]
d = {&apos;name1&apos;:&apos;swht&apos;,&apos;name2&apos;:&apos;shen&apos;}
show(*l,**d)
#返回结果：
(23, 45, 67, 82) &lt;class &apos;tuple&apos;&gt; 
{&apos;name2&apos;: &apos;shen&apos;, &apos;name1&apos;: &apos;swht&apos;} &lt;class &apos;dict&apos;&gt;

总结：
    函数可以传递元组、列表、字典等类型的值，由于带&apos;*&apos;、&apos;**&apos;的参数允许传入多个参数，所以在调用函数的时候默认将传入的参数识别到第一个*args。为了指定将参数传给某个args，这里需要对实参进行加&apos;*&apos;进行标识。

#list
show = &quot;Welcome to {0},there have too many {1}!&quot;
# reault = show.format(&quot;China&quot;,&quot;Foods&quot;)
l = [&quot;China&quot;,&quot;Foods&quot;]
reault = show.format(*l)
print(reault)
#返回结果：Welcome to China,there have too many Foods!

#dict
show = &quot;{name} is a {acter}!&quot;
# reault = show.format(name=&apos;swht&apos;,acter=&apos;teacher&apos;)
d = {&apos;name&apos;:&apos;swht&apos;,&apos;acter&apos;:&apos;teacher&apos;}
reault = show.format(**d)
print(reault)
#返回结果：swht is a teacher!
</code></pre><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p><img src="http://i.imgur.com/ICv89lK.jpg" alt=""></p>
<pre><code>    功能：简单函数的表示方式
    func = lambda a:a+1
    函数名  关键字 形参：函数体
    创建形式参数a，函数内容为a+1,并将结果return
测试代码：
    f = lambda x:x + 1
    ret = f(4)
    print(ret)
</code></pre><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p><img src="http://i.imgur.com/5so1j4e.png" alt=""></p>
<p><strong>abs()</strong></p>
<pre><code>功能：取绝对值
&gt;&gt;&gt; abs(5)
5
&gt;&gt;&gt; abs(-85)
85
</code></pre><p><strong>all(iterable)</strong></p>
<pre><code>功能：iterable所有的元素都为真,返回True，否则返回False
备注：为False的元素：0、&apos;&apos;、False或者空，其他的为True
参数：iterable为可迭代对象
all的功能可以使用下面的函数进行理解：
    def all(iterable):
    for element in iterable:
        if not element:
            return False
    return True
测试代码：
    all(&apos;test,hh&apos;)
    返回值为：True
    &gt;&gt;&gt; all([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;])  #列表list，元素都不为空或0
    True
    &gt;&gt;&gt; all([&apos;a&apos;, &apos;b&apos;, &apos;&apos;, &apos;d&apos;])  #列表list，存在一个为空的元素
    False
    &gt;&gt;&gt; all([0, 1，2, 3])  #列表list，存在一个为0的元素
    False              
    &gt;&gt;&gt; all((&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;))  #元组tuple，元素都不为空或0
    True
    &gt;&gt;&gt; all((&apos;a&apos;, &apos;b&apos;, &apos;&apos;, &apos;d&apos;))  #元组tuple，存在一个为空的元素
    False
    &gt;&gt;&gt; all((0, 1，2, 3))  #元组tuple，存在一个为0的元素
    False
    &gt;&gt;&gt; all([]) # 空列表
    True
    &gt;&gt;&gt; all(()) # 空元组
    True    
</code></pre><p><strong>any(iterable)</strong></p>
<pre><code>功能：iterable中元素只要有一个元素为真，则返回True,否则返回False(即iterable中所有的元素为假才会返回False)
参数：iterable为可迭代对象
any的功能可以使用下面的函数进行理解：
def any(iterable):
   for element in iterable:
       if  element:
           return False
   return True
测试代码：
    &gt;&gt;&gt; any([0,1,2,3]) #列表中仅有一个元素0为假，返回True
    True
    &gt;&gt;&gt; any([&apos; &apos;, &apos;  &apos;, &apos;&apos;, 0])
    True
    &gt;&gt;&gt; any([0]) #列表中元素只有一个元素0，返回False
    False
    &gt;&gt;&gt; any([0,&apos;&apos;])
    False
    &gt;&gt;&gt; any([0,&apos;&apos;,4])
    True    
    &gt;&gt;&gt; any((&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;))  #元组tuple，元素都不为空或0
    True
    &gt;&gt;&gt; any((&apos;a&apos;, &apos;b&apos;, &apos;&apos;, &apos;d&apos;))  #元组tuple，存在一个为空的元素
    True
    &gt;&gt;&gt; any((0, &apos;&apos;, False))  #元组tuple，元素全为0,&apos;&apos;,false
    False
    &gt;&gt;&gt; any([]) # 空列表
    False
    &gt;&gt;&gt; any(()) # 空元组
    False
</code></pre><p><strong>map(iterable)</strong></p>
<pre><code>功能：对可迭代函数&apos;iterable&apos;中的每一个元素应用‘function’方法，将结果作为list返回
参考链接：http://segmentfault.com/a/1190000000322433
测试代码：
    def add_100(num):
        return num + 100
    li1 = [25,26,27]
    ret = list(map(add_100,li1))
    print(ret)
    返回结果：[125, 126, 127]
</code></pre><p><img src="http://i.imgur.com/DVA1NXt.jpg" alt=""><br><img src="http://i.imgur.com/YqzknXX.jpg" alt=""></p>
<pre><code>python2.7                                python3.5
两个版本的对比，真是让人感到诧异，python3上执行map明明已经获取了值，但非得加个list进行展示，超乎寻常。

def abc(a,b,c):
    return a*1000 + b*100 + c*10

list1 = [11,22,33]
list2 = [44,55,66]
list3 = [77,88,99]
ret = list(map(abc,list1,list2,list3))
print(ret) #返回结果 [16170, 28380, 40590]
</code></pre><p><strong>ascii(object)</strong></p>
<pre><code>功能：该函数与python2中的repr()函数一样，返回一个可打印的对象字符串。当遇到非ascii码时，就会输出\x，\u或\U等字符来表示。例如：ascii(4) = int.__repr__(4) = repr(4)等号两边的方式是对等的。
测试代码：
    &gt;&gt;&gt; ascii(54)
    &apos;54&apos;
    &gt;&gt;&gt; ascii(&apos;o&apos;)
    &quot;&apos;o&apos;&quot;
    &gt;&gt;&gt; type(ascii(54))
    &lt;class &apos;str&apos;&gt;    
    &gt;&gt;&gt; print(ascii(10), ascii(9000000), ascii(&apos;b\31&apos;), ascii(&apos;0x\1000&apos;))
        10 9000000 &apos;b\x19&apos; &apos;0x@0&apos;
</code></pre><p><strong>bin()</strong></p>
<pre><code>功能：将整数转换为二进制字符串
&gt;&gt;&gt; bin(56)
&apos;0b111000&apos;
&gt;&gt;&gt; bin(100)
&apos;0b1100100&apos;
注意：如果bin()函数的实际参数不是一个整数,则该该实参(由类创建的对象)返回值必须是整数型
如：
&gt;&gt;&gt; class myType:
...     def __index__(self):
...             return 56
...
&gt;&gt;&gt; myvar = myType()
&gt;&gt;&gt; bin(myvar)
&apos;0b111000&apos;
</code></pre><p><strong>bool()</strong></p>
<pre><code>功能：获取对象的bool值
bool(0) #False
bool(5) #True
bool(&apos;&apos;) #False
#为假的元素：0 none 空列表 空字典 空元组 空字符串
</code></pre><p><strong>bytearray()</strong></p>
<pre><code>功能：转成字符字典。Bytearray类型是一个可变的序列，并且序列中的元素的取值范围为 [0 ,255]。
&gt;&gt;&gt; a = bytearray([5,8])
&gt;&gt;&gt; a[0]
5
&gt;&gt;&gt; a[1]
8
&gt;&gt;&gt; a
bytearray(b&apos;\x05\x08&apos;)
</code></pre><p><strong>bytes()</strong></p>
<pre><code>    功能：返回一个新的数组对象，这个数组不能对数组元素进行修改，每个元素的取值范围为[0 ,255]
    测试代码：
    bytes(iterable_of_ints) 
        &gt;&gt;&gt; b = bytes((5,8,6,8))
        &gt;&gt;&gt; print(b)
        b&apos;\x05\x08\x06\x08&apos;
    bytes(string, encoding[, errors])     
        &gt;&gt;&gt; bytes(&apos;sdjsd&apos;,encoding=&apos;utf-8&apos;)
        b&apos;sdjsd&apos;
    bytes(bytes_or_buffer)  ？
    bytes(int) 
        &gt;&gt;&gt; bytes(5)
        b&apos;\x00\x00\x00\x00\x00&apos;
    bytes()  
        &gt;&gt;&gt; bytes()
        b&apos;&apos;

总结：（参考：http://blog.csdn.net/caimouse/article/details/40860827）
    bytes函数与bytearray函数主要区别是bytes函数产生的对象的元素不能修改，而bytearray函数产生的对象的元素可以修改。因此，除了可修改的对象函数跟bytearray函数不一样之外，其它使用方法全部是相同的。最后它的参数定义方式也与bytearray函数是一样的。
</code></pre><p><strong>callable()</strong></p>
<pre><code>功能：判断函数或者对象是否可执行
&gt;&gt;&gt; callable(5)
False
&gt;&gt;&gt; callable(0)
False
&gt;&gt;&gt; callable(&apos;&apos;)
False
&gt;&gt;&gt; callable(int())
False
&gt;&gt;&gt; callable(lambda x:x+1)
True
</code></pre><p><strong>chr()</strong></p>
<pre><code>功能：参数为一个整型数字，返回值对应ASCII码的字符
&gt;&gt;&gt; chr(5)
&apos;\x05&apos;
&gt;&gt;&gt; chr(115)
&apos;s&apos;
&gt;&gt;&gt; chr(56)
&apos;8&apos;
</code></pre><p><strong>ord()</strong> </p>
<pre><code>功能：返回一个字符的ASCII码值
&gt;&gt;&gt; ord(&apos;s&apos;)
115
&gt;&gt;&gt; ord(&apos;5&apos;)
53
</code></pre><p><strong>classmethod()</strong></p>
<pre><code>功能：classmethod是用来指定一个类的方法为类方法，没有此参数指定的类的方法为实例方法
    &gt;&gt;&gt; class C: #定义一个类
    ...     @classmethod  #声明为类方法，不经过实例化就可以直接调用
    ...     def f(self): #定义一个函数（类的方法）
    ...             print &quot;This is a class method&quot;
    ...
    &gt;&gt;&gt; C.f()  #通过类调用函数
    This is a class method
    &gt;&gt;&gt; c = C()
    &gt;&gt;&gt; c.f()
    This is a class method
    &gt;&gt;&gt; class D:
    ...     def f(self):
    ...             print &quot; This is not a class method &quot;
    ...
    &gt;&gt;&gt; D.f()  #没有经过@classmethod 声明的类方法，必须经过实例化才能被调用
    Traceback (most recent call last):
      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
    TypeError: unbound method f() must be called with D instance as first argument (got nothing instead)
    &gt;&gt;&gt; d = D()
    &gt;&gt;&gt; d.f()
    This is not a class method
</code></pre><p><strong>staticmethod()</strong></p>
<pre><code>    功能：类的静态方法，只能在类内部使用。经过静态类方法声明的类，在调用的时候不需要进行实例化

总结：对比classmethod()和staticmethod()

    静态方法：@staticmethod()
        class Foo(object):
            str = &quot;I&apos;m a static method.&quot;
            def bar():
                print(Foo.str)
            bar = staticmethod(bar)

        Foo.bar()
    返回结果：I&apos;m a static method. 

    类方法：@classmethod()
        class Foo(object):
            str = &quot;I&apos;m a static method.&quot;
            def bar(cls):
                print(cls.str)
            bar = classmethod(bar)
        Foo.bar()
    返回结果：I&apos;m a static method. 
较简单的操作代码：

    静态方法：@staticmethod()
        class Foo:
            str = &quot;I&apos;m a static method.&quot;
            @staticmethod
            def bar():
                print(Foo.str)
        Foo.bar() 
    返回结果：I&apos;m a static method. 

    类方法：@classmethod()
        class Foo:
            str = &quot;I&apos;m a static method.&quot;
            @classmethod
            def bar(cls):
                print(cls.str )
        Foo.bar()
    返回结果：I&apos;m a static method.
</code></pre><p><strong>compile()、eval()、exec()</strong></p>
<pre><code>功能：compile语句是从type类型中将str里面的语句创建成代码对象。
    compile语句的目的是提供一次性的字节码编译，就不用在以后的每次调用中重新进行编译了
语法：compile( str, file, type )
    eveal_code = compile(&apos;1+2&apos;,&apos;&apos;,&apos;eval&apos;)
    &gt;&gt;&gt;eveal_code
    返回结果：&lt;code object &lt;module&gt; at 0x01555D40, file &quot;&quot;, line 1&gt;
    &gt;&gt;&gt;eval(eveal_code)
    返回结果：3

    single_code = compile( &apos;print(&quot;apicloud.com&quot;)&apos;, &apos;&apos;, &apos;single&apos; )
    &gt;&gt;&gt; single_code
    返回结果：&lt;code object &lt;module&gt; at 0x01555B10, file &quot;&quot;, line 1&gt;
    &gt;&gt;&gt; exec(single_code)
    返回结果：apicloud.com
</code></pre><p><strong>complex()</strong></p>
<pre><code>功能：创建一个值为real + imag * j的复数或者转化一个字符串或数为复数。如果第一个参数为字符串，则不需要指定第二个参数。
参数real: int, long, float或字符串；
参数imag: int, long, float
&gt;&gt;&gt;complex()
0j
#数字
&gt;&gt;&gt; complex(1,2)
(1+2j)
#当做字符串处理
&gt;&gt;&gt; complex(&apos;1&apos;)
(1+0j)
#注意：这个地方在“+”号两边不能有空格，也就是不能写成&quot;1 + 2j&quot;，应该是&quot;1+2j&quot;，否则会报错
&gt;&gt;&gt; complex(&apos;1+2j&apos;)
(1+2j)
</code></pre><p><strong>delattr()</strong></p>
<pre><code>参考链接：http://www.cnblogs.com/zhangjing0502/archive/2012/05/16/2503702.html
功能：删除object对象名为name的属性
语法：delattr(object,name) 
参数object：对象。
参数name：属性名称字符串。

&gt;&gt;&gt; class Person:
...     def __init__(self, name, age):
...             self.name = name
...             self.age = age
...
&gt;&gt;&gt; tom = Person(&quot;Tom&quot;, 35)
&gt;&gt;&gt; dir(tom)
[&apos;__doc__&apos;, &apos;__init__&apos;, &apos;__module__&apos;, &apos;age&apos;, &apos;name&apos;]
&gt;&gt;&gt; delattr(tom, &quot;age&quot;)
&gt;&gt;&gt; dir(tom)
[&apos;__doc__&apos;, &apos;__init__&apos;, &apos;__module__&apos;, &apos;name&apos;]
</code></pre><p><strong>getattr()</strong></p>
<pre><code>功能：用于返回一个对象属性，或者方法
class A:   
    def __init__(self):   
        self.name = &apos;zhangjing&apos;  
　　  #self.age=&apos;24&apos;
    def method(self):   
        print(&quot;method print&quot;)  

Instance = A()   
print(getattr(Instance , &apos;name&apos;, &apos;not find&apos;)) #如果Instance 对象中有属性name则打印self.name的值，否则打印&apos;not find&apos;
print(getattr(Instance , &apos;age&apos;, &apos;not find&apos;))  #如果Instance 对象中有属性age则打印self.age的值，否则打印&apos;not find&apos;
print(getattr(a, &apos;method&apos;, &apos;default&apos;))  
#如果有方法method，否则打印其地址，否则打印default   
print(getattr(a, &apos;method&apos;, &apos;default&apos;)()) 
#如果有方法method，运行函数并打印None否则打印default

li=[&quot;swht&quot;,&quot;shen&quot;]
getattr(li,&quot;pop&quot;)
返回结果：&lt;built-in method pop of list object at 0x01AFDA80&gt;
</code></pre><p><strong>setattr()</strong>    </p>
<pre><code>功能：参数是一个对象,一个字符串和一个任意值。字符串可能会列出一个现有的属性或一个新的属性。这个函数将值赋给属性的。该对象允许它提供。
语法：setattr(object, name, value)    
setattr(x,“foobar”,123)相当于x.foobar = 123
</code></pre><p><strong>hasattr()</strong></p>
<pre><code>功能：用于确定一个对象是否具有某个属性
语法：hasattr(object, name) -&gt; bool
    判断object中是否有name属性，返回一个布尔值
li=[&quot;swht&quot;,&quot;shen&quot;]
hasattr(li,&apos;append&apos;)
返回结果：True
</code></pre><p><strong>dict()</strong></p>
<pre><code>功能：字典定义函数，可以创建一个字典，也可以将其他类型（列表、元组、字符串）转换成字典类型
定义：
    dict1 = dict(one = 1, two = 2, a = 3)
    prin（dict1)
    {&apos;one&apos;: 1, &apos;a&apos;: 3, &apos;two&apos;: 2}
类型转换：
    list1 = [&apos;name&apos;,&apos;age&apos;,]
    list2 = [&apos;swht&apos;,18]
    dict(zip(list1,list2))
    返回结果：{&apos;name&apos;: &apos;swht&apos;, &apos;age&apos;: 18}

    new_list= [[&apos;key1&apos;,&apos;value1&apos;],[&apos;key2&apos;,&apos;value2&apos;],[&apos;key3&apos;,&apos;value3&apos;]]
    dict(new_list)
    返回结果：{&apos;key3&apos;: &apos;value3&apos;, &apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;}
</code></pre><p><strong>dir()</strong></p>
<pre><code>功能：查看函数或模块内的操作方法都有什么，输出的是方法列表。
如dir(int)可以直接获取int的所有方法，返回的类型是一个列表
</code></pre><p><strong>divmod()</strong></p>
<pre><code>功能：divmod(a,b)方法返回的是a//b（除法取整）以及a对b的余数
&gt;&gt;&gt; divmod(2,5)
(0, 2)
&gt;&gt;&gt; divmod(12,5)
(2, 2)
</code></pre><p><strong>enumerate()</strong></p>
<pre><code>功能：获取字典的索引值并指定开始值
li = [&apos;swht&apos;,&apos;shen&apos;,&apos;test&apos;]
for i,k in enumerate(li,3): #遍历列表，索引值从3开始
    print(i,k)
#返回结果
3 swht
4 shen
5 test
</code></pre><p><strong>filter()</strong></p>
<pre><code>参考链接：http://www.cnblogs.com/fangshenghui/p/3445469.html
功能：filter(function, sequence)对于队列中的item依次被function处理
def fun(item):
    if item != 4:
        return item
list1 = [5,4,8]
print(list(filter(fun,list1)))
返回结果：[4, 8]
总结：相当于一个过滤函数
</code></pre><p><strong>frozenset()</strong></p>
<pre><code>参考：http://blog.csdn.net/caimouse/article/details/42042051
功能：本函数是返回一个冻结的集合
l = [1, 2, 3, 4, 5, 6, 6, 7, 8, 8, 9]  
print(len(l), l)  
set = frozenset(l)  
print(len(set), set) 
返回结果：11 [1, 2, 3, 4, 5, 6, 6, 7, 8, 8, 9]
         9 frozenset({1, 2, 3, 4, 5, 6, 7, 8, 9})
总结：所谓冻结就是这个集合不能再添加或删除任何集合里的元素。因此与集合set的区别，就是set是可以添加或删除元素，而frozenset不行。frozenset的主要作用就是速度快，它是使用hash算法实现。参数iterable是表示可迭代的对象，比如列表、字典、元组等等
</code></pre><p><strong>locals()、globals()</strong></p>
<pre><code>功能：基于字典的访问局部和全局变量的方式
locals 是只读的，globals 不是
关于名字空间的相关说明请移步参考：http://blog.csdn.net/scelong/article/details/6977867
</code></pre><p><strong>hash()</strong></p>
<pre><code>功能：输出对象的hash值
&gt;&gt;&gt; hash(8)
8
&gt;&gt;&gt; hash(&apos;sd&apos;)
-584109415
&gt;&gt;&gt; hash(&apos;99&apos;)
-1356598271
&gt;&gt;&gt; hash(&apos;asds&apos;)
-1179125483
</code></pre><p><strong>help()</strong></p>
<pre><code>功能：查看函数或模块用途的详细说明
使用方法：help(object)
</code></pre><p><strong>类型转换</strong></p>
<pre><code>int(x [,base ])         将x转换为一个整数    
long(x [,base ])        将x转换为一个长整数    
float(x )               将x转换到一个浮点数    
complex(real [,imag ])  创建一个复数    
str(x )                 将对象 x 转换为字符串    
repr(x )                将对象 x 转换为表达式字符串    
eval(str )              用来计算在字符串中的有效Python表达式,并返回一个对象    
tuple(s )               将序列 s 转换为一个元组    
list(s )                将序列 s 转换为一个列表    
chr(x )                 将一个整数转换为一个字符    
unichr(x )              将一个整数转换为Unicode字符    
ord(x )                 将一个字符转换为它的整数值    
hex(x )                 将一个整数转换为一个十六进制字符串    
oct(x )                 将一个整数转换为一个八进制字符串
</code></pre><p><strong>id()</strong></p>
<pre><code>功能：获取对象的内存地址
id(object)
</code></pre><p><strong>input()</strong></p>
<pre><code>功能:获取用户的输入信息
input(&quot;请输入你的名字:&quot;)
&gt;&gt;&gt;请输入你的名字:swht
swht
</code></pre><p><strong>isinstance()</strong></p>
<pre><code>功能：判断对象类型
isinstance(5,int)
返回结果:True
</code></pre><p><strong>issubclass()</strong></p>
<pre><code>功能：本函数用来判断类参数class是否是类型参数classinfo的子类
class Line:  
    pass  
class RedLine(Line):  
    pass  

class Rect:  
    pass  

print(issubclass(RedLine, Line))  #返回True  Redline是Line的子类
print(issubclass(Rect, Line))  #返回False  
</code></pre><p><strong>iter()</strong></p>
<pre><code>功能：创建一个迭代器
for i in iter((1,2,4,5,6,7,)):
    print(i)
返回结果：1 2 4 5 6 7 #循环遍历元组
</code></pre><p><strong>len()</strong></p>
<pre><code>功能：获取字符串的长度
len(str)
</code></pre><p><strong>max()</strong></p>
<pre><code>功能：返回所有整数中最大的一个数
max(5,6,8,7) 
返回结果：8
</code></pre><p><strong>memoryview()</strong></p>
<pre><code>功能：本函数是返回对象obj的内存查看对象
&gt;&gt;&gt; v = memoryview(b&apos;abc123&apos;)
&gt;&gt;&gt; print(v[1])
98
&gt;&gt;&gt; print(v[0])
97
&gt;&gt;&gt; print(v[2])
import struct  
buf = struct.pack(&quot;i&quot;*12, *list(range(12)))  
x = memoryview(buf)  
y = x.cast(&apos;i&apos;, shape=[2,2,3])  
print(y.tolist()) 
返回结果：[[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]

总结：所谓内存查看对象，就是对象符合缓冲区协议的对象，为了给别的代码使用缓冲区里的数据，而不必拷贝，就可以直接使用。参考链接：http://blog.csdn.net/caimouse/article/details/43083627
</code></pre><p><strong>sorted()</strong></p>
<pre><code>功能：排序
sorted([5, 2, 3, 1, 4])
[1, 2, 3, 4, 5]
</code></pre><p><strong>sum()</strong></p>
<pre><code>功能：返回整数数字的和
sum([1,5,8]) #参数是一个list
返回结果：14
</code></pre><p><strong>super()</strong></p>
<pre><code>功能：用来解决多重继承问题
</code></pre><p><strong>type()</strong></p>
<pre><code>功能：获取对象的类型
type(object)
</code></pre><p><strong>vars()</strong></p>
<pre><code>功能：本函数是实现返回对象object的属性和属性值的字典对象
&gt;&gt;&gt; class Foo:
...     a = 1
...
&gt;&gt;&gt; print(vars(Foo))
{&apos;a&apos;: 1, &apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;Foo&apos; objects&gt;, &apos;__doc__&apos;: None, &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;Foo&apos; objects&gt;, &apos;__module__&apos;: &apos;__main__&apos;}

总结：如果默认不输入参数，就打印当前调用位置的属性和属性值，相当于locals()的功能。如果有参数输入，就只打印这个参数相应的属性和属性值。参考：http://blog.csdn.net/caimouse/article/details/46489079
</code></pre><p><strong>zip()</strong></p>
<pre><code>功能：zip函数接受任意多个（包括0个和1个）序列作为参数，返回一个tuple列表
&gt;&gt;&gt; x = [1,2,3,]
&gt;&gt;&gt; y = [4,5,6,]
&gt;&gt;&gt; z = [7,8,9,]
&gt;&gt;&gt; xyz = zip(x,y,z)
&gt;&gt;&gt; print(xyz)
&lt;zip object at 0x00FBD968&gt;
&gt;&gt;&gt; print(list(xyz))
[(1, 4, 7), (2, 5, 8), (3, 6, 9)]
</code></pre><p>random</p>
<pre><code>功能:产生随机数
import random
random.randint(1,99) #从1-99中产生随机数
</code></pre><p><strong>import</strong>()</p>
<pre><code>功能：查看模块所在的位置
 __import__(&apos;random&apos;) #参数为一个字符串
&lt;module &apos;random&apos; from &apos;D:\\Program Files\\Python\\Python35\\python35.zip\\random.pyc&apos;&gt;
</code></pre><h3 id="open-函数"><a href="#open-函数" class="headerlink" title="open()函数"></a>open()函数</h3><p>博客参考：<a href="http://www.cnblogs.com/songqingbo/p/5102618.html" target="_blank" rel="external">http://www.cnblogs.com/songqingbo/p/5102618.html</a></p>
<p><strong>read()</strong></p>
<pre><code>功能：读取文件中的所有内容，返回的类型是字节
</code></pre><p><strong>readline()</strong></p>
<pre><code>功能：读取文件中的一行数据。返回的类型是字节
</code></pre><p><strong>readlines()</strong></p>
<pre><code>功能：读取文件中的所有内容，返回的类型是list
</code></pre><p><strong>tell()</strong> </p>
<pre><code>功能：查看当前指针位置，返回值类型为整数
</code></pre><p><strong>seek()</strong></p>
<pre><code>功能：指定当前指针位置


files = open(&apos;test.txt&apos;,&apos;r&apos;,encoding=&apos;utf-8&apos;)
files.seek(5)
print(files.read()) #读取指为直接切割针5后面的所有字符
files.truncate() #获取指针5之前的所有字符然后写到原来的文件（或者可以理解）
files.close()
</code></pre><p><strong>扩展</strong></p>
<pre><code>读二进制文件：

    input = open(&apos;data&apos;,&apos;rb&apos;)

读取所有内容：

    f = open(&apos;test.txt&apos;,&apos;r&apos;)
    try:
        all_txt_view = f.read()
    finally:
        f.close()

读取固定字节：

    f = open(&apos;test.txt&apos;,&apos;rb&apos;)
    try:
        while True:
            chunk = f.read(100)
            if not chunk:
                break
            pass
    finally:
        f.close()

读每行：

    list_of_all_the_lines = f.readlines()

如果文件是文本文件，还可以直接遍历文件对象获取每行：

    for line in f:
        print(line)

写文件写文本文件

    output = open(&apos;data&apos;,&apos;w&apos;)

写入多行：

    f.writeline(list_of_text_string)
</code></pre><h3 id="作业："><a href="#作业：" class="headerlink" title="作业："></a>作业：</h3><pre><code>作业连接：http://www.cnblogs.com/wupeiqi/articles/4950799.html
1. 用户输入一个字符串，将其转换成字典 使用json
2. 增加一条记录
3. （可选）删除一条
4. （可选）线上文件修改


global       
        log 127.0.0.1 local2
        daemon
        maxconn 256
        log 127.0.0.1 local2 info
defaults
        log global
        mode http
        timeout connect 5000ms
        timeout client 50000ms
        timeout server 50000ms
        option  dontlognull

listen stats :8888
        stats enable
        stats uri       /admin
        stats auth      admin:1234

frontend oldboy.org
        bind 0.0.0.0:80
        option httplog
        option httpclose
        option  forwardfor
        log global
        acl www hdr_reg(host) -i www.oldboy.org
        use_backend www.oldboy.org if www

backend test.oldboy.org
        server 100.1.7.9 100.1.7.9 weight 20 maxconn 3000
        #server 100.1.7.9 100.1.7.999 weight 20 maxconn 3000


backend buy.oldboy.org
        server 100.1.7.90 100.1.7.90 weight 20 maxconn 3000

字典：        
{&quot;backend&quot;: &quot;test.oldboy.org&quot;,
 &quot;record&quot;:{
        &quot;server&quot;: &quot;100.1.7.999&quot;,
        &quot;weight&quot;: 20,
        &quot;maxconn&quot;: 30
  }
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python自动化开发 day02]]></title>
      <url>http://blog.songqingbo.cn/2016/01/09/s12-20160109-day02/</url>
      <content type="html"><![CDATA[<p>Author:@南非波波</p>
<p>作者注：</p>
<pre><code>经过第一天的学习以及后续的代码练习,给自己一个约定的代码风格、格式：
1. 模块名：
    模块应该使用尽可能短的、全小写命名，可以在模块命名时使用下划线以增强可读性。
    例如：
        login_shop.py
2. 类名定义：
    由于类名要求首字母必须大写，所以这样定义：
    class MyFristClass:  # 类名有三个单词组成，分别首字母大写
        def __init__(self,a):
            pass
3. 函数名定义：
    普通函数：
        选择使用字母小写，单词直接使用下划线_分割：
            shop_mag(users):
                pass
4. 变量名定义：
    全局变量名：
        字母全大写： SHOPLIST
    普通变量名：
        字母小写，单词分割选择使用首字母大写： shopUsers
</code></pre><p>以上规范并不是必须，但是作为个人的编程习惯而言，是一种很好的养成约束。</p>
<p>课程大纲地址： <a href="http://www.cnblogs.com/wupeiqi/articles/5115190.html" target="_blank" rel="external">http://www.cnblogs.com/wupeiqi/articles/5115190.html</a></p>
<h3 id="python知识拾忆："><a href="#python知识拾忆：" class="headerlink" title="python知识拾忆："></a>python知识拾忆：</h3><p>Python2.x与Python3.x关于dict.keys()返回值的类型对比：</p>
<p><img src="http://i.imgur.com/tieH6Vh.png" alt=""></p>
<h2 id="一、python种类"><a href="#一、python种类" class="headerlink" title="一、python种类"></a>一、python种类</h2><p>关于Python的一些版本内部执行的一些原理。从原理上来看待执行快慢的类型，从而选择自己需要的去学习。目前而言，最火的就是cpython了，这也是官方版本的Python。后面出现的pypy渐渐崭露头角，用银角大王的话讲：这货日后指定会火…</p>
<pre><code>1. cpython  使用c解释器生产.pyc(字节码)，然后转换成机器码，最后到cpu
2. javapython java解释器--&gt;字节码--&gt;机器码--&gt;cpu
3. IronPython C#解释器--&gt;字节码 --&gt; 机器码--&gt; cpu
4. pypy  内部使用自己的解释器编译成字节码--&gt;机器码.最后在外部执行的时候直接是机器码，速度要快
</code></pre><p>银角大王推荐阅读书：<strong>《python源码剖析》</strong></p>
<h2 id="二、字节码"><a href="#二、字节码" class="headerlink" title="二、字节码"></a>二、字节码</h2><p>在Python内部字节码直接的转换过程如图：</p>
<p><img src="http://i.imgur.com/U6KPbcR.png" alt=""></p>
<pre><code>python中进行字节码之间的转换流程大概是这样的：字节码类型转换从utf-8转换成gbk类型，首先需要执行解码变成Unicode类型，然后再由Unicode类型编码成gbk类型。[图片来源：银角大王课堂笔记]
</code></pre><h2 id="三、字符串"><a href="#三、字符串" class="headerlink" title="三、字符串"></a>三、字符串</h2><p>博客链接：<a href="http://www.cnblogs.com/songqingbo/p/5126957.html" target="_blank" rel="external">http://www.cnblogs.com/songqingbo/p/5126957.html</a></p>
<p>字符串的常用操作包括但不限于以下操作：</p>
<pre><code>字符串的替换、删除、截取、复制、连接、比较、查找、分割等
</code></pre><p>这里将对字符串的内置操作方法进行总结归纳，重点是以示例的方式进行展示。</p>
<pre><code>使用type获取创建对象的类 type(name)
使用dir获取类的成员dir(name)
使用vars获取类的成员和各个成员的值
</code></pre><p><strong>capitalize</strong></p>
<pre><code>功能：字符串首字母大写
name = &apos;swhthaitun&apos;
name.capitalize()
返回结果：&apos;Swht&apos;
</code></pre><p><strong>casefold()首字母小写</strong></p>
<pre><code>name = &apos;HelloWord&apos;
reault = name.casefold()
print(reault)
返回结果：helloword
</code></pre><p><strong>casefold</strong></p>
<pre><code>功能：将字符串中所有的大写字母转换成小写字母
s1 = &quot;[&apos;bsondump&apos;, &apos;mongo&apos;, &apos;mongod&apos;, &apos;mongodump&apos;, &apos;mongoexport&apos;, &apos;mongofiles&apos;, &apos;mongoimport&apos;, &apos;mongooplog&apos;, &apos;mongoperf&apos;, &apos;mongoLLKJKKore&apos;, &apos;mongos&apos;, &apos;UUUngostat&apos;, &apos;monGGtop&apos;]&quot;
s1.casefold()
返回结果：&quot;[&apos;bsondump&apos;, &apos;mongo&apos;, &apos;mongod&apos;, &apos;mongodump&apos;, &apos;mongoexport&apos;, &apos;mongofiles&apos;, &apos;mongoimport&apos;, &apos;mongooplog&apos;, &apos;mongoperf&apos;, &apos;mongollkjkkore&apos;, &apos;mongos&apos;, &apos;uuungostat&apos;, &apos;monggtop&apos;]&quot;
</code></pre><p><strong>center</strong></p>
<pre><code>功能：字符串宽度填充，使用原有字符串+填充字符构成指定长度的新的字符串
name = &apos;swhthaitun&apos;
name.center(15)
返回结果：&apos;   swhthaitun  &apos; #默认以空格进行填充
name.center(16,&apos;*&apos;)
返回结果：&apos;***swhthaitun***&apos;

功能：字符串居中，以‘*’分割(20为新产生字符串的总的宽度)
name = &apos;HelloWord&apos;
reault = name.center(20,&apos;*&apos;)
print(reault)
返回结果：*****HelloWord******
</code></pre><p><strong>count</strong></p>
<pre><code>功能：统计某个字符在字符串中出现的次数，或在字符串指定区间内完成上述操作
name = &apos;swhthaitun&apos;
name.count(&apos;h&apos;)
返回结果：2
name.count(&apos;h&apos;,0,3)  #从索引值0-3范围的字符中统计&apos;h&apos;出现的次数
返回结果：1

功能：统计子序列出现的次数
name = &apos;HelloWord&apos;
reault = name.count(&apos;W&apos;) #如果换成&apos;w&apos;，返回结果为0，python对大小写敏感
print(reault)
返回结果：1

name = &apos;HelloWord&apos;
reault = name.count(&apos;l&apos;,0,3) #统计单个字符出现的次数,可以指定起始范围,另外在python中起始范围讲究顾头不顾尾的原则，即[0,3)
print(reault)
</code></pre><p><strong>encode</strong></p>
<pre><code>功能：对字符串进行编码操作
name = &apos;swhthaitun&apos;
name.encode()
返回结果：b&apos;swhthaitun&apos;

功能：转变字符串的编码
name = &apos;南非波波&apos;
reault = name.encode(&apos;gbk&apos;)
print(reault)
返回结果：b&apos;\xc4\xcf\xb7\xc7\xb2\xa8\xb2\xa8&apos;
</code></pre><p><strong>endswith</strong></p>
<pre><code>功能：判断字符串是否以某个字符串结尾的，返回值为bool型
name = &apos;swhthaitun&apos;
name.endswith(&apos;s&apos;)
返回结果：False
name.endswith(&apos;n&apos;)
返回结果：True
name.endswith(&apos;tun&apos;)
返回结果：True

name = &apos;Iamalatterboy&apos;
reault = name.endswith(&apos;y&apos;)
print(reault)
返回结果：True
</code></pre><p><strong>expandtabs</strong></p>
<pre><code>功能：将制表符&apos;\t&apos;转换成指定宽度的tab键分割，默认tabsize=8
li = &apos;sw\tht&apos;
li.expandtabs(4)
返回结果：&apos;sw  ht&apos;
li.expandtabs()
返回结果：&apos;sw      ht&apos;
</code></pre><p><strong>find</strong></p>
<pre><code>功能：在字符串中查找指定字符串，找不到时返回-1
name = &apos;swht&apos;
name.find(&apos;s&apos;)
返回结果：0
name.find(&apos;h&apos;)
返回结果：2
</code></pre><p><strong>format</strong></p>
<pre><code>功能：格式化输出字符串
li = &apos;I\&apos;m {},{}&apos; #两个&apos;{}&apos;是占位符
li.format(&apos;swht&apos;,&apos;欢迎来中国&apos;)
返回结果：&quot;I&apos;m swht,欢迎来中国&quot;
参考：http://blog.chinaunix.net/uid-23802873-id-4477364.html
</code></pre><p>__contains__ </p>
<pre><code>功能：包含 --&gt;&apos;eal&apos; in name
name = &apos;swhtkkskjj&apos;
reault = name.__contains__(&apos;swht&apos;)
print(reault)
返回结果：True
</code></pre><p><strong>index</strong></p>
<pre><code>功能：在字符串中查找指定的字符串,找不到时直接报错
name = &apos;swhthaitun&apos;
name.index(&apos;w&apos;)
返回结果：1    
</code></pre><p><strong>join()</strong></p>
<pre><code>功能：字符串连接
name = &apos;swhthaitun&apos;
&apos;*&apos;.join(name)
返回结果：&apos;s*w*h*t*h*a*i*t*u*n&apos;
</code></pre><p><strong>isalnum</strong></p>
<pre><code>功能：检查判断字符串是否包含字母数字字符（http://www.yiibai.com/python/string_isalnum.html）
name = &apos;swhthaitun&apos;
name.isalnum()
返回结果：True
</code></pre><p><strong>isalpha</strong></p>
<pre><code>功能：检测字符串是否只由字母组成（http://www.runoob.com/python/att-string-isalpha.html）
name = &apos;swhthaitun&apos;
name.isalpha()
返回结果：True
</code></pre><p><strong>isdecimal</strong></p>
<pre><code>功能：检查字符串是否只包含十进制字符。这种方法只存在于unicode对象。（参考：http://www.runoob.com/python/att-string-isdecimal.html）
name = &apos;swhthaitun&apos;
name.isdecimal()
返回结果：False
</code></pre><p><strong>isdigit</strong></p>
<pre><code>功能：检测字符串是否只由数字组成。(参考:http://www.runoob.com/python/att-string-isdigit.html)
name = &apos;swhthaitun&apos;
name.isdigit()
返回结果：False
</code></pre><p><strong>isidentifier</strong></p>
<pre><code>功能：检测字符串是否是字母开头
name = &apos;swhthaitun&apos;
name.isidentifier()
返回结果：True
name = &apos;1swhthaitun&apos;
name.isidentifier()
返回结果：False
</code></pre><p><strong>isnumeric</strong></p>
<pre><code>功能：检测字符串是否只由数字组成。这种方法是只针对unicode对象。
name = &apos;swhthaitun&apos;
name.isnumeric()
返回结果：False
Li = &apos;5523&apos;
Li.isnumeric()
返回结果：True
</code></pre><p><strong>isprintable</strong></p>
<pre><code>功能：判断字符串中所有字符是否都属于可见字符
a = &quot;\tPuppy&quot;
a.isprintable()
返回结果：False
name = &apos;swhthaitun&apos;
name.isprintable()
返回结果：True
</code></pre><p><strong>isspace</strong></p>
<pre><code>功能：检测字符串是否为空格
name = &apos;swhthaitun&apos;
name.isspace()
返回结果：False
Li = &apos; &apos;
Li.isspace()
返回结果：True
</code></pre><p><strong>istitle</strong></p>
<pre><code>功能：判断字符串是否适合当作标题（其实就是每个单词首字母大写）
a = &quot;a puppy&quot;
b = &quot;Puppy&quot;
a.istitle()
返回结果：False
b.istitle()
返回结果：True
</code></pre><p><strong>isupper</strong></p>
<pre><code>功能：判断字符串中所有字母字符是否都是大写字母
a = &quot;puppy&quot;
b = &quot;PUPPY&quot;
a.isupper()
返回结果：False
b.isupper()
返回结果：True
</code></pre><p><strong>ljust</strong></p>
<pre><code>功能：返回一个原字符串左对齐,并使用空格填充至指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符串。（参考：http://www.runoob.com/python/att-string-ljust.html）
语法：str.ljust(width[, fillchar])
     width -- 指定字符串长度。
     fillchar -- 填充字符，默认为空格。
name = &apos;swhthaitun&apos;
name.ljust(50,&apos;*&apos;)
返回结果：&apos;swhthaitun****************************************&apos;
</code></pre><p><strong>lower</strong></p>
<pre><code>功能：将所有的字母转换成小写字母
name = &apos;SWHT&apos;
name.lower()
返回结果：&apos;swht&apos;
</code></pre><p><strong>lstrip</strong></p>
<pre><code>功能：去除字符串左边开头的空格
name = &apos;  swht   &apos;
name.lstrip()
返回结果：&apos;swht   &apos;
</code></pre><p><strong>rstrip</strong></p>
<pre><code>功能：去除字符串右边结尾的空格
name = &apos;  swht   &apos;
name.rstrip()
返回结果：&apos;   swht&apos;
</code></pre><p><strong>strip</strong></p>
<pre><code>功能：去除字符串两边的空格
name = &apos;  swht   &apos;
name.rstrip()
返回结果：&apos;swht&apos;
</code></pre><p><strong>maketrans</strong></p>
<pre><code>功能：用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。
注：两个字符串的长度必须相同，为一一对应的关系。
语法：str.maketrans(intab, outtab)
参数：intab -- 字符串中要替代的字符组成的字符串。
      outtab -- 相应的映射字符的字符串。
intab = &quot;swhtr&quot;
outtab = &quot;12345&quot;
name = &quot;hjjksknsnjmk&quot;
name.maketrans(intab, outtab)
返回结果：{104: 51, 114: 53, 115: 49, 116: 52, 119: 50}
</code></pre><p><strong>partition</strong></p>
<pre><code>功能：根据指定的分隔符将字符串进行分割。
    如果字符串包含指定的分隔符，则返回一个3元的元组，第一个为分隔符左边的子串，第二个为分隔符本身，第三个为分隔符右边的子串。
name = &apos;swht&apos;
li = &apos;hhsslswhtolljm&apos;
li.partition(name)
返回结果：(&apos;hhssl&apos;, &apos;swht&apos;, &apos;olljm&apos;)
</code></pre><p><strong>replace</strong></p>
<pre><code>功能：把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次。
语法：str.replace(old, new[, max])
参数：old -- 将被替换的子字符串。
     new -- 新字符串，用于替换old子字符串。
     max -- 可选字符串, 替换不超过 max 次
str = &quot;this is string example....wow!!! this is really string&quot;
str.replace(&quot;is&quot;, &quot;was&quot;)
返回结果：&apos;thwas was string example....wow!!! thwas was really string&apos;
str.replace(&quot;is&quot;, &quot;was&quot;, 3)
返回结果：&apos;thwas was string example....wow!!! thwas is really string&apos;
</code></pre><p><strong>split</strong></p>
<pre><code>功能：字符串分割，默认是空格
name.split()
返回结果：[&apos;swht&apos;]
name.split(&apos;s&apos;) #以&apos;s&apos;字符进行分割
返回结果：[&apos;&apos;, &apos;wht&apos;]
</code></pre><p><strong>__add__</strong></p>
<pre><code>功能：在字符串后面增加指定的字符或字符串
name = &apos;swht&apos;
name.__add__(&apos;e&apos;)
返回结果：&apos;swhte&apos;
li = &apos;hjh&apos;
name.__add__(li)
返回结果：&apos;swhthjh&apos;
</code></pre><p><strong>__contains__</strong></p>
<pre><code>功能：判断指定字符串是否包含在字符串中,返回值为True和False
name = &apos;swht&apos;
name.__contains__(&apos;s&apos;)
返回结果：True
</code></pre><p><strong>__eq__</strong></p>
<pre><code>功能：判断字符串是否相等，返回值为True和False
name = &apos;swht&apos;
li = &apos;test&apos;
name.__eq__(li)
返回结果：False        
</code></pre><p><strong>splitlines</strong>    </p>
<pre><code>功能：按照行分隔，返回一个包含各行作为元素的列表，如果 num 指定则仅切片 num 个行.
语法：str.splitlines( num=string.count(&apos;\n&apos;))
参数：num -- 分割行的次数
Li = &quot;Line1-a b c d e f\nLine2- a b c\n\nLine4- a b c d&quot;
Li.splitlines(0)
返回结果：[&apos;Line1-a b c d e f&apos;, &apos;Line2- a b c&apos;, &apos;&apos;, &apos;Line4- a b c d&apos;]
Li.splitlines(1)
返回结果：[&apos;Line1-a b c d e f\n&apos;, &apos;Line2- a b c\n&apos;, &apos;\n&apos;, &apos;Line4- a b c d&apos;]
</code></pre><p><strong>startswith</strong></p>
<pre><code>功能：判断一个字符串是否以某个或几个字符开始，结果以True或者False返回。
name = &quot;swhtlllds&quot;
name.startswith(&apos;s&apos;)
返回结果：True
</code></pre><p><strong>endswith</strong></p>
<pre><code>功能：判断一个字符串是否以某个或几个字符结束，结果以True或者False返回。
name = &quot;swhtlllds&quot;
name.endswith(&apos;ds&apos;)
返回结果：True
</code></pre><p><strong>swapcase</strong></p>
<pre><code>功能：用于对字符串的大小写字母进行转换。
name = &apos;swht&apos;
name.swapcase()
返回结果：&apos;SWHT&apos;
name = &apos;Swht&apos;
name.swapcase()
返回结果：&apos;sWHT&apos;
</code></pre><p><strong>upper</strong></p>
<pre><code>功能：将字符串中的小写字母转为大写字母
name = &apos;swht&apos;
name.swapcase()
返回结果：&apos;SWHT&apos;
</code></pre><p><strong>title</strong></p>
<pre><code>功能：进行标题转换,即单词首字母大写
name = &apos;swht ni li&apos;
name.title()
返回结果： &apos;Swht Ni Li&apos;
</code></pre><p><strong>translate</strong></p>
<pre><code>功能：根据参数table给出的表(包含 256 个字符)转换字符串的字符, 要过滤掉的字符放到 del 参数中。
方法：str.translate(table[, deletechars]);
参数：table -- 翻译表，翻译表是通过maketrans方法转换而来。
     deletechars -- 字符串中要过滤的字符列表。
intab = &quot;aeiou&quot;
outtab = &quot;12345&quot;
trantab = maketrans(intab, outtab)

str = &quot;this is string example....wow!!!&quot;;
print str.translate(trantab);
返回结果：th3s 3s str3ng 2x1mpl2....w4w!!!
</code></pre><p><strong>zfill</strong></p>
<pre><code>功能：垫零左侧的字符串，以填补宽度
语法：str.zfill(width)
参数：width：最后的字符串宽度
str = &quot;this is string example....wow!!!&quot;        
print str.zfill(40)
print str.zfill(50)
返回结果：00000000this is string example....wow!!!
         000000000000000000this is string example....wow!!!
</code></pre><h2 id="四、列表"><a href="#四、列表" class="headerlink" title="四、列表"></a>四、列表</h2><p>博客链接：<a href="http://www.cnblogs.com/songqingbo/p/5126943.html" target="_blank" rel="external">http://www.cnblogs.com/songqingbo/p/5126943.html</a></p>
<p>列表的基本操作示例展示：</p>
<p><strong>append</strong></p>
<pre><code>功能：列表追加元素
name = [&apos;sd&apos;,&apos;dfdf&apos;,&apos;drer&apos;]
name.append(&apos;sdsd&apos;)
返回结果：name
        [&apos;sd&apos;, &apos;dfdf&apos;, &apos;drer&apos;, &apos;sdsd&apos;]
</code></pre><p><strong>clear</strong></p>
<pre><code>功能：情况列表元素
name = [&apos;sd&apos;,&apos;dfdf&apos;,&apos;drer&apos;]
name.clear()
返回结果：name
         []
</code></pre><p><strong>copy</strong></p>
<pre><code>功能：浅拷贝，即只拷贝第一层的元素
name = [&apos;sd&apos;,&apos;dfdf&apos;,&apos;drer&apos;]
li = [&apos;ssd&apos;]
li = name.copy()
返回结果：li
         [&apos;sd&apos;, &apos;dfdf&apos;, &apos;drer&apos;]

name = [&apos;sd&apos;,&apos;dfdf&apos;,&apos;drer&apos;,[&apos;sddss&apos;,&apos;sdsdsd&apos;]]
li = [&apos;ssd&apos;]
li = name.copy()
返回结果：li
[&apos;sd&apos;, &apos;dfdf&apos;, &apos;drer&apos;, [&apos;sddss&apos;, &apos;sdsdsd&apos;]]
</code></pre><p><strong>count</strong></p>
<pre><code>功能：统计列表指定元素个数
name = [&apos;sd&apos;,&apos;dfdf&apos;,&apos;drer&apos;,[&apos;sddss&apos;,&apos;sdsdsd&apos;]]
name.count(&apos;sd&apos;)
返回结果：1
li = [&apos;sd&apos;,&apos;sdsds&apos;,[&apos;sd&apos;,&apos;dffdg&apos;,],]
li.count(&apos;sd&apos;) #只统计第一层的元素个数
返回结果：1
</code></pre><p><strong>extend</strong></p>
<pre><code>功能：追加字符元素或列表元素
name = [&apos;sd&apos;,&apos;dfdf&apos;,&apos;drer&apos;,[&apos;sddss&apos;,&apos;sdsdsd&apos;]]
li = [&apos;sd&apos;,&apos;sdsds&apos;,[&apos;sd&apos;,&apos;dffdg&apos;,],]
name.extend(&apos;ss&apos;)
返回结果：name
[&apos;sd&apos;, &apos;dfdf&apos;, &apos;drer&apos;, [&apos;sddss&apos;, &apos;sdsdsd&apos;], &apos;s&apos;, &apos;s&apos;]
name.extend(&apos;d&apos;)
返回结果：name
[&apos;sd&apos;, &apos;dfdf&apos;, &apos;drer&apos;, [&apos;sddss&apos;, &apos;sdsdsd&apos;], &apos;s&apos;, &apos;s&apos;, &apos;d&apos;]
name.extend(li)
返回结果：name
[&apos;sd&apos;, &apos;dfdf&apos;, &apos;drer&apos;, [&apos;sddss&apos;, &apos;sdsdsd&apos;], &apos;s&apos;, &apos;s&apos;, &apos;d&apos;, &apos;sd&apos;, &apos;sdsds&apos;, [&apos;sd&apos;, &apos;dffdg&apos;]]
</code></pre><p><strong>index</strong></p>
<pre><code>功能：定位列表中某元素
name = [&apos;sd&apos;,&apos;dfdf&apos;,&apos;drer&apos;,[&apos;sddss&apos;,&apos;sdsdsd&apos;]]
name.index(&apos;sd&apos;)
返回结果：0
name.index(&apos;drer&apos;)
返回结果：2
返回结果：name.index(&apos;dr&apos;)  #当出现某元素不在列表中的时候会直接报错
        Traceback (most recent call last):
          File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
        ValueError: &apos;dr&apos; is not in list
</code></pre><p><strong>insert</strong></p>
<pre><code>功能：在指定索引位置的元素前面插入新的元素
name = [&apos;sd&apos;,&apos;dfdf&apos;,&apos;drer&apos;,[&apos;sddss&apos;,&apos;sdsdsd&apos;]]
name.insert(3,&apos;sd&apos;)
返回结果：name
[&apos;sd&apos;, &apos;dfdf&apos;, &apos;drer&apos;, &apos;sd&apos;, [&apos;sddss&apos;, &apos;sdsdsd&apos;]]
</code></pre><p><strong>pop</strong></p>
<pre><code>功能：删除指定索引值的元素,返回值为当前删除的元素的值。不指定索引值，默认删除最后一个元素
name = [&apos;sd&apos;,&apos;dfdf&apos;,&apos;drer&apos;,[&apos;sddss&apos;,&apos;sdsdsd&apos;]]
name.pop(3)
返回结果：&apos;sd&apos;
</code></pre><p><strong>remove</strong></p>
<pre><code>功能：删除列表中指定的元素
name = [&apos;sd&apos;,&apos;dfdf&apos;,&apos;drer&apos;,[&apos;sddss&apos;,&apos;sdsdsd&apos;]]
name.remove(&apos;sd&apos;)
name
返回结果：[&apos;dfdf&apos;, &apos;drer&apos;, [&apos;sddss&apos;, &apos;sdsdsd&apos;]]
</code></pre><p><strong>reverse</strong></p>
<pre><code>功能：用于反向列表中元素。
name = [&apos;sd&apos;,&apos;dfdf&apos;,&apos;drer&apos;,[&apos;sddss&apos;,&apos;sdsdsd&apos;]]
name.reverse()
name
返回结果：[[&apos;sddss&apos;, &apos;sdsdsd&apos;], &apos;drer&apos;, &apos;dfdf&apos;, &apos;sd&apos;]
</code></pre><p><strong>sort</strong></p>
<pre><code>功能：对单层列表进行元素的排序
name = [&apos;sd&apos;,&apos;dfdf&apos;,&apos;drer&apos;,]
name.sort()
name
返回结果：[&apos;dfdf&apos;, &apos;drer&apos;, &apos;sd&apos;]

name = [&apos;sd&apos;,&apos;dfdf&apos;,&apos;drer&apos;,[&apos;sddss&apos;,&apos;sdsdsd&apos;]]
name.sort() #报错的
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
</code></pre><h2 id="五、元组"><a href="#五、元组" class="headerlink" title="五、元组"></a>五、元组</h2><p>关于元组的常用操作，请参考：<a href="http://www.runoob.com/python/python-tuples.html" target="_blank" rel="external">http://www.runoob.com/python/python-tuples.html</a></p>
<p>博客链接：<a href="http://www.cnblogs.com/songqingbo/p/5126947.html" target="_blank" rel="external">http://www.cnblogs.com/songqingbo/p/5126947.html</a></p>
<p>元组的元素不可修改    ，元组的元素的元素可修改</p>
<p><strong>count(self,value)</strong></p>
<pre><code>功能：统计当前元组中某元素的个数
tup = (55,77,85,55,96,99,22,55,)
tup.count(55)
返回结果：3 
备注：元素‘55’在元组tup中出现了3次
</code></pre><p><strong>index(self, value, start=None, stop=None)</strong></p>
<pre><code>功能：获取元素在元组中的索引值,对于重复的元素,默认获取从左起第一个元素的索引值
tup = (55,77,85,55,96,99,22,55,)
tup.index(55)
返回结果：0
tup.index(85)
返回结果：2
tup.index(55,2,7)
返回结果：3
</code></pre><p><strong>__add__</strong></p>
<pre><code>功能：将另一个元组追加到当前元组后面.__add__()只接收元组类型的序列
tup1 = (12,33,566,78,)
tup2 = (55,66,77,)
tup1.__add__(tup2)
返回结果：(12,33,566,78,55,66,77,)
</code></pre><p><strong>__contains__</strong></p>
<pre><code>功能：包含，判断某元素是否包含在元组中
tup = (55,77,85,55,96,99,22,55,)
tup.__contains__(55)
返回结果：True  
备注：返回值类型是bool型，该方法判断在对成员元素是否存在元组中，程序根据返回不同的bool值进行相应的值返回或者操作
</code></pre><p><strong>__eq__</strong></p>
<pre><code>功能：判断两个元组是否相等，返回值类型为bool型
tup = (55,77,85,55,96,99,22,55,)
tup1 = (55,77,85,55,96,99,22,551,)
tup.__eq__(tup1)
返回结果：False
</code></pre><p><strong>__getattribute__</strong></p>
<pre><code>pass
</code></pre><p><strong>__getitem__</strong></p>
<pre><code>功能：获取指定索引值的元素值
tup = (55,77,85,55,96,99,22,55,)
tup.__getitem__(5)
返回结果：99
</code></pre><p><strong>__getnewargs__</strong></p>
<pre><code>功能：只是获取原来的元组？？无卵用
tup = (55,77,85,55,96,99,22,55,)
tup.__getnewargs__()
返回结果：((55, 77, 85, 55, 96, 99, 22, 55),)
</code></pre><p><strong>__ge__</strong></p>
<pre><code>功能：判断当前元组是否大于等于某个元组
tup = (55,77,85,55,96,99,22,55,)
tup1 = (55,77,85,55,96,99,22,551,)
tup.__ge__(tup1)
返回结果：False #bool类型
</code></pre><p><strong>__gt__</strong></p>
<pre><code>功能：判断当前元组是否大于某个元组
tup = (55,77,85,55,96,99,22,55,)
tup1 = (55,77,85,55,96,99,22,551,)
tup.__ge__(tup1)
返回结果：False #bool类型
</code></pre><p><strong>__hash__</strong></p>
<pre><code>功能：计算元组的hash值
tup = (55,77,85,55,96,99,22,55,)
tup1 = (55,77,85,55,96,99,22,551,)
tup.__hash__()
返回结果：-2123087613
tup1.__hash__()
返回结果：1338854611
</code></pre><p><strong>__init__</strong></p>
<pre><code>功能：初始化作用，无返回值
</code></pre><p><strong>__iter__</strong></p>
<pre><code>功能：获取元组的内存地址
tup = (55,77,85,55,96,99,22,55,)
tup1 = (55,77,85,55,96,99,22,551,)
tup.__iter__()
返回结果：&lt;tuple_iterator object at 0x01C21F70&gt;
tup1.__iter__()
返回结果：&lt;tuple_iterator object at 0x01C21F50&gt;
</code></pre><p><strong>__len__</strong></p>
<pre><code>功能：获取元组的长度
tup.__len__()  #该方法已经被放到python的内置函数中，可以使用len(tup)获取长度
返回结果：8
</code></pre><p><strong>__le__</strong></p>
<pre><code>功能：判断当前元组是否小于等于某个元组
tup = (55,77,85,55,96,99,22,55,)
tup1 = (55,77,85,55,96,99,22,551,)
tup.__le__(tup1)
返回结果：True #bool类型
</code></pre><p><strong>__lt__</strong></p>
<pre><code>功能：判断当前元组是否小于某个元组
tup = (55,77,85,55,96,99,22,55,)
tup1 = (55,77,85,55,96,99,22,551,)
tup.__lt__(tup1)
返回结果：True #bool类型
</code></pre><p><strong>__mul__</strong></p>
<pre><code>功能：把当前元组按照某个值的倍数进行元组的扩展，产生新的元组
tup = (55,77,85,55,96,99,22,55,)
tup.__mul__(2)
返回结果：(55, 77, 85, 55, 96, 99, 22, 55, 55, 77, 85, 55, 96, 99, 22, 55)
tup.__iter__()
返回结果：&lt;tuple_iterator object at 0x01C21F70&gt;
tup.__mul__(2).__iter__()
返回结果：&lt;tuple_iterator object at 0x01C2F050&gt;
</code></pre><p><strong>__new__</strong></p>
<pre><code>pass
</code></pre><p><strong>__ne__</strong></p>
<pre><code>功能：判断当前元组不等于某个元组
tup = (55,77,85,55,96,99,22,55,)
tup1 = (55,77,85,55,96,99,22,551,)
tup.__ne__(tup1)
返回结果：True #bool类型
</code></pre><p><strong>__repr__</strong></p>
<pre><code>功能：将元组转换成一个字符串
tup = (55,77,85,55,96,99,22,55,)
tup.__repr__()
返回结果：&apos;(55, 77, 85, 55, 96, 99, 22, 55)&apos;
 type(tup.__repr__())
返回结果：&lt;class &apos;str&apos;&gt;
</code></pre><p><strong>__rmul__</strong></p>
<pre><code>功能：？？怎么感觉跟__mul__一个德行？？
tup = (55,77,85,55,96,99,22,55,)
tup.__rmul__(2)
返回结果：(55, 77, 85, 55, 96, 99, 22, 55, 55, 77, 85, 55, 96, 99, 22, 55)
</code></pre><h2 id="六、字典"><a href="#六、字典" class="headerlink" title="六、字典"></a>六、字典</h2><p>博客链接：<a href="http://www.cnblogs.com/songqingbo/p/5127044.html" target="_blank" rel="external">http://www.cnblogs.com/songqingbo/p/5127044.html</a></p>
<p>字典的常用操作：</p>
<p><strong>clear</strong></p>
<pre><code>功能：清空字典
dict_li = {&apos;users&apos;:&apos;swht&apos;,&apos;age&apos;:&apos;18&apos;,}
dict_li.clear()
返回结果：dict_li
        {}
</code></pre><p><strong>copy</strong></p>
<pre><code>功能：浅拷贝
dict_li = {&apos;users&apos;:&apos;swht&apos;,&apos;age&apos;:&apos;18&apos;,}
dict_li.copy()
返回结果：{&apos;age&apos;: &apos;18&apos;, &apos;users&apos;: &apos;swht&apos;}
dict_li = {&apos;users&apos;:&apos;swht&apos;,&apos;age&apos;:&apos;18&apos;,&apos;address&apos;:{&apos;sd&apos;:&apos;dz&apos;}}
dict_li.copy()
返回结果：{&apos;age&apos;: &apos;18&apos;, &apos;users&apos;: &apos;swht&apos;, &apos;address&apos;: {&apos;sd&apos;: &apos;dz&apos;}}
</code></pre><p><strong>fromkeys()</strong></p>
<pre><code>功能：用于创建一个新字典，以序列seq中元素做字典的键，value为字典所有键对应的初始值。
语法：dict.fromkeys(seq[, value]))
参数：seq -- 字典键值列表。
     value -- 可选参数, 设置键序列（seq）的值。
li = [&apos;users&apos;,&apos;age&apos;]
dict_li = dict.fromkeys(li,&apos;swht&apos;)
返回结果：dict_li
        {&apos;age&apos;: &apos;swht&apos;, &apos;users&apos;: &apos;swht&apos;}
</code></pre><p><strong>get</strong></p>
<pre><code>功能：获取字典的value值
dict_li = {&apos;users&apos;:&apos;swht&apos;,&apos;age&apos;:&apos;18&apos;,}
dict_li.get(&apos;users&apos;)
返回结果：&apos;swht&apos;
</code></pre><p><strong>items</strong></p>
<pre><code>功能：返回可遍历的(键, 值) 元组数组
dict_li = {&apos;users&apos;:&apos;swht&apos;,&apos;age&apos;:&apos;18&apos;,}
dict_li.items()
返回结果：dict_items([(&apos;age&apos;, &apos;18&apos;), (&apos;users&apos;, &apos;swht&apos;)])
</code></pre><p><strong>keys</strong></p>
<pre><code>功能：获取字典可遍历的键
dict_li = {&apos;users&apos;:&apos;swht&apos;,&apos;age&apos;:&apos;18&apos;,}
dict_li.keys()
返回结果：dict_keys([&apos;age&apos;, &apos;users&apos;])
</code></pre><p><strong>pop</strong></p>
<pre><code>功能：删除字典中指定的键值
dict_li = {&apos;users&apos;:&apos;swht&apos;,&apos;age&apos;:&apos;18&apos;,}
dict_li.pop(&apos;age&apos;)
返回结果：&apos;18&apos;
</code></pre><p><strong>popitem</strong></p>
<pre><code>功能：随机返回并删除字典中的一对键和值
dict_li = {&apos;users&apos;:&apos;swht&apos;,&apos;age&apos;:&apos;18&apos;,}
dict_li.popitem()
返回结果：(&apos;age&apos;, &apos;18&apos;)
dict_li
{&apos;users&apos;: &apos;swht&apos;}
</code></pre><p><strong>setdefault</strong></p>
<pre><code>功能：查找键值，如果键不已经存在于字典中，将会添加键并将值设为默认值。
dict_li = {&apos;users&apos;:&apos;swht&apos;,&apos;age&apos;:&apos;18&apos;,}
dict_li.setdefault(&apos;ID&apos;,5)
返回结果：5
dict_li
返回结果：{&apos;age&apos;: &apos;18&apos;, &apos;users&apos;: &apos;swht&apos;, &apos;ID&apos;: 5}
</code></pre><p><strong>update</strong></p>
<pre><code>功能：把指定字典的键值更新到当前字典中
dict_li = {&apos;users&apos;:&apos;swht&apos;,&apos;age&apos;:&apos;18&apos;,}
dict_ai = {&apos;address&apos;:&apos;山东&apos;}
dict_li.update(dict_ai)
dict_li
返回结果：{&apos;age&apos;: &apos;18&apos;, &apos;users&apos;: &apos;swht&apos;, &apos;address&apos;: &apos;山东&apos;}
</code></pre><p><strong>values</strong></p>
<pre><code>功能：获取字典的所有值
dict_li = {&apos;age&apos;: &apos;18&apos;, &apos;users&apos;: &apos;swht&apos;, &apos;address&apos;: &apos;山东&apos;}
dict_li.values()
返回结果：dict_values([&apos;18&apos;, &apos;swht&apos;, &apos;山东&apos;])
</code></pre><h2 id="七、set集合"><a href="#七、set集合" class="headerlink" title="七、set集合"></a>七、set集合</h2><p>博客链接：<a href="http://www.cnblogs.com/songqingbo/p/5128066.html" target="_blank" rel="external">http://www.cnblogs.com/songqingbo/p/5128066.html</a></p>
<pre><code>set集合是一个无序且不重复的集合。
创建一个set集合：
    name = set(&apos;sdd&apos;)
    name
    返回结果：{&apos;d&apos;, &apos;s&apos;}
</code></pre><p><strong>add</strong></p>
<pre><code>功能：增加集合元素
name = {&apos;d&apos;, &apos;s&apos;}
name.add(&apos;d&apos;)
name
返回结果：{&apos;d&apos;, &apos;s&apos;}
name.add(&apos;sd&apos;)
name
返回结果：{&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
</code></pre><p><strong>clear</strong></p>
<pre><code>功能：清空集合元素
name = {&apos;d&apos;, &apos;s&apos;}
name.clear()
name
返回结果：{}
</code></pre><p><strong>copy</strong></p>
<pre><code>功能：浅拷贝
name = {&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
li = name.copy()
返回结果：li
        {&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
</code></pre><p><strong>difference</strong></p>
<pre><code>功能：取差集
name = {&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
li = set()
name.difference(li)
返回结果：name.difference()
{&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
</code></pre><p><strong>difference_update</strong></p>
<pre><code>功能：删除当前set中的所有包含在 new set 里的元素
li = (&apos;s&apos;, &apos;d&apos;)
name = {&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
name.difference_update(li)
name
返回结果：{&apos;sd&apos;}
</code></pre><p><strong>discard</strong></p>
<pre><code>功能：移除元素
name = {&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
name.discard(&apos;s&apos;)
返回结果：name 
        {&apos;sd&apos;, &apos;d&apos;}
</code></pre><p><strong>intersection</strong></p>
<pre><code>功能：取交集,建立新的set集合
li = (&apos;s&apos;, &apos;d&apos;)
name = {&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
name.intersection(li)
返回结果：{&apos;d&apos;, &apos;s&apos;}
</code></pre><p><strong>intersection_update</strong></p>
<pre><code>功能：取交集,更新原来的set集合
li = (&apos;s&apos;, &apos;d&apos;)
name = {&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
name.intersection_update(li)
返回结果：{&apos;d&apos;, &apos;s&apos;}
</code></pre><p><strong>isdisjoint</strong></p>
<pre><code>功能：判断没有交集，返回True,否则,返回False
li = {&apos;s&apos;, &apos;d&apos;}
name = {&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
name.isdisjoint(li)
</code></pre><p><strong>issubset</strong></p>
<pre><code>功能：判断是否是子集
li = {&apos;s&apos;, &apos;d&apos;}
name = {&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
name.issubset(li)  #判断name是不是li的子集
返回结果：False
li.issubset(name)  #判断li是不是name的子集
返回结果：True
</code></pre><p><strong>issuperset</strong></p>
<pre><code>功能：判断是否是父集
li = {&apos;s&apos;, &apos;d&apos;}
name = {&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
name.issuperset(li)  #判断name是不是li的父集
返回结果：True
li.issuperset(name)  #判断li是不是name的父集
返回结果：False
</code></pre><p><strong>pop</strong></p>
<pre><code>功能：移除集合元素
name = {&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
name.pop()
返回结果：&apos;sd&apos; #随机删除集合元素
se1 = {&apos;a&apos;,&apos;s&apos;,&apos;sb&apos;}
se1.pop()
返回结果：&apos;sb&apos;
</code></pre><p><strong>remove</strong></p>
<pre><code>功能：移除指定集合元素
name = {&apos;sd&apos;,&apos;d&apos;,&apos;s&apos;}
name.remove(&apos;s&apos;)
返回结果：name
{&apos;sd&apos;, &apos;d&apos;}
</code></pre><p><strong>symmetric_difference</strong></p>
<pre><code>功能：去两个集合的差集，建立新的set集合对象
name = {&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
li = {&apos;s&apos;, &apos;d&apos;}
name.symmetric_difference(li)
返回结果：{&apos;sd&apos;}
</code></pre><p><strong>symmetric_difference_update</strong></p>
<pre><code>功能：去两个集合的差集，更新原来的集合对象
name = {&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
li = {&apos;s&apos;, &apos;d&apos;}
name.symmetric_difference_update(li)
返回结果：{&apos;sd&apos;}
</code></pre><p><strong>union</strong></p>
<pre><code>功能：并集，创建新的对象
name = {&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
li = {&apos;s&apos;, &apos;d&apos;,&apos;h&apos;}
name.union(li)
返回结果：{&apos;h&apos;, &apos;s&apos;, &apos;d&apos;, &apos;sd&apos;}
</code></pre><p><strong>update</strong></p>
<pre><code>功能：更新已有集合
name = {&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
name.update(&apos;df&apos;)
name
返回结果：{&apos;sd&apos;, &apos;d&apos;, &apos;f&apos;, &apos;s&apos;}
</code></pre><h2 id="八、类与对象"><a href="#八、类与对象" class="headerlink" title="八、类与对象"></a>八、类与对象</h2><p><img src="http://i.imgur.com/O2wZsUd.png" alt=""></p>
<p>对象</p>
<pre><code>python中一切事物皆对象,对象是一开始就有的,只是我们无法访问它。访问对象需要以变量的形式去访问（即创建变量指向到对象的，变量即对对象的引用）
在python中，一个对象的特征也称为属性（attribute）。它所具有的行为也称为方法（method）
结论：对象=属性+方法
</code></pre><p>类</p>
<pre><code>在python中，把具有相同属性和方法的对象归为一个类（class）
比如人类，动物，植物等等，这些都是类的概念。 
类是对象的模板或蓝图，类是对象的抽象化，对象是类的实例化。类不代表具体的事物，而对象表示具体的事物。
类包含描述对象的方法。
</code></pre><h3 id="int"><a href="#int" class="headerlink" title="int"></a>int</h3><pre><code>取绝对值：
    age = -19
    age.__abs__() #int类函数调用
    abs(-19) #内置函数方式操作
取商和余数：
    age = 95
    age.__divmod__(10) #95/10 --&gt;(9,5)
相加：
    a = 5，b=6
    a.__add__(b) #调用int的类函数add，相当于a + b  --&gt;11
    a + b #内置函数方式操作
</code></pre><h3 id="作业："><a href="#作业：" class="headerlink" title="作业："></a>作业：</h3><pre><code>1. 博客整理
2. 购物商城实现
    1. 商品展示，价格
    2. 购物车添加商品（进行差异商品，同一种商品应该只存在一条数据）
    3. 付款（根据钱进行判断是否可以满足付款）
3. 预习
    http://www.cnblogs.com/wupeiqi/articles/5115190.html  后面的部分
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python自动化开发 day01]]></title>
      <url>http://blog.songqingbo.cn/2015/12/16/s12-20151226-day01/</url>
      <content type="html"><![CDATA[<p>Author:@南非波波</p>
<p>作者注：</p>
<p>　　python学习旅程正式开启，这一天将是一个新的开始。希望我们在python开发的道路上多多积累、多分享！</p>
<h2 id="一、python简介"><a href="#一、python简介" class="headerlink" title="一、python简介"></a>一、python简介</h2><pre><code>python应用 
    Disgus Voitze Yelip Mozilla Quora  Redit
    豆瓣、知乎、sohu、腾讯、网易、金山、雅虎、Facebook、 Instagram（图片分享）
python2与python3比较
    经过多年的发展，python3已经得到更多的第三方优秀函数库兼容，对比python2来说，python3表现出来的精简高效特性让开发者们跃跃欲试。
    另外，python2.7.11作为python2版本的最后一个版本，不再有新版本推出，这样官方更多的引导开发者快速的向python3版本上进行转移。
    在本次学习的过程中，我们会穿插在python2和python3两个版本之间进行学习，后续的测试代码在开头会明确标记python的使用版本。相关注释都会对python2和python3的差异进行描述。
</code></pre><h2 id="二、python安装"><a href="#二、python安装" class="headerlink" title="二、python安装"></a>二、python安装</h2><pre><code>1.windows端安装
    安装包下载地址：
        python2.7版本：
            https://www.python.org/ftp/python/2.7.11/python-2.7.11.amd64.msi
        python3.5版本：
            https://www.python.org/ftp/python/3.5.1/python-3.5.1-amd64.exe  #安装版
            https://www.python.org/ftp/python/3.5.1/python-3.5.1-embed-win32.zip #免安装版
    安装步骤：
        使用可执行程序进行安装，按照流程进行安装即可，注意在安装的时候选择“安装路径”和一些必要的插件，比如pip、easy_install等
        使用免安装的文件（可嵌入的）进行环境配置：
        ![](http://i.imgur.com/U827QAb.jpg)
2.linux端安装
    centos6等常用系统自带的python版本为2.6，有特殊需求的朋友可能需要升级到python2.7或者python3版本。下面链接以python2.7.8为例进行编译安装。
        http://swht1278.blog.51cto.com/7138082/1728427
    提供一下python版本的下载地址：
        python2.7.11版本：
            https://www.python.org/ftp/python/2.7.11/Python-2.7.11.tgz
        python3.5版本：
            https://www.python.org/ftp/python/3.5.1/Python-3.5.1.tgz
3.Ubuntu端安装
    最新版本的Ubuntu系统（15.04等）已经自带了python2.7.9和python3.4.5两个版本的python环境，我们只需要在shell终端输入python2或python3进行调用即可。老版本的系统升级python环境需要以下操作：
        # 增加python源
        sudo add-apt-repository ppa:fkrull/deadsnakes
        # update 软件列表
        sudo apt-get update
        # 安装python3
        sudo apt-get install python3.5
</code></pre><h2 id="三、基础概念"><a href="#三、基础概念" class="headerlink" title="三、基础概念"></a>三、基础概念</h2><pre><code>变量：Python 是动态类型语言， 也就是说不需要预先声明变量的类型。变量是对象的引用，变量只是将指针指向了对象所在的内存地址。变量的类型和值在赋值那一刻被初始化。
变量起名：
    1.显式--&gt;通俗易懂
    2.nums_of_alex_gf = 19 
    3.NumsOfAlexGf = 20  驼峰写法
    4.中横线不能作为变量的命名字符
    5.数字不能作为开头，但可以在中间或者结尾
    6.特殊字符不能作为变量名的组成部分
    7.不能使用空格
    8.关键字不能声明为变量
</code></pre><h2 id="四、运算符"><a href="#四、运算符" class="headerlink" title="四、运算符"></a>四、运算符</h2><pre><code>算术运算符
    +  -  *  /   //  %  **
    /:传统除法，将执行地板除法，
    //:浮点除法，即去尾法除法，保留位数与除数和被除数的小数位数有关 （取整除，返回商的部分）
    **：平方运算
比较运算符
    &lt;  &lt;=  &gt;  &gt;=  ==  !=   &lt;&gt;
    不等于：!=   &lt;&gt;
    返回值是：True 和 False
赋值运算符
    &gt;&gt;&gt; counter = 0 
    &gt;&gt;&gt; miles = 1000.0 
    &gt;&gt;&gt; name = &apos;Bob&apos; 
    &gt;&gt;&gt; counter = counter + 1 
    &gt;&gt;&gt; kilometers = 1.609 * miles 
    &gt;&gt;&gt; print &apos;%f miles is the same as %f km&apos; % (miles, kilometers)
    1000.000000 miles is the same as 1609.000000 km
    支持简写：n=n*3 -&gt; n*=3  但不支持自增自减，因为“-” 和”+”是单目字符，--n -&gt; -(-n)n
位运算符
    &amp;      按位与      （a&amp;b）
    |      按位或    （a|b）
    ^    按位异或    （a^b）
    ~    按位取反    （~a）
    &lt;&lt;    左移动     a&lt;&lt;1 整体向左移动，结果是原来数值的2倍
    &gt;&gt;  右移动    a&gt;&gt;1 整体向右移动，结果是原来数值的1/2
逻辑运算符
    and 布尔“与”     同真为True
    or  布尔“或”     同假为False
    not    布尔“非”     非True即False
成员运算符
    in     如果在指定序列中找到指定的值，返回True
    not in 如果在指定序列中没找到指定的值，返回False
身份运算符
    is  判断两个标识符是不是引用自同一个对象
        type(names) is list 判断某个变量值的类型（list、int、dic）
    is not 判断两个标识符是不是引用自不同对象
</code></pre><h2 id="五、字符编码"><a href="#五、字符编码" class="headerlink" title="五、字符编码"></a>五、字符编码</h2><pre><code>python2 中在输入中文字符的时候会报字符编码的错误，在python3中已经引入了Unicode（万国码、统一码、），它为每种语言中的每个字符设定了统一并且唯一的二进制编码，规定所有的字符和符号最少由16位二进制来表示（2个字节），即2 ** 16 = 65536
UTF-8，是对Unicode编码的压缩和优化，它不再使用最少2个字节，而是将所有的字符和符号进行分类：ascii码中的内容用1个字节保存，欧洲的字符用2个字节保存，东亚的字符用3个字节保存

示例
python2
    #!/usr/local/env python2
    # -*- coding: utf-8 -*-  # 声明使用的字符类型，否则会报错
    &apos;&apos;&apos;
    @swht
    &apos;&apos;&apos;
    print &quot;你好！&quot;

python3
    #!/usr/local/env python3
    &apos;&apos;&apos;
    @swht
    &apos;&apos;&apos;
    print (&quot;你好！&quot;)

总结：在python3中完全不用考虑字符编码的问题，python解释器会自行处理字符类型的问题
</code></pre><h2 id="六、python流程控制"><a href="#六、python流程控制" class="headerlink" title="六、python流程控制"></a>六、python流程控制</h2><pre><code>流程控制分为两大类：条件判断和循环
其中循环又分为两类：for循环和while循环
条件判断和循环可以单独存在，也可以嵌套使用，以处理更为复杂的逻辑问题。
</code></pre><p>下面会从<em>if条件判断</em>、<em>for循环</em>和<em>while循环</em>进行代码示例：</p>
<h4 id="if-ex-py"><a href="#if-ex-py" class="headerlink" title="if_ex.py"></a>if_ex.py</h4><pre><code>#!/usr/bin/env python3
&apos;&apos;&apos;
@swht
&apos;&apos;&apos;
LuckyNum = 9
# 让用户输入一个数值与指定的值进行比较，当然这里没有处理用户输入为空的情况
# strip() 可以截取用户输入字符串首尾的空格
UserInputNum = int(input(&quot;请从1-100之间选择一个数字输入:&quot;).strip())
if UserInputNum &gt; LuckyNum:
    print(&quot;你输入的数字比我的LuckNum要大哦!&quot;)
elif UserInputNum &lt; LuckyNum:
    print(&quot;你输入的数字比我的LuckNum要小哦!&quot;)
else:
    print(&quot;恭喜你猜中了我的LuckNum,原来你就是我的幸运天使!&quot;)
</code></pre><h3 id="while-ex-py"><a href="#while-ex-py" class="headerlink" title="while_ex.py"></a>while_ex.py</h3><pre><code>#!/usr/bin/env python3
&apos;&apos;&apos;
@swht
&apos;&apos;&apos;
LuckyNum = 9
# 设置一个标志位，用于程序判断退出循环，
flag = True
while flage:
UserInputNum = int(input(&quot;请从1-100之间选择一个数字输入:&quot;).strip())
if UserInputNum &gt; LuckyNum:
    print(&quot;你输入的数字比我的LuckyNum要大哦!&quot;)
elif UserInputNum &lt; LuckyNum:
    print(&quot;你输入的数字比我的LuckyNum要小哦!&quot;)
else:
    print(&quot;恭喜你猜中了我的LuckyNum,原来你就是我的幸运天使!&quot;)
    flag = False 
</code></pre><h3 id="for-ex-py"><a href="#for-ex-py" class="headerlink" title="for_ex.py"></a>for_ex.py</h3><pre><code>#!/usr/bin/env python3
&apos;&apos;&apos;
@swht
&apos;&apos;&apos;
LuckyNum = 9
for count in range(3):
    UserInputNum = int(input(&quot;请从1-100之间选择一个数字输入:&quot;).strip())
    if UserInputNum &gt; LuckyNum:
        print(&quot;你输入的数字比我的LuckyNum要大哦!&quot;)
    elif UserInputNum &lt; LuckyNum:
        print(&quot;你输入的数字比我的LuckyNum要小哦!&quot;)
    else:
        print(&quot;恭喜你猜中了我的LuckyNum,原来你就是我的幸运天使!&quot;)
        break
else:
    print(&quot;你输入的次数已达到3次,程序即将退出!&quot;)
</code></pre><h3 id="对比break和countnue"><a href="#对比break和countnue" class="headerlink" title="对比break和countnue"></a>对比break和countnue</h3><pre><code>break是结束整个循环体，continue是结束单次循环

示例
    #!/usr/local/env python3
    &apos;&apos;&apos;
    @swht
    &apos;&apos;&apos;
    x = 0
    while x &lt; 10:
        if x ==3:
            break
        x += 1
        print(&quot;x=%s&quot; % x)
    输出结果：    x=1
                x=2
                x=3
    直接退出了整个while循环
</code></pre><h2 id="七、格式化输出"><a href="#七、格式化输出" class="headerlink" title="七、格式化输出"></a>七、格式化输出</h2><pre><code>使用&apos;&apos;&apos;string&apos;&apos;&apos;可以很方便的将多行内容进行注释，另外这个符号还有一个功能，那就是文档描述的功能。一般而言，在程序的前面后有一个文档说明，包括作者信息，版本信息，功能等

#!/usr/bin/env python
&apos;&apos;&apos;
@swht
&apos;&apos;&apos;

name = input(&quot;name:&quot;)
age = input(&quot;age:&quot;)
job = input(&quot;job:&quot;)

print(&quot;Information of:&quot; + name + &quot;\nname:&quot; + name + &quot;\nage:&quot; + age + &quot;\njob:&quot; + job)
print(&quot;Information of %s\nname:%s\nage:%s\njob:%s&quot; %(name,name,age,job))
print(&apos;&apos;&apos;
    Infomation of %s
             name:%s
              age:%s
              job:%s
    &apos;&apos;&apos; % (name,name,age,job))
</code></pre><h2 id="八、数据类型："><a href="#八、数据类型：" class="headerlink" title="八、数据类型："></a>八、数据类型：</h2><p><em>列表转换成元组：tuple(name_list)</em></p>
<p><em>元组转换成列表：list(元组_name)</em></p>
<pre><code>1.数字
    int     整型
    long     长整型
    float     浮点型
2.布尔
    1    真
    0    假
3.字符串
        stinglist = “Hello World”
    字符串操作：
        (参考：http://www.cnblogs.com/zhxiang/p/3385242.html
        http://www.jb51.net/article/47956.htm)
        移除空白：stinglist.strip()
        移除特殊字符：stinglist.lstrip().rstrip(&apos;,&apos;)
        分割：&gt;&gt;&gt; stringlist[2]
                 &apos;l&apos;
        长度：&gt;&gt;&gt; len(stringlist)
                 11
        索引：&gt;&gt;&gt; stringlist.index(&apos;W&apos;) #字母‘W’所在的索引值
                 6
        切片：&gt;&gt;&gt; stringlist[0:3] #顾前不顾尾
                 &apos;Hel&apos;
        字符串在输出时的对齐：
            &gt;&gt;&gt; stringlist[0:3]
            &apos;Hel&apos;
            &gt;&gt;&gt; stringlist[0:3].ljust(5) #ljust(width,[fillchar]) fillchar为填充字符，默认为空格
            &apos;Hel  &apos;
        字符串拼接：
            &gt;&gt;&gt; stringlist += s
            &gt;&gt;&gt; stringlist
            &apos;Hello Worldab,cde,fgh,ijk&apos;
        大小写转换：
            &gt;&gt;&gt;stringlist.lower() #小写
               &apos;hello world&apos;
            &gt;&gt;&gt; stringlist.upper() #大写
                &apos;HELLO WORLD&apos;
            &gt;&gt;&gt; stringlist.swapcase() #大小写互换
                &apos;hELLO wORLD&apos;
            &gt;&gt;&gt; stringlist.capitalize() #首字母大写
                &apos;Hello world&apos; 
            &gt;&gt;&gt; string.capwords(stringlist) #以空格分割，每个单词首字母大写
                &apos;Hello World&apos;
        字符串翻转：
            &gt;&gt;&gt; s
            &apos;sdsds sdsdsff&apos;
            &gt;&gt;&gt; s = s[::-1]
            &gt;&gt;&gt; s
            &apos;ffsdsds sdsds&apos;
        字符串查找：
            &gt;&gt;&gt; stringlist.find(&apos;World&apos;)
                6
        判断是否为整型：
            &gt;&gt;&gt; stringlist.isdigit()
                False
        判断字符串是否为空格：
            &gt;&gt;&gt; stringlist.isspace()
                False
        转换成列表：
            &gt;&gt;&gt; stringlist.split() #默认以空格为分割
                [&apos;Hello&apos;, &apos;World&apos;]

4.列表（dir(name_list)获取列表操作帮助）
    参考：http://www.jb51.net/article/46768.htm
    name_list = [&apos;alex&apos;, &apos;sddkd&apos;, &apos;shdjsjd&apos;, &apos;shen&apos;, &apos;swht&apos;, &apos;test&apos;]
    移除空白：name_list.strip()
    获取元素：name_list[index_num]
    索引：name_list.index(&quot;swht&quot;)  获取指定元素的索引值
    追加：name_list.append(&quot;test&quot;) 在列表后面追加一个元素
    插入：name_list.insert(3,&quot;ssdd&quot;) 在索引值3后面插入新的元素
    删除：name_list.pop() 删除最后一个元素
         name_list.remove(&quot;test&quot;) 删除指定的元素
    排序：name_list.sort()  对元素按照ASCII码进行排序
        python3 里面不能同时sort int 和 str类型
    反转顺序：name_list.reverse()  对列表中的元素进行反转操作
    切片：name_list[0:3]  切取索引值从0-2的值（切片顾头不顾尾）
    扩展：name_list.extend(name_list2) 在一个列表后面追加另一个列表的元素，或者追加一个变量中的单个字符
5.元组
    &gt;&gt;&gt; namelist = (&quot;swht&quot;,&quot;test&quot;)
    &gt;&gt;&gt; type(namelist)
        &lt;class &apos;tuple&apos;&gt;
    索引：&gt;&gt;&gt; namelist.index(&apos;swht&apos;) #查找某个字符串的索引值
             0
    统计：&gt;&gt;&gt; namelist.count(&apos;swht&apos;) #统计某个字符串出现的次数
             1
6.字典（无序）
    参考：http://www.jb51.net/article/47990.htm

    不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住
    键必须不可变，所以可以用数，字符串或元组充当，所以用列表就不行

    dict = {&quot;swht&quot;:&quot;test123&quot;,&quot;shen&quot;:&quot;test124&quot;,&quot;test&quot;:&quot;test125&quot;}
    访问字典里的值：
        &gt;&gt;&gt; dict[&quot;swht&quot;]
            &apos;test123&apos;
    增加字典里的值：
        &gt;&gt;&gt; dict[&quot;alex&quot;] = &quot;test126&quot;
        &gt;&gt;&gt; dict
        {&apos;test&apos;: &apos;test125&apos;, &apos;shen&apos;: &apos;test124&apos;, &apos;swht&apos;: &apos;test123&apos;, &apos;alex&apos;: &apos;test126&apos;}

    删除字典当中的元素：
        &gt;&gt;&gt; del dict[&quot;test&quot;]
        &gt;&gt;&gt; dict
        {&apos;shen&apos;: &apos;test124&apos;, &apos;swht&apos;: &apos;test123&apos;, &apos;alex&apos;: &apos;test126&apos;}
        &gt;&gt;&gt;                
    清空字典里的所有条目：
        &gt;&gt;&gt; dict.clear()
        &gt;&gt;&gt; dict
        {}
    删除字典：del dict
</code></pre><h2 id="九、文件操作"><a href="#九、文件操作" class="headerlink" title="九、文件操作"></a>九、文件操作</h2><pre><code>简单操作：
    filename = open(&quot;文件路径&quot;,&quot;模式&quot;)    #打开文件
    filename.write(&apos;内容&apos;)    #往文件中写入内容
    filename.read()        #一次性加载文件中的内容到内存
    filename.readlines()    #一次性加载所有的内容到内存，并根据行分割成字符串
    filename.close()    #关闭文件句柄
</code></pre><h2 id="十、作业"><a href="#十、作业" class="headerlink" title="十、作业"></a>十、作业</h2><pre><code>作业一：编写登录接口
</code></pre><p>，</p>
<pre><code>作业二：多级菜单    
</code></pre>]]></content>
    </entry>
    
  
  
</search>
