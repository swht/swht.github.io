<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>南非波波博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="这是一个记录学习和工作的个人博客。">
<meta property="og:type" content="website">
<meta property="og:title" content="南非波波博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="南非波波博客">
<meta property="og:description" content="这是一个记录学习和工作的个人博客。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="南非波波博客">
<meta name="twitter:description" content="这是一个记录学习和工作的个人博客。">
  
    <link rel="alternate" href="/atom.xml" title="南非波波博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">南非波波博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">文章</a>
        
          <a class="main-nav-link" href="http://www.cnblogs.com/songqingbo/">cnblogs博客</a>
        
          <a class="main-nav-link" href="https://github.com/swht">github</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-s12-20160514-day17" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/14/s12-20160514-day17/" class="article-date">
  <time datetime="2016-05-14T07:30:00.000Z" itemprop="datePublished">2016-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/14/s12-20160514-day17/">pytho自动化开发 day17</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author:@南非波波</p>
<p>课程大纲：</p>
<p><a href="http://www.cnblogs.com/alex3714/articles/5474411.html" title="常用算法设计" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5474411.html</a></p>
<p>一、</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/14/s12-20160514-day17/" data-id="ciq8usaf3000rogj5yffqxdvb" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python开发之路/">Python开发之路</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-s12-20160507-day16" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/07/s12-20160507-day16/" class="article-date">
  <time datetime="2016-05-07T07:30:00.000Z" itemprop="datePublished">2016-05-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/07/s12-20160507-day16/">pytho自动化开发 day16</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author:@南非波波</p>
<p>课程大纲：</p>
<p><a href="http://www.cnblogs.com/alex3714/articles/5457672.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5457672.html</a></p>
<h2 id="一、Django起步"><a href="#一、Django起步" class="headerlink" title="一、Django起步"></a>一、Django起步</h2><p>1.创建Django项目</p>
<pre><code>两种方式：使用pycharm工具进行创建
         使用manage命令进行创建
</code></pre><p><img src="http://i.imgur.com/UKdz7aG.png" alt=""></p>
<p>2.url设计</p>
<p><img src="http://i.imgur.com/2y2zgI4.png" alt=""></p>
<p>3.views视图设计<br><img src="http://i.imgur.com/M1xkgkw.png" alt=""></p>
<p><img src="http://i.imgur.com/UsZ5fay.png" alt=""></p>
<p>4.Template版本设计<br><img src="http://i.imgur.com/LLavnYW.png" alt=""></p>
<h2 id="二、Template模板渲染"><a href="#二、Template模板渲染" class="headerlink" title="二、Template模板渲染"></a>二、Template模板渲染</h2><p>1.调用后端传递的数据</p>
<pre><code>&lt;h3&gt;username:{{user_obj.username}}&lt;/h3&gt;
   &lt;h3&gt;E-mail:{{user_obj.email}}&lt;/h3&gt;
</code></pre><p>2.使用for循环进行遍历数据</p>
<pre><code>&lt;url&gt;
    {% for user_info in user_obj %}
        	<li style="">username:{{user_info.username}},E-mail:{{user_info.email}}</li>
        {% endfor %}
&lt;/url&gt;
</code></pre><p>3.使用if进行相关条件判断</p>
<pre><code>&lt;url&gt;
    {% for user_info in user_obj %}
		{#  {% if user_info.username == "swht" %}#} <!--可以直接判断某个字符串，然后进行处理-->
	    	{% if forloop.counter0|divisibleby:"2" %} <!--使用forloop。counter参数获取遍历的当前数字。counter0是从0开始的索引值，divisibleby:"2"是指能够被2整除-->
	        	<li style="background-color: aqua">username:{{user_info.username}},E-mail:{{user_info.email}}</li>
	        {% else %}
	            <li style="">username:{{user_info.username}},E-mail:{{user_info.email}}</li>
	        {% endif %}
	
	   	{% endfor %}
&lt;/url&gt;
</code></pre><p>4.模板的继承与复用</p>
<p>使用主页的头部进行继承，然后将主体进行重写</p>
<pre><code>index.html

{% block header-menu %}
	    <ul>
	        <li style="display: inline-block">Home</li>
	        <li style="display: inline-block">page1</li>
	        <li style="display: inline-block">page2</li>
	        <li style="display: inline-block">page3</li>
	    </ul>
	    {% endblock %}
    {% block content-container %}
	    <h2>这是文章的首页</h2>
	    <!--<h3>username:{{user_obj.username}}</h3>-->
	    <!--<h3>E-mail:{{user_obj.email}}</h3>-->
	    <url>
	        {% for user_info in user_obj %}
	{#            {% if user_info.username == "swht" %}#} <!--可以直接判断某个字符串，然后进行处理-->
	            {% if forloop.counter0|divisibleby:"2" %} <!--使用forloop。counter参数获取遍历的当前数字。counter0是从0开始的索引值，divisibleby:"2"是指能够被2整除-->
	                <li style="background-color: aqua">username:{{user_info.username}},E-mail:{{user_info.email}}</li>
	            {% else %}
	                <li style="">username:{{user_info.username}},E-mail:{{user_info.email}}</li>
	            {% endif %}
	
	        {% endfor %}
	    </url>
	    {% endblock %}

year.html

{% extends 'article/index.html' %}
{% block content-container %}
	    <h1>这是{{ year_obj.year }}年的文章</h1>
	{% endblock %}
</code></pre><p>说明：</p>
<pre><code>{% extends 'article/index.html' %} 语法是继承主页的所有属性
{% block content-container %}
	{% endblock%}  语法说明该语块是可以被重写的
</code></pre><p>模板的继承和重写支持：子继承父、孙继承子</p>
<h2 id="三、配置文件"><a href="#三、配置文件" class="headerlink" title="三、配置文件"></a>三、配置文件</h2><p>1.setting文件说明</p>
<pre><code>BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))  指定了当前项目文件的基础路径
SECRET_KEY = &apos;-i6p7t+w6@&amp;duki)8s88tf=_ms%@z8fz4_5g@vhvzp@tij36w$&apos; django通信KEY，我们一般不需要进行修改

DEBUG = True  #选项为True时，属于开发环境，当遇到错误时会弹出默认的提示大黄页，当选项为False时，属于生产环境，需要下面的关键字进行配合设置
ALLOWED_HOSTS = [] #当DEBUG = False时，ALLOWED_HOSTS = [*]，即允许所有主机访问，当访问的资源不存在时，默认会返回默认的404页面提示
INSTALLED_APPS=[] #这里需要配置我们安装的应用的名称
TEMPLATES = [] #这里指定项目模板的路径，一般不需要修改，但也可以自定义路径
DATABASES = {} #这里默认使用sqlite3数据库进行存储，我们可以修改成支持的其他数据库类型
TIME_ZONE = &apos;Asia/Shanghai&apos; #这里的时区参数需要选择上海时区
</code></pre><p>2.设置mysql数据库配置</p>
<pre><code>DATABASES = {
    &apos;default&apos;:{
        &apos;ENGINE&apos;:&apos;django.db.backends.mysql&apos;,
        &apos;NAME&apos;:&apos;blog&apos;,
        &apos;HOST&apos;:&apos;127.0.0.1&apos;,
        &apos;PORT&apos;:&apos;3306&apos;,
        &apos;USER&apos;:&apos;root&apos;,
        &apos;PASSWORD&apos;:&apos;&apos;,
    }
}

Windows下面安装mysql环境：http://www.cnblogs.com/songqingbo/p/5080847.html

创建所需的数据库：
    create database blog charset utf8;
</code></pre><p>3.mysql数据库初始化</p>
<pre><code>models

class Author(models.Model):
    first_name = models.CharField(max_length=32)
    last_name = models.CharField(max_length=32)
    email = models.EmailField()
    def __unicode__(self):
        return &quot;&lt;%s %s&gt;&quot; %(self.first_name,self.last_name)

    class Meta:
        verbose_name_plural = u&quot;作者&quot;
    #def __str__()
class Publisher(models.Model):
    name = models.CharField(max_length=64,unique=True)
    address = models.CharField(max_length=128,null=True,blank=True)
    city = models.CharField(max_length=64)
    state_province = models.CharField(max_length=30,help_text=&quot;put your country code here..&quot;,verbose_name=u&quot;所属省&quot;)
    country = models.CharField(max_length=50,editable=False)
    website = models.URLField()
    def __unicode__(self):
        return &quot;&lt;%s&gt;&quot; %(self.name)
class Book(models.Model):
    name = models.CharField(max_length=128)
    authors = models.ManyToManyField(Author)
    publisher = models.ForeignKey(Publisher)
    #publish_date = models.DateTimeField
    publish_date = models.DateField()
    def __unicode__(self):
        return &quot;&lt;%s&gt;&quot; %(self.name)
</code></pre><p>由于django需要MySQLdb进行连接mysql数据库，需要安装MySQLdb模块和vc++ for python2.7环境包。</p>
<pre><code>python2 manage.py makemigrations  #生成数据库创建表文件
    Migrations for &apos;article&apos;:
      0001_initial.py:
        - Create model Author
        - Create model Book
        - Create model Publisher
        - Add field publisher to book
python2 manage.py migrate #将表结构写入数据库
    Operations to perform:
      Apply all migrations: admin, article, contenttypes, auth, sessions
    Running migrations:
      Rendering model states... DONE
      Applying contenttypes.0001_initial... OK
      Applying auth.0001_initial... OK
      Applying admin.0001_initial... OK
      Applying admin.0002_logentry_remove_auto_add... OK
      Applying article.0001_initial... OK
      Applying contenttypes.0002_remove_content_type_name... OK
      Applying auth.0002_alter_permission_name_max_length... OK
      Applying auth.0003_alter_user_email_max_length... OK
      Applying auth.0004_alter_user_username_opts... OK
      Applying auth.0005_alter_user_last_login_null... OK
      Applying auth.0006_require_contenttypes_0002... OK
      Applying auth.0007_alter_validators_add_error_messages... OK
</code></pre><p>4.创建后台用户</p>
<pre><code>admin.py
    #增加下面的语句作用是使用admin后台进行数据库的管理操作
    import models
    admin.site.register(models.Author)
    admin.site.register(models.Book)
    admin.site.register(models.Publisher)
python2 manage.py createsuperuser #创建一个超级用户
</code></pre><p><img src="http://i.imgur.com/Foh6exY.png" alt="Django后台增加数据"></p>
<h3 id="四、使用django命令对数据库进行基础操作"><a href="#四、使用django命令对数据库进行基础操作" class="headerlink" title="四、使用django命令对数据库进行基础操作"></a>四、使用django命令对数据库进行基础操作</h3><ol>
<li><p>进入python django shell</p>
<p> shell&gt;&gt;python2 manage.py shell</p>
</li>
<li><p>查询数据</p>
<p> >&gt;&gt;from article.models import Publisher</p>
<p> >&gt;&gt;publisher_list = Publisher.objects.all() #查询所有的出版社列表</p>
<p> >&gt;&gt;publisher_list[1].name  #查询第2个出版社的名称</p>
<p> >&gt;&gt;publisher_list[1].id  #查询第2个出版社的id</p>
</li>
<li><p>增加一条数据</p>
<p> >&gt;&gt; p1 = Publisher.objects.create(name=’SWht’,address=’haidian’,city=’beijing’,state_province=’CA’,country=’CN’,website=’<a href="http://www.songqingbo.cn" target="_blank" rel="external">http://www.songqingbo.cn</a>‘)</p>
<p> >&gt;&gt;p2 = Publisher(name=’SWht2’,address=’haidian1’,city=’beijing’,state_province=’CA’,country=’CN’,website=’<a href="http://www.songqingbo.cn" target="_blank" rel="external">http://www.songqingbo.cn</a>‘)</p>
<p> >&gt;&gt;p2.save()  #增加数据两种方式，1.使用对象的objects的create方法进行数据的创建，2.使用对象的save方法进行数据的保存。</p>
</li>
<li><p>数据库过滤查询</p>
<p> >&gt;&gt; from article.models import Author</p>
<p> >&gt;&gt; author_list = Author.objects.all()</p>
<p> >&gt;&gt; author_list</p>
<p> [<author: <shen="" test="">&gt;, <author: <alix="" sds="">&gt;]</author:></author:></p>
<p> >&gt;&gt; Author.objects.filter(first_name=’shen’)</p>
<p> [<author: <shen="" test="">&gt;]</author:></p>
</li>
<li><p>获取单个对象</p>
<p> >&gt;&gt; Author.objects.get(first_name=’shen’)</p>
<p> <author: <shen="" test="">&gt;</author:></p>
<p> >&gt;&gt; Author.objects.get(id=’1’)</p>
<p> <author: <shen="" test="">&gt;</author:></p>
<p> >&gt;&gt; Author.objects.get(id=’2’)</p>
<p> <author: <alix="" sds="">&gt;</author:></p>
<p> 注意：如果查询没有返回结果也会抛出异常</p>
</li>
<li><p>数据排序</p>
<p> >&gt;&gt; Author.objects.order_by(“first_name”)</p>
<p> [<author: <alix="" sds="">&gt;, <author: <shen="" test="">&gt;]</author:></author:></p>
<p> >&gt;&gt; Author.objects.order_by(“id”)</p>
<p> [<author: <shen="" test="">&gt;, <author: <alix="" sds="">&gt;]</author:></author:></p>
</li>
<li><p>数据更新</p>
<p> >&gt;&gt; author = Author.objects.get(last_name=’test’)</p>
<p> >&gt;&gt; author.last_name = ‘diaoxia’</p>
<p> >&gt;&gt; author.save()</p>
<p> >&gt;&gt; Author.objects.all()</p>
<p> [<author: <shen="" diaoxia="">&gt;, <author: <alix="" sds="">&gt;]</author:></author:></p>
</li>
<li><p>删除对象</p>
<p> >&gt;&gt; author = Author.objects.get(first_name=’alix’)</p>
<p> >&gt;&gt; author</p>
<p> <author: <alix="" sds="">&gt;</author:></p>
<p> >&gt;&gt; author.delete()</p>
<p> (2L, {u’article.Book_authors’: 1L, u’article.Author’: 1L})</p>
<p> >&gt;&gt; Author.objects.all()</p>
<p> [<author: <shen="" diaoxia="">&gt;]</author:></p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/07/s12-20160507-day16/" data-id="ciq8usaet000nogj5gfbwbo5t" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python开发之路/">Python开发之路</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-s12-20160430-day15" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/30/s12-20160430-day15/" class="article-date">
  <time datetime="2016-04-30T07:30:00.000Z" itemprop="datePublished">2016-04-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/30/s12-20160430-day15/">pytho自动化开发 day15</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author:@南非波波</p>
<p>课程大纲：</p>
<p><a href="http://www.cnblogs.com/wupeiqi/articles/4491246.html" target="_blank" rel="external">http://www.cnblogs.com/wupeiqi/articles/4491246.html</a><br><a href="http://www.cnblogs.com/wupeiqi/articles/4508271.html" target="_blank" rel="external">http://www.cnblogs.com/wupeiqi/articles/4508271.html</a></p>
<h2 id="一、前端设计"><a href="#一、前端设计" class="headerlink" title="一、前端设计"></a>一、前端设计</h2><p>1.实现图片轮播</p>
<pre><code>js下载地址：
    http://bxslider.com/
引入
    &lt;!-- jQuery library (served from Google) --&gt;
    &lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js&quot;&gt;&lt;/script&gt;
    &lt;!-- bxSlider Javascript file --&gt;
    &lt;script src=&quot;/js/jquery.bxslider.min.js&quot;&gt;&lt;/script&gt;
    &lt;!-- bxSlider CSS file --&gt;
    &lt;link href=&quot;/lib/jquery.bxslider.css&quot; rel=&quot;stylesheet&quot; /&gt;
加载图片：
    &lt;ul class=&quot;bxslider&quot;&gt;
      &lt;li&gt;&lt;img src=&quot;/images/pic1.jpg&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;/images/pic2.jpg&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;/images/pic3.jpg&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;/images/pic4.jpg&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;

调用：    
    $(document).ready(function(){
      $(&apos;.bxslider&apos;).bxSlider();
    });
</code></pre><p>2.图标资源</p>
<pre><code>Font Awesome
   http://fontawesome.io/
   a、图片，自己找图片，挖洞
   b、现成的图标
       css
       使用样式
       --以前版本
           css
           图片库
           使用样式
       -- 现在
           css
           字体文件
           使用样式
   c、css
       字体文件
       样式
   =====》 大图片
</code></pre><p>3.伪类</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;响应式&lt;/title&gt;
    &lt;style&gt;
        @media (min-width: 768px) {
            .lead {
                background-color: red;
            }
        }
        .c1 {
            background-color: green;
            }
        .clearfix:after {
            content: &quot;.&quot;;
            clear: both;
            visibility: hidden;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;dev class=&quot;lead&quot;&gt;
        我们都是中国人
    &lt;/dev&gt;

    &lt;div class=&quot;c1 clearfix&quot;&gt;
        &lt;div style=&quot;float: right;&quot;&gt;
            你好
        &lt;/div&gt;
         &lt;div style=&quot;float: right;&quot;&gt;
             china
        &lt;/div&gt;
         &lt;!--&lt;div style=&quot;clear: both&quot;&gt;&lt;/div&gt;--&gt;
    &lt;/div&gt;


&lt;/body&gt;
&lt;/html&gt;
</code></pre><h2 id="二、web框架"><a href="#二、web框架" class="headerlink" title="二、web框架"></a>二、web框架</h2><p>1.python web框架分类</p>
<pre><code>#!/usr/bin/env python
#coding:utf-8

import socket

def handle_request(client):
    buf = client.recv(1024)
    client.send(&quot;HTTP/1.1 200 OK\r\n\r\n&quot;)
    client.send(&quot;Hello, Seven&quot;)

def main():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.bind((&apos;localhost&apos;,8000))
    sock.listen(5)

    while True:
        connection, address = sock.accept()
        handle_request(connection)
        connection.close()

if __name__ == &apos;__main__&apos;:
    main()
</code></pre><p>2.MVC web框架</p>
<pre><code>MVC：Models  Views Controllers

        数据库操作 模板  处理请求的函数
代码块的归类结构

MTV：Models Templates Views

    数据库操作 模板  处理请求的函数
</code></pre><p>3.Django基础</p>
<pre><code>Django框架属于MTV框架。程序需要的操作的：
    1.models
    2.Templates
    3.Views
    4.urls
</code></pre><h2 id="三、Django"><a href="#三、Django" class="headerlink" title="三、Django"></a>三、Django</h2><p>1.安装</p>
<pre><code>pip install django 1.9.5
</code></pre><p>2.创建Django程序框架</p>
<pre><code>使用命令创建
    django-admin startproject demo 创建projects
    cd demo
    python manage.py startapp app0 创建应用
使用pycharm进行创建项目和应用
</code></pre><p>3.执行程序</p>
<pre><code>进入项目， python manage.py runserver 127.0.0.1：8000
</code></pre><p>4.创建数据表</p>
<pre><code>python manage.py makemigrations #生成配置文件
python manage.py migrate       #根据配置文件创建数据库相关 表
</code></pre><p>5.django默认后台管理</p>
<pre><code>创建超级用户名 python manage.py createsuperuser
</code></pre><p>6.路由系统</p>
<pre><code>静态路由
动态路由
    安照顺序，第n个匹配的数据交给函数的第n个参数，严格按照顺序
        url(r&apos;^page/（\d+)/(\d+)&apos;,views.page)
    模板的方法，将匹配的参数，传给指定的形式参数
        url(r&apos;^page/(?P&lt;n1&gt;\d+)/(?P&lt;n2&gt;\d+)&apos;,views.page)
二级路由
    app01
        urls.py
    project name 
        URL：app01 -&gt;include（&quot;app01.urls&quot;）
</code></pre><p><img src="http://i.imgur.com/QbaeTDM.png" alt=""></p>
<p>7.基本数据库操作</p>
<pre><code>ORM框架
    code first
        自己写类 --&gt;数据库表
    db first
        自己写命令操作数据库--&gt;更新类
    使用类进行数据操作

创建类
    from django.db import models
    class UserInfo(models.Model):
        username = models.CharField(max_length=32)
        password = models.CharField(max_length=32)
        age = models.IntegerField()

配置
    setting
        INSTALLED_APPS = [
            &apos;django.contrib.admin&apos;,
            &apos;django.contrib.auth&apos;,
            &apos;django.contrib.contenttypes&apos;,
            &apos;django.contrib.sessions&apos;,
            &apos;django.contrib.messages&apos;,
            &apos;django.contrib.staticfiles&apos;,
            &apos;app01&apos;,
        ]
使用命令根据类创建表
    python manage.py makemigrations #生成配置文件
    python manage.py migrate       #根据配置文件创建数据库相关 表
默认表名：
    appname_classname

d. 
    views中导入models

e.
    POST提交数据
        settings里操作：
            MIDDLEWARE_CLASSES = [
                &apos;django.middleware.security.SecurityMiddleware&apos;,
                &apos;django.contrib.sessions.middleware.SessionMiddleware&apos;,
                &apos;django.middleware.common.CommonMiddleware&apos;,
               # &apos;django.middleware.csrf.CsrfViewMiddleware&apos;,
                &apos;django.contrib.auth.middleware.AuthenticationMiddleware&apos;,
                &apos;django.contrib.auth.middleware.SessionAuthenticationMiddleware&apos;,
                &apos;django.contrib.messages.middleware.MessageMiddleware&apos;,
                &apos;django.middleware.clickjacking.XFrameOptionsMiddleware&apos;,
            ]
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/30/s12-20160430-day15/" data-id="ciq8usaey000pogj59jzjg5ya" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python开发之路/">Python开发之路</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-s12-20160421-day14" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/21/s12-20160421-day14/" class="article-date">
  <time datetime="2016-04-21T07:30:00.000Z" itemprop="datePublished">2016-04-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/21/s12-20160421-day14/">pytho自动化开发 day14</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author:@南非波波</p>
<p>课程大纲：</p>
<p><a href="http://www.cnblogs.com/wupeiqi/articles/5369773.html" target="_blank" rel="external">http://www.cnblogs.com/wupeiqi/articles/5369773.html</a></p>
<p><a href="http://www.php100.com/manual/jquery/" target="_blank" rel="external">http://www.php100.com/manual/jquery/</a></p>
<h2 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h2><h3 id="1-查找"><a href="#1-查找" class="headerlink" title="1.查找"></a>1.查找</h3><h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><pre><code>$(&apos;#nid&apos;)  根据id找到某个标签
$(&apos;.nid&apos;)  根据class查找
$(&apos;.nid div #nid&apos;)  根据class查找下面的div标签下面的id
$(&apos;.nid,div,#nid&apos;)  查找到class或div或id条件的查找到
$(&apos;li:eq(0)&apos;)  查到到第一个li标签行
</code></pre><h4 id="筛选器"><a href="#筛选器" class="headerlink" title="筛选器"></a>筛选器</h4><pre><code>$(&apos;li&apos;).eq(0)  查到到第一个li标签行
</code></pre><h2 id="2-操作"><a href="#2-操作" class="headerlink" title="2.操作"></a>2.操作</h2><p>属性</p>
<pre><code>添加指定属性，并删除兄弟的属性
 $(ths).addClass(&apos;current&apos;).siblings().removeClass(&apos;current&apos;);

attr：
    其他所有标签都适用，除checkbox、redio之外
prop：
    checkbox、redio

jQuery循环：

    var userList = [&apos;swht&apos;,&apos;shen&apos;,&apos;test&apos;];
    $.each(userList,fun(i,item){
        console.log(i,item);
    })    
</code></pre><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>文档处理</p>
<pre><code>增加
append(content|fn)
    在指定的标签内部后面追加
appendTo(content)
    把指定的某个标签追加某个标签内部后面
prepend(content|fn)
    在指定的标签内部前面追加
prependTo(content)
    把指定的某个标签追加某个标签内部前面
包裹
wrap(html|ele|fn)
unwrap()
wrapAll(html|ele)
wrapInner(html|ele|fn)

删除
empty()
remove([expr])
detach([expr])
复制
clone([Even[,deepEven]])
</code></pre><p>事件</p>
<pre><code>绑定事件：
    1. 直接绑定ready(fn) 文本加载完之后执行事件绑定
        1. $(document).ready(function(){

            })
        2. $(function(){

            })
    2. 委派delegate(s,[t],[d],fn)
        1. $(&apos;ul&apos;).delegate(&apos;li&apos;,&apos;click&apos;,function(){

           })

    3. bind(type,[data],fn)
        1. $(&apos;li&apos;).click(function(){

            })
        2. $(&apos;li&apos;).bind(&apos;click&apos;)
        3. unbind
</code></pre><p>AJAX</p>
<pre><code>异步的javascript和xml
ajax是对javascript和Dom的封装。
ajax容易出现跨域的问题。
$.ajax({
    url:&quot;&quot;,
    data:{},
    type:&quot;&quot;,
    dateType:&quot;&quot;,
    jsonp:&quot;&quot;,
    jsonpCallback:&quot;&quot;,
    sucess:function(){},
    error:function(){}
})
</code></pre><p>JQuery扩展</p>
<pre><code>(function(arg){
    arg.extend({
      qinghua: function() {
        return &quot;SB&quot;;
      },
      qinghua1: function() {
        return this.each(function() { this.checked = false; });
      }
    });

    arg.fn.extend({
       sanjiang:function(){
           return &quot;DSB&quot;
       }
    });
})(jQuery);
</code></pre><p>其他</p>
<p>30款最好的 Bootstrap 3.0 免费主题和模板<br><a href="http://www.cnblogs.com/lhb25/p/30-free-bootstrap-templates.html" target="_blank" rel="external">http://www.cnblogs.com/lhb25/p/30-free-bootstrap-templates.html</a></p>
<p>例子：</p>
<pre><code>tab菜单

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;tab&lt;/title&gt;
    &lt;style&gt;
        .tab-box .box-menu{
            background-color: #DDDDDD;
            border: 1px solid #DDDDDD;
            height: 33px;
            line-height: 33px;
        }
        .box-menu a{
            border-right: 1px solid #664747;
            padding: 10px;
            background-color: #425a66;;
        }
        .tab-box .box-body{
            border: 1px solid #dddddd;
        }
        .hide{
            display: none;
        }
         .current{
            background-color: white;
            color: black;
            border-top: 2px solid red;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;tab-box&quot;&gt;
        &lt;div class=&quot;box-menu&quot;&gt;
            &lt;!--所有菜单--&gt;
            &lt;a menu1=&quot;c1&quot; onclick=&quot;ChangeTab(this);&quot; class=&quot;current&quot;&gt;菜单一&lt;/a&gt;
            &lt;a menu1=&quot;c2&quot; onclick=&quot;ChangeTab(this);&quot;&gt;菜单二&lt;/a&gt;
            &lt;a menu1=&quot;c3&quot; onclick=&quot;ChangeTab(this);&quot;&gt;菜单三&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class=&quot;box-body&quot;&gt;
            &lt;!--所有内容--&gt;
            &lt;div id=&quot;c1&quot;&gt;内容一&lt;/div&gt;
            &lt;div id=&quot;c2&quot; class=&quot;hide&quot;&gt;内容二&lt;/div&gt;
            &lt;div id=&quot;c3&quot; class=&quot;hide&quot;&gt;内容三&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;script src=&quot;jquery-2.2.3.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        function ChangeTab(ths){
            $(ths).addClass(&apos;current&apos;).siblings().removeClass(&apos;current&apos;);
            var contentId = $(ths).attr(&apos;menu1&apos;);
            var temp = &quot;#&quot; + contentId;
            $(temp).removeClass(&apos;hide&apos;).siblings().addClass(&apos;hide&apos;);

        }
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;


全选、反选、取消

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;全选、反选、取消&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;
        &lt;input type=&quot;button&quot; value=&quot;全选&quot; onclick=&quot;selectAll();&quot; /&gt;
        &lt;input type=&quot;button&quot; value=&quot;反选&quot; onclick=&quot;selectInvert();&quot; /&gt;
        &lt;input type=&quot;button&quot; value=&quot;取消&quot; onclick=&quot;clearAll();&quot; /&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;table border=&quot;1&quot;&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;input type=&quot;checkbox&quot; /&gt;
                &lt;/td&gt;
                &lt;td&gt;
                    第一章
                &lt;/td&gt;
                &lt;td&gt;
                    第一篇
                &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;input type=&quot;checkbox&quot; /&gt;
                &lt;/td&gt;
                &lt;td&gt;
                    第二章
                &lt;/td&gt;
                &lt;td&gt;
                    第一篇
                &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;input type=&quot;checkbox&quot; /&gt;
                &lt;/td&gt;
                &lt;td&gt;
                   第三章
                &lt;/td&gt;
                &lt;td&gt;
                    第一篇
                &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;input type=&quot;checkbox&quot; /&gt;
                &lt;/td&gt;
                &lt;td&gt;
                   第四章
                &lt;/td&gt;
                &lt;td&gt;
                    第一篇
                &lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;
    &lt;/div&gt;

    &lt;script src=&quot;jquery-2.2.3.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        function selectAll(){
            $(&quot;table input[type=&apos;checkbox&apos;]&quot;).prop(&apos;checked&apos;,true);
        }
        function selectInvert(){
            $(&quot;table input[type=&apos;checkbox&apos;]&quot;).each(function(){
               var isChecked = $(this).prop(&apos;checked&apos;);
                if(isChecked){
                    $(this).prop(&apos;checked&apos;,false);
                }else{
                    $(this).prop(&apos;checked&apos;,true);
                }
            });
        }
        function clearAll(){
            $(&quot;table input[type=&apos;checkbox&apos;]&quot;).prop(&apos;checked&apos;,false);
        }
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;


ajax_jsonp

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;ajax_jsonp&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;input type=&quot;button&quot; value=&quot;获取电视节目&quot; onclick=&quot;Ajax_jsonp();&quot;/&gt;
    &lt;dev id=&quot;contaner&quot;&gt;

    &lt;/dev&gt;
    &lt;script src=&quot;jquery-2.2.3.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        function Ajax_jsonp(){
            $.ajax({
                url:&quot;http://www.jxntv.cn/data/jmd-jxtv2.html&quot;,
                data:{},
                type:&quot;GET&quot;,
                dataType:&quot;jsonp&quot;,
                jsonp:&quot;callback&quot;,
                jsonpCallback:&quot;list&quot;,
                success:function(arg){
                    console.log(arg);
                    var jsonArray = arg.data;
                    $.each(jsonArray,function(k,v){
                        var week = v.week;
                        var label = &quot;&lt;h1&gt;&quot; + week + &quot;&lt;/h1&gt;&quot;;
                        $(&quot;#contaner&quot;).append(label);
                        var listArray = v.list;
                        $.each(listArray,function(kk,vv){
                            var link = vv.link;
                            var name = vv.name;
                            var time = vv.time;
                            var labelNew = &quot;&lt;a href=&apos;&quot; + link + &quot;&apos;&gt;&quot; + time+name + &quot;&lt;/a&gt;&lt;br/&gt;&quot;;
                            $(&quot;#contaner&quot;).append(labelNew);
                        })
                    })
                },
                error:function(arg){
                    console.log(arg);
                }
            })
        }
    &lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/21/s12-20160421-day14/" data-id="ciq8usaeo000logj5lw9qiw3d" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python开发之路/">Python开发之路</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-s12-20160409-day13" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/09/s12-20160409-day13/" class="article-date">
  <time datetime="2016-04-09T07:30:00.000Z" itemprop="datePublished">2016-04-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/09/s12-20160409-day13/">pytho自动化开发 day13</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author:@南非波波</p>
<p>课程大纲：</p>
<p>day13</p>
<p><a href="http://www.cnblogs.com/wupeiqi/articles/5369773.html" target="_blank" rel="external">http://www.cnblogs.com/wupeiqi/articles/5369773.html</a></p>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><pre><code>js    
    使页面动起来的一门语言，解释器就是浏览器的引擎
dom
    提供一套api
jQuery
    封装的JS和dom的类库
</code></pre><h2 id="一、javaScript"><a href="#一、javaScript" class="headerlink" title="一、javaScript"></a>一、javaScript</h2><pre><code>1. 存在形式：
    文件
    标签
2. 放置位置：
    原则上可以存在head 和body，但是当页面请求不到js的时候就会一直在等待。建议将js代码放在body底部
3. 声明变量：
    name = &quot;swht&quot;;  //全局变量
    age = 18;   //局部变量    

4. 注释：
    当行注释：  //
    多行注释：    /*  ..  */
    每行代码结束需要加分号(;)
5. 类型：
    数字                
    字符串
    数组（字典）
6. 类型转换：
    var age = 18；
    var age = Number(18)；

    Number(&quot;123&quot;);
    parseInt(&apos;123&apos;);  //将字符串转换成数字类型
    var num = 18.9;
    num1 = parseInt(num); //将数字类型转换成整型数字输出
    num2 = parseFloat(num); //将数字类型转换成浮点型数字输出
    console.log(&quot;num1:&quot;,num1,typeof num1,&quot;num2:&quot;,num2,typeof num2); //控制台打印转换后的值和类型
    //输出结果：num1: 18 number num2: 18.9 number
7. 控制台打印：
    var age = &quot;18&quot;; 
    var n1 = 1,n2 = 3,n3 = 4; //单行可以声明多个变量并赋值
    console.log(age,typeof age); //控制台输出变量的值和类型
</code></pre><h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><pre><code>1. 去除字符串左右空格：        
    var name = &quot;swht   &quot;;
    name.trim();    
2. 按索引取值：
    var name = &quot;swht&quot;;
    name.charAt(1);
3. search:
    name.search(&quot;w&quot;);  //返回字符所在的索引值
4. split：
    name.split(&quot;&quot;);  //将字符串转换成数组
    [&quot;s&quot;, &quot;w&quot;, &quot;h&quot;, &quot;t&quot;, &quot; &quot;, &quot; &quot;, &quot; &quot;]
5. xx
</code></pre><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><pre><code>var li1 = [11,22,33,44];
for (var index in li1){
    console.log(index);
}

for (var i = 0;i &lt; li1.length;i++){
    console.log(i,li1[i]);
}

var dict = {&quot;name&quot;:&quot;swht&quot;,&quot;age&quot;:18,&quot;work&quot;:&quot;运维&quot;}
for (var item in dict){
    console.log(item,dict[item]);
}
</code></pre><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><pre><code>while(true){
    countine;
    break;
}
</code></pre><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><pre><code>var name = &apos;1&apos;;
switch (name){
    case &quot;1&quot;:
        console.log(1);
        break;
    case &quot;2&quot;:
        console.log(2);
        break;
    case &quot;3&quot;:
        console.log(3);
        break;
    default:
        console.log(&apos;default&apos;);
        break;
}
</code></pre><h4 id="if条件句"><a href="#if条件句" class="headerlink" title="if条件句"></a>if条件句</h4><pre><code>var name = &quot;swht&quot;;
if (name == &quot;alex&quot;){
    console.log(err);
}else if (name == &quot;hh&quot;){
    console.log(true);
}else {
    console.log(&quot;你逗呢！&quot;);
}
</code></pre><h4 id="try"><a href="#try" class="headerlink" title="try"></a>try</h4><pre><code>var name = &quot;swht&quot;;
try {
    if (name == &quot;shen&quot;){
        console.log(&quot;err&quot;);
    }else {
        console.log(&quot;false&quot;);
    }
}catch (e){
    console.log(e);
}finally {
    console.log(&quot;finally&quot;);
}
</code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><pre><code>//函数的声明
function func1(arg){
    return true;
}
//匿名函数
var func2 = function(arg){
    return true;
}
//自执行函数，一般用在jq封装类库时使用
(function(arg){
    console.log(arg);
})(&apos;123&apos;)
</code></pre><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><pre><code>function Foo(name,age){
this.Name = name;
this.Age = age;
this.Func = function(arg){
    return this.Name +arg;
}
}
var obj = new Foo(&apos;swht&apos;,22)
console.log(obj.Name);
console.log(obj.Age);
var ret = obj.Func(&apos;haha&apos;);
console.log(ret);
</code></pre><h2 id="二、Dom"><a href="#二、Dom" class="headerlink" title="二、Dom"></a>二、Dom</h2><p>文档对象模型（Document Object Model，DOM）是一种用于HTML和XML文档的编程接口。它给文档提供了一种结构化的表示方法，可以改变文档的内容和呈现方式。我们最为关心的是，DOM把网页和脚本以及其他的编程语言联系了起来。DOM属于浏览器，而不是JavaScript语言规范里的规定的核心内容。</p>
<p>注：一般说的JS让页面动起来泛指JavaScript和Dom</p>
<p>1、选择器</p>
<pre><code>document.getElementById(&apos;id&apos;);
document.getElementsByName(&apos;name&apos;);
document.getElementsByTagName(&apos;tagname&apos;);
</code></pre><p>2、内容</p>
<pre><code>innerText
innerHTML

var obj = document.getElementById(&apos;nid&apos;)
obj.innerText                       # 获取文本内容
obj.innerText = &quot;hello&quot;             # 设置文本内容
obj.innerHTML                       # 获取HTML内容
obj.innerHTML = &quot;&lt;h1&gt;asd&lt;/h1&gt;&quot;      # 设置HTML内容


特殊的：
    input系列
    textarea标签
    select标签

    value属性操作用户输入和选择的值
</code></pre><p>3、创建标签</p>
<pre><code>方式一：
    var obj = document.createElement(&apos;a&apos;);
    obj.href = &quot;http://www.apicloud.com&quot;;
    obj.innerText = &quot;APICloud&quot;;

    var container = document.getElementById(&apos;container&apos;);
    //container.appendChild(obj);
    //container.insertBefore(obj, container.firstChild);
    //container.insertBefore(obj, document.getElementById(&apos;hhh&apos;));

方式二：
    var container = document.getElementById(&apos;container&apos;);
    var obj = &quot;&lt;input  type=&apos;text&apos; /&gt;&quot;;
    container.innerHTML = obj;
    // &apos;beforeBegin&apos;, &apos;afterBegin&apos;, &apos;beforeEnd&apos;,  &apos;afterEnd&apos;
    //container.insertAdjacentHTML(&quot;beforeEnd&quot;,obj);
</code></pre><p>4、标签属性</p>
<pre><code>var obj = document.getElementById(&apos;container&apos;);
固定属性
    obj.id
    obj.id = &quot;nid&quot;
    obj.className
    obj.style.fontSize = &quot;88px&quot;;

自定义属性
    obj.setAttribute(name,value)
    obj.getAttribute(name)
    obj.removeAttribute(name)
</code></pre><p>5、提交表单</p>
<pre><code>document.geElementById(&apos;form&apos;).submit()
</code></pre><p>6、事件</p>
<p><img src="http://i.imgur.com/aP6MTMY.png" alt=""></p>
<p>7、其他功能</p>
<pre><code>console.log()
alert()
confirm()

// URL和刷新
location.href
location.href = &quot;url&quot;  window.location.reload()

// 定时器
setInterval(&quot;alert()&quot;,2000);   
clearInterval(obj)
setTimeout();   
clearTimeout(obj)
</code></pre><p>示例：</p>
<pre><code>跑马灯

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;欢迎南非波波同志成为本届董事长&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;input type=&quot;button&quot; onclick=&quot;DropInterval();&quot; value=&quot;停止滚动&quot; /&gt;
        &lt;script&gt;
            obj1 = setInterval(&quot;GunDong()&quot;,1000);
            console.log(obj1);
            function DropInterval(){
                   clearInterval(obj1);
            }
            function GunDong(){
                var text = document.title;
                var firstWord = text.charAt(0);
                var subWord = text.substring(1,text.length);
                var newWord = subWord + firstWord;
                document.title = newWord;
            }
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;

搜索框

&lt;input type=&quot;text&quot; placeholder=&quot;请输入关键字&quot; id=&quot;search&quot; onfocus=&quot;Focus();&quot; onblur=&quot;Blur();&quot;/&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    function Focus(){
        var nid = document.getElementById(&quot;search&quot;);
        var value = nid.placeholder;
        if (value == &quot;请输入关键字&quot;){
            nid.placeholder = &quot;&quot;;
        }
    }

    function Blur(){
        var nid = document.getElementById(&quot;search&quot;);
        var value = nid.placeholder;
        if (!value.trim()){
            nid.placeholder = &quot;请输入关键字&quot;;
        }
    }
&lt;/script&gt;
</code></pre><h2 id="三、jQuery"><a href="#三、jQuery" class="headerlink" title="三、jQuery"></a>三、jQuery</h2><p>1、选择器：</p>
<pre><code>#id
element
.class
*
selector1,selector2,selectorN
</code></pre><p><img src="http://i.imgur.com/fhuW9MD.png" alt=""></p>
<p>示例：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;Title&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div&gt;
           &lt;div id=&quot;n1&quot;&gt;11&lt;/div&gt;
            &lt;div class=&quot;c1&quot;&gt;22&lt;/div&gt;
            &lt;div  class=&quot;c1&quot;&gt;33&lt;/div&gt;
            &lt;a&gt;&lt;/a&gt;
            &lt;span id=&quot;n2&quot;&gt;&lt;/span&gt;

            &lt;div id=&quot;n3&quot;&gt;
                &lt;div&gt;
                    &lt;div class=&quot;c3&quot;&gt;
                        &lt;span&gt;
                            &lt;a class=&quot;c4&quot;&gt;asdf&lt;/a&gt;
                        &lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;span&gt;asdf&lt;/span&gt;
            &lt;/div&gt;

        &lt;/div&gt;

        &lt;script src=&quot;jquery-2.2.3.js&quot;&gt;&lt;/script&gt;
        &lt;script&gt;
            /*
            选择器基础使用
             */
            $(&quot;#n1&quot;).text(&quot;中国好声音&quot;);
            $(&quot;.c1&quot;).text(&quot;欢迎三江同学&quot;);
            $(&quot;.c4&quot;).text(&quot;一不小心挂掉了&quot;);
            $(&quot;#n3 span&quot;).text(&quot;游泳冠军&quot;);

        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>2、 筛选器</p>
<p><img src="http://i.imgur.com/x7Jqi96.jpg" alt=""></p>
<p>3、属性、CSS</p>
<p><img src="http://i.imgur.com/mPoLfMu.png" alt="">    </p>
<p>4、文档处理</p>
<p><img src="http://i.imgur.com/8YcX0EW.png" alt=""></p>
<p>5、事件</p>
<p><img src="http://i.imgur.com/p53Uf3n.png" alt=""></p>
<p><strong>作业</strong></p>
<ol>
<li>jQuery API文档阅读</li>
<li>博客实例阅读练习</li>
<li>列表处理、登录方式</li>
<li>主机管理列表可编辑</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/09/s12-20160409-day13/" data-id="ciq8usaf3000togj5r7aei22t" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python开发之路/">Python开发之路</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-s12-20160319-day10" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/19/s12-20160319-day10/" class="article-date">
  <time datetime="2016-03-19T07:30:00.000Z" itemprop="datePublished">2016-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/19/s12-20160319-day10/">pytho自动化开发 day10</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author:@南非波波</p>
<p>课程大纲：</p>
<p>day09</p>
<p><a href="http://www.cnblogs.com/alex3714/articles/5248247.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5248247.html</a></p>
<p>day10</p>
<p><a href="http://www.cnblogs.com/alex3714/articles/5286889.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5286889.html
</a></p>
<h3 id="一、回顾"><a href="#一、回顾" class="headerlink" title="一、回顾"></a>一、回顾</h3><ol>
<li><p>队列</p>
<ol>
<li>队列的作业就是实现多个线程之间数据安全的交互</li>
<li>队列类型：先进先出、后进先出、优先级</li>
<li>queue的数据必须按照顺序进行取出–&gt;处理–&gt;放回。主要作用就是不同进程之间数据的交换，manager可以进行多个进程之间的数据的共享，而且是数据安全的。</li>
<li>生产者-消费者模型：实现程序的松耦合</li>
</ol>
</li>
<li><p>gevent模块：对Greenlet模块的一次封装</p>
<ol>
<li>gevent里面的socket本身可以实现IO阻塞变成非阻塞</li>
<li>monkey.path_all()可以帮助我们实现阻塞变成非阻塞</li>
</ol>
</li>
<li><p>协程</p>
<ol>
<li>实现单个线程里面的并发</li>
<li>无需线程上下文切换的开销，无需原子操作锁定及同步的开销，方便切换控制流，高并发+高扩展性+低成本</li>
<li>无法利用多核资源，但是可以实现单个进程下面起一个线程，然后一个线程下面实现多个协程并发</li>
</ol>
</li>
<li><p>select</p>
<p> <img src="http://i.imgur.com/SpEkQHr.png" alt=""></p>
<ol>
<li><p>select 与poll的区别</p>
<pre><code>select有一个最大文件数的限制1024，文件扫描一个列表是非常低效的；poll没有这个限制
内核态到用户态的数据copy；Epoll直接调用C语言进行内核态的数据nat到用户态
</code></pre></li>
<li><p>select代码注释</p>
<p>  <strong>auther</strong> = ‘Victor’</p>
<p>  import select<br>  import socket<br>  import sys<br>  import queue</p>
<h1 id="创建一个TCP-IP-socket"><a href="#创建一个TCP-IP-socket" class="headerlink" title="创建一个TCP/IP socket"></a>创建一个TCP/IP socket</h1><p>  server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>  server.setblocking(False)</p>
<h1 id="绑定socket到指定端口"><a href="#绑定socket到指定端口" class="headerlink" title="绑定socket到指定端口"></a>绑定socket到指定端口</h1><p>  server_address = (‘localhost’, 10000)<br>  print(sys.stderr, ‘starting up on %s port %s’ % server_address)<br>  server.bind(server_address)</p>
<h1 id="监听连接的地址"><a href="#监听连接的地址" class="headerlink" title="监听连接的地址"></a>监听连接的地址</h1><p>  server.listen(5)<br>  inputs = [server]</p>
<h1 id="Socket的读操作"><a href="#Socket的读操作" class="headerlink" title="Socket的读操作"></a>Socket的读操作</h1><p>  outputs = []</p>
<h1 id="socket的写操作"><a href="#socket的写操作" class="headerlink" title="socket的写操作"></a>socket的写操作</h1><p>  message_queues = {}<br>  while inputs:</p>
<pre><code># Wait for at least one of the sockets to be ready for processing
print( &apos;\nwaiting for the next event&apos;)
readable, writable, exceptional = select.select(inputs, outputs, inputs)
# 监听句柄序列，如果某个发生变化，select的第一个rLest会拿到数据，output只要有数据wLest就能获取到，select的第三个参数inputs用来监测异常，并赋值给exceptional。
# 监听inputs，outputs，inputs  如果他们的值有变化，就将分别赋值给readable，writable，exceptional。
for s in readable:
    # 遍历readable的值。
    if s is server:
        connection, client_address = s.accept()
        # 如果s 是server，那么server socket将接收连接。
        print(&apos;new connection from&apos;, client_address)
        # 打印出连接客户端的地址。
        connection.setblocking(False)
        # 设置socket 为非阻塞模式。
        inputs.append(connection)
        # 因为有读操作发生，所以将此连接加入inputs
        message_queues[connection] = queue.Queue()
        # 为每个连接创建一个queue队列。使得每个连接接收到正确的数据。
    else:
        data = s.recv(1024)
        # 如果s不是server，说明客户端连接来了，那么就接受客户端的数据。
        if data:
            # 如果接收到客户端的数据
            print(sys.stderr, &apos;received &quot;%s&quot; from %s&apos; % (data, s.getpeername()) )
            message_queues[s].put(data)
            # 将收到的数据放入队列中
            if s not in outputs:
                outputs.append(s)
                # 将socket客户端的连接加入select的output中，并且用来返回给客户端数据。
        else:
            print(&apos;closing&apos;, client_address, &apos;after reading no data&apos;)
            # 如果没有收到客户端发来的空消息，则说明客户端已经断开连接。
            if s in outputs:
                outputs.remove(s)
                # 既然客户端都断开了，我就不用再给它返回数据了，所以这时候如果这个客户端的连接对象还在outputs列表中，就把它删掉
            inputs.remove(s)
            # inputs中也删除掉
            s.close()
            # 把这个连接关闭掉
            del message_queues[s]
            # 删除此客户端的消息队列

for s in writable:
    # 遍历output的数据
    try:
        next_msg = message_queues[s].get_nowait()
    except queue.Empty:
        # 获取对应客户端消息队列中的数据，如果队列中的数据为空，从消息队列中移除此客户端连接。
        print(&apos;output queue for&apos;, s.getpeername(), &apos;is empty&apos;)
        outputs.remove(s)
    else:
        print( &apos;sending &quot;%s&quot; to %s&apos; % (next_msg, s.getpeername()))
        s.send(next_msg)
        # 如果消息队列有数据，则发送给客户端。
for s in exceptional:
    # 处理 &quot;exceptional conditions&quot;
    print(&apos;handling exceptional condition for&apos;, s.getpeername() )
    inputs.remove(s)
    # 取消对出现异常的客户端的监听
    if s in outputs:
        outputs.remove(s)
        # 移除客户端的连接对象。
    s.close()
    # 关闭此socket连接
    del message_queues[s]
    # 删除此消息队列。
</code></pre><p>  ‘’’</p>
<p>  在select/poll时代，服务器进程每次都把这100万个连接告诉操作系统(从用户态复制句柄数据结构到内核态)，让操作系统内核去查询这些套接字上是否有事件发生，</p>
<p>  轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll一般只能处理几千的并发连接。</p>
<p>  epoll的设计和实现与select完全不同。epoll通过在Linux内核中申请一个简易的文件系统(文件系统一般用什么数据结构实现？B+树)。把原先的select/poll调用分成了3个部分：</p>
<p>  1）调用epoll_create()建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源)</p>
<p>  2）调用epoll_ctl向epoll对象中添加这100万个连接的套接字</p>
<p>  3）调用epoll_wait收集发生的事件的连接</p>
<p>  ‘’’</p>
</li>
<li><p>epoll代码注释</p>
<p>  <strong>auther</strong> = ‘Victor’</p>
</li>
</ol>
</li>
</ol>
<pre><code>#--------------这是一个epoll的例子--------------


import socket, select
# &apos;windows&apos;下不支持&apos;epoll&apos;

EOL1 = b&apos;\n\n&apos;
EOL2 = b&apos;\n\r\n&apos;
response = b&apos;HTTP/1.0 200 OK\r\nDate: Mon, 1 Jan 1996 01:01:01 GMT\r\n&apos;
response += b&apos;Content-Type: text/plain\r\nContent-Length: 13\r\n\r\n&apos;
response += b&apos;Hello, world!&apos;

serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
serversocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
serversocket.bind((&apos;0.0.0.0&apos;, 8080))
serversocket.listen(1)
# 建立socket连接。
serversocket.setblocking(0)
# 因为socket本身是阻塞的，setblocking（0）使得socket不阻塞

epoll = select.epoll()
# 创建一个eopll对象
epoll.register(serversocket.fileno(), select.EPOLLIN)
# 在服务器端socket上面注册对读event的关注，一个读event随时会触发服务器端socket去接收一个socket连接。

try:
   connections = {}; requests = {}; responses = {}
# 生成3个字典，connection字典是存储文件描述符映射到他们相应的网络连接对象
   while True:
      events = epoll.poll(1)
# 查询epoll对象，看是否有任何关注的event被触发，参数‘1’表示，会等待一秒来看是否有event发生，如果有任何感兴趣的event发生在这次查询之前，这个查询就会带着这些event的列表立即返回
      for fileno, event in events:
        # event作为一个序列（fileno，event code）的元组返回，fileno是文件描述符的代名词，始终是一个整数。
         if fileno == serversocket.fileno():
            # 如果一个读event在服务器端socket发生，就会有一个新的socket连接可能被创建。
            connection, address = serversocket.accept()
            # 服务器端开始接收连接和客户端地址
            connection.setblocking(0)
            # 设置新的socket为非阻塞模式
            epoll.register(connection.fileno(), select.EPOLLIN)
            # 为新的socket注册对读（EPOLLIN）event的关注
            connections[connection.fileno()] = connection
            requests[connection.fileno()] = b&apos;&apos;
            responses[connection.fileno()] = response
         elif event &amp; select.EPOLLIN:
            requests[fileno] += connections[fileno].recv(1024)
            # 如果发生一个读event，就读取从客户端发过来的数据。
            if EOL1 in requests[fileno] or EOL2 in requests[fileno]:
               epoll.modify(fileno, select.EPOLLOUT)
            # 一旦完成请求已经收到，就注销对读event的关注，注册对写（EPOLLOUT）event的关注，写event发生的时候，会回复数据给客户端。
               print(&apos;-&apos;*40 + &apos;\n&apos; + requests[fileno].decode()[:-2])
            # 打印完整的请求，证明虽然与客户端的通信是交错进行的，但是数据可以作为一个整体来组装和处理。
         elif event &amp; select.EPOLLOUT:
            # 如果一个写event在一个客户端socket上面发生，他会接受新的数据以便发送到客户端。
            byteswritten = connections[fileno].send(responses[fileno])
            responses[fileno] = responses[fileno][byteswritten:]
            if len(responses[fileno]) == 0:
                # 每次发送一部分响应数据，直到完整的响应数据都已经发送给操作系统等待传输给客户端。
               epoll.modify(fileno, 0)
            # 一旦完整的响应数据发送完成，就不再关注读或者写event。
               connections[fileno].shutdown(socket.SHUT_RDWR)
            # 如果一个连接显式关闭，那么socket shutdown是可选的，在这里这样使用，是为了让客户端首先关闭。
            # shutdown调用会通知客户端socket没有更多的数据应该被发送或者接收，并会让功能正常的客户端关闭自己的socket连接。
         elif event &amp; select.EPOLLHUP:
            # HUP挂起event表明客户端socket已经断开（即关闭），所以服务器端也需要关闭，没有必要注册对HUP event的关注，在socket上面，他们总是会被epoll对象注册。
            epoll.unregister(fileno)
            # 注销对此socket连接的关注。
            connections[fileno].close()
            # 关闭socket连接。
            del connections[fileno]
finally:
   epoll.unregister(serversocket.fileno())
# 去掉已经注册的文件句柄
   epoll.close()
# 关闭epoll对象
   serversocket.close()
# 关闭服务器连接
# 打开的socket连接不需要关闭，因为Python会在程序结束时关闭， 这里的显示关闭是个好的习惯。



&apos;&apos;&apos;

首先我们来定义流的概念，一个流可以是文件，socket，pipe等等可以进行I/O操作的内核对象。

    不管是文件，还是套接字，还是管道，我们都可以把他们看作流。

    之后我们来讨论I/O的操作，通过read，我们可以从流中读入数据；通过write，我们可以往流写入数据。现在假定一个情形，
    我们需要从流中读数据，但是流中还没有数据，（典型的例子为，客户端要从socket读如数据，但是服务器还没有把数据传回来），
    这时候该怎么办？

阻塞：阻塞是个什么概念呢？比如某个时候你在等快递，但是你不知道快递什么时候过来，而且你没有别的事可以干（或者说接下来的事要等快递来了才能做）；
那么你可以去睡觉了，因为你知道快递把货送来时一定会给你打个电话（假定一定能叫醒你）。

非阻塞忙轮询：接着上面等快递的例子，如果用忙轮询的方法，那么你需要知道快递员的手机号，然后每分钟给他挂个电话：“你到了没？”

    很明显一般人不会用第二种做法，不仅显很无脑，浪费话费不说，还占用了快递员大量的时间。

    大部分程序也不会用第二种做法，因为第一种方法经济而简单，经济是指消耗很少的CPU时间，如果线程睡眠了，就掉出了系统的调度队列，暂时不会去瓜分CPU宝贵的时间片了。

    为了了解阻塞是如何进行的，我们来讨论缓冲区，以及内核缓冲区，最终把I/O事件解释清楚。缓冲区的引入是为了减少频繁I/O操作而引起频繁的系统调用（你知道它很慢的），
    当你操作一个流时，更多的是以缓冲区为单位进行操作，这是相对于用户空间而言。对于内核来说，也需要缓冲区。

假设有一个管道，进程A为管道的写入方，Ｂ为管道的读出方。

假设一开始内核缓冲区是空的，B作为读出方，被阻塞着。然后首先A往管道写入，这时候内核缓冲区由空的状态变到非空状态，内核就会产生一个事件告诉Ｂ该醒来了，
这个事件姑且称之为“缓冲区非空”。

    但是“缓冲区非空”事件通知B后，B却还没有读出数据；且内核许诺了不能把写入管道中的数据丢掉这个时候，Ａ写入的数据会滞留在内核缓冲区中，如果内核也缓冲区满了，
    B仍未开始读数据，最终内核缓冲区会被填满，这个时候会产生一个I/O事件，告诉进程A，你该等等（阻塞）了，我们把这个事件定义为“缓冲区满”。

假设后来Ｂ终于开始读数据了，于是内核的缓冲区空了出来，这时候内核会告诉A，内核缓冲区有空位了，你可以从长眠中醒来了，继续写数据了，我们把这个事件叫做“缓冲区非满”

    也许事件Y1已经通知了A，但是A也没有数据写入了，而Ｂ继续读出数据，知道内核缓冲区空了。这个时候内核就告诉B，你需要阻塞了！，我们把这个时间定为“缓冲区空”。

这四个情形涵盖了四个I/O事件，缓冲区满，缓冲区空，缓冲区非空，缓冲区非满（注都是说的内核缓冲区，且这四个术语都是我生造的，仅为解释其原理而造）。
这四个I/O事件是进行阻塞同步的根本。（如果不能理解“同步”是什么概念，请学习操作系统的锁，信号量，条件变量等任务同步方面的相关知识）。

    然后我们来说说阻塞I/O的缺点。但是阻塞I/O模式下，一个线程只能处理一个流的I/O事件。如果想要同时处理多个流，要么多进程(fork)，要么多线程(pthread_create)，
    很不幸这两种方法效率都不高。

    于是再来考虑非阻塞忙轮询的I/O方式，我们发现我们可以同时处理多个流了（把一个流从阻塞模式切换到非阻塞模式再此不予讨论）：

while true {
    for i in stream[]; {
        if i has data
            read until unavailable
    }
}

    我们只要不停的把所有流从头到尾问一遍，又从头开始。这样就可以处理多个流了，但这样的做法显然不好，因为如果所有的流都没有数据，那么只会白白浪费CPU。
    这里要补充一点，阻塞模式下，内核对于I/O事件的处理是阻塞或者唤醒，而非阻塞模式下则把I/O事件交给其他对象（后文介绍的select以及epoll）处理甚至直接忽略。

    为了避免CPU空转，可以引进了一个代理（一开始有一位叫做select的代理，后来又有一位叫做poll的代理，不过两者的本质是一样的）。这个代理比较厉害，
    可以同时观察许多流的I/O事件，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流
    （于是我们可以把“忙”字去掉了）。代码长这样:

while true {
    select(streams[])
    for i in streams[] {
        if i has data
            read until unavailable
    }
}

    于是，如果没有I/O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知道了，有I/O事件发生了，但却并不知道是那几个流
    （可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。

    但是使用select，我们有O(n)的无差别轮询复杂度，同时处理的流越多，没一次无差别轮询时间就越长。再次

说了这么多，终于能好好解释epoll了

    epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll之会把哪个流发生了怎样的I/O事件通知我们。此时我们对这些流的操作都是有意义的。
    （复杂度降低到了O(1)）

    在讨论epoll的实现细节之前，先把epoll的相关操作列出：

      epoll_create 创建一个epoll对象，一般epollfd = epoll_create()

      epoll_ctl （epoll_add/epoll_del的合体），往epoll对象中增加/删除某一个流的某一个事件

比如

epoll_ctl(epollfd, EPOLL_CTL_ADD, socket, EPOLLIN);//注册缓冲区非空事件，即有数据流入

epoll_ctl(epollfd, EPOLL_CTL_DEL, socket, EPOLLOUT);//注册缓冲区非满事件，即流可以被写入

epoll_wait(epollfd,...)等待直到注册的事件发生

（注：当对一个非阻塞流的读写发生缓冲区满或缓冲区空，write/read会返回-1，并设置errno=EAGAIN。而epoll只关心缓冲区非满和缓冲区非空事件）。

一个epoll模式的代码大概的样子是：
while true {
    active_stream[] = epoll_wait(epollfd)
    for i in active_stream[] {
        read or write till
    }
}

&apos;&apos;&apos;
</code></pre><h3 id="二、Twsited异步网络框架"><a href="#二、Twsited异步网络框架" class="headerlink" title="二、Twsited异步网络框架"></a>二、Twsited异步网络框架</h3><ol>
<li><p>事件驱动</p>
<p>将自定义的类和函数注册到事件列表中，事件驱动框架就会自行去列表中获取事件并执行。</p>
<p>第一，注册事件；第二，触发事件<br><img src="http://i.imgur.com/6brDszu.png" alt=""></p>
</li>
</ol>
<p>示例代码：</p>
<pre><code>#event_drive.py
#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
&apos;&apos;&apos;
模拟twsited异步网络框架的流程
&apos;&apos;&apos;
#创建一个事件列表
event_list = []

#创建一个事件驱动动作
def run():
    for event in event_list:
        obj = event()
        obj.execute()

#创建事件定义规则，用户将自定义事件注册到事件列表中需要继承此类
class BaseHandler(object):
    &quot;&quot;&quot;
    用户必须继承该类，从而规范所有类的方法（类似于接口的功能）
    &quot;&quot;&quot;
    def execute(self):
        raise Exception(&apos;you must overwrite execute&apos;)

#event_run.py
#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
import event_drive

#自定义事件，继承事件驱动自定义类
class MyHandler(event_drive.BaseHandler):

    #重写执行函数
    def execute(self):
        print(&apos;event-drive execute MyHandler&apos;)
class YourHandler(event_drive.BaseHandler):

    def execute(self):
        print(&apos;event-drive ezecute YourHandler&apos;)

event_drive.event_list.append(MyHandler) #将事件注册到事件列表中
event_drive.event_list.append(YourHandler)
event_drive.run()    
</code></pre><ol>
<li>Twisted框架</li>
</ol>
<p>Echo_server</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
from twisted.internet import protocol
from twisted.internet import reactor

class Echo(protocol.Protocol):
    &apos;&apos;&apos;
    定义一个类，处理客户端传递的数据
    &apos;&apos;&apos;
    def dataReceived(self, data):
        &apos;&apos;&apos;
        一旦接收到客户端传递的数据就要调用该方法
        :param data: 客户端传递过来的数据，python3版本传递的数据需要转换成bytes
        :return: 返回的数据是将客户端传递过来的数据返回给客户端
        &apos;&apos;&apos;
        print(&quot;Client said:&quot;,data)
        self.transport.write(data)

def main():
    &apos;&apos;&apos;
    主函数，程序执行时直接从该函数调用事件类
    :return:
    &apos;&apos;&apos;
    factory = protocol.ServerFactory() #定义基础工厂类
    factory.protocol = Echo #相当于socketserver中的Handler方法，工厂协议直接引用自定义的Echo类

    reactor.listenTCP(5000,factory) #reactor自动重复去做一件事情。使用listenTCP监听端口
    reactor.run() #运行

if __name__ == &apos;__main__&apos;:
    main()
</code></pre><p>Echo_client:</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
from twisted.internet import reactor, protocol


# a client protocol

class EchoClient(protocol.Protocol):
    &apos;&apos;&apos;
    客户端Echo事件
    &apos;&apos;&apos;
    def connectionMade(self):
        &apos;&apos;&apos;
        连接建立执行该方法，客户端发送数据
        :return:
        &apos;&apos;&apos;
        self.transport.write(b&quot;hello alex!&quot;)

    def dataReceived(self, data):
        &apos;&apos;&apos;
        客户端接收服务端的数据
        :param data:
        :return:
        &apos;&apos;&apos;
        print(&quot;Server said:&quot;, data)
        self.transport.loseConnection()
    def connectionLost(self, reason):
        &apos;&apos;&apos;
        客户端接收完数据断开连接，主动执行该方法断开连接
        :param reason:
        :return:
        &apos;&apos;&apos;
        print(&quot;connection lost&quot;)

class EchoFactory(protocol.ClientFactory):
    &apos;&apos;&apos;
    自定义工厂类，继承prorocol.ClientFactory类
    &apos;&apos;&apos;
    protocol = EchoClient #hanld。自己重写了protocol类

    def clientConnectionFailed(self, connector, reason):
        print(&quot;Connection failed - goodbye!&quot;)
        reactor.stop()

    def clientConnectionLost(self, connector, reason):
        print(&quot;Connection lost - goodbye!&quot;)
        reactor.stop()


# this connects the protocol to a server running on port 8000
def main():
    f = EchoFactory()
    reactor.connectTCP(&quot;localhost&quot;, 5000, f)
    reactor.run()

# this only runs if the module was *not* imported
if __name__ == &apos;__main__&apos;:
    main()
</code></pre><ol>
<li>升入学习</li>
</ol>
<p><a href="http://blog.csdn.net/hanhuili/article/details/9389433" target="_blank" rel="external">http://blog.csdn.net/hanhuili/article/details/9389433</a> </p>
<p><a href="http://krondo.com/an-introduction-to-asynchronous-programming-and-twisted/" target="_blank" rel="external">http://krondo.com/an-introduction-to-asynchronous-programming-and-twisted/</a> </p>
<h3 id="三、非关系型数据库"><a href="#三、非关系型数据库" class="headerlink" title="三、非关系型数据库"></a>三、非关系型数据库</h3><ol>
<li><p>Redis</p>
<p>参考：<a href="http://www.cnblogs.com/wupeiqi/articles/5132791.html" target="_blank" rel="external">http://www.cnblogs.com/wupeiqi/articles/5132791.html</a></p>
<p>数据（键值对）存储在内存中，一个独立的内存管理器，可以使多个程序共享数据    </p>
<p>默认是非持久化的，但是可以在配置文件中进行设置</p>
<ol>
<li><p>redis基础使用</p>
<p>   cli&gt;keys * #查看所有的键<br>   cli&gt;set name swht ex 5 #设置一个键值对，其有效时间为5秒<br>   cli&gt;get name #获取键值</p>
</li>
<li><p>redis连接</p>
<p>   import redis<br>   redis_cli = redis.Redis(“localhost”)<br>   print(redis_cli.get(‘name’)) #b’swht’  get方法只能获取字符</p>
</li>
<li><p>redis连接池</p>
<p>   import redis<br>   pool = redis.ConnectionPool(host = ‘localhost’,port = 6379)<br>   redis_cli = redis.Redis(connection_pool=pool)<br>   redis_cli.set(‘age’,56)<br>   print(redis_cli.get(‘age’)) #b’56’</p>
</li>
<li><p>操作</p>
<p>set(name, value, ex=None, px=None, nx=False, xx=False)</p>
<p>   在Redis中设置值，默认，不存在则创建，存在则修改<br>   参数：</p>
<pre><code>ex，过期时间（秒）
px，过期时间（毫秒）
nx，如果设置为True，则只有name不存在时，当前set操作才执行
xx，如果设置为True，则只有name存在时，岗前set操作才执行
</code></pre><p>setnx(name, value)</p>
<p>   设置值，只有name不存在时，执行设置操作（添加）<br>setex(name, value, time)</p>
<h1 id="设置值"><a href="#设置值" class="headerlink" title="设置值"></a>设置值</h1><h1 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h1><pre><code># time，过期时间（数字秒 或 timedelta对象）
</code></pre><p>psetex(name, time_ms, value)</p>
<h1 id="设置值-1"><a href="#设置值-1" class="headerlink" title="设置值"></a>设置值</h1><h1 id="参数：-1"><a href="#参数：-1" class="headerlink" title="参数："></a>参数：</h1><pre><code># time_ms，过期时间（数字毫秒 或 timedelta对象）
</code></pre><p>mset(<em>args, *</em>kwargs)</p>
<p>   批量设置值<br>   如：</p>
<pre><code>mset(k1=&apos;v1&apos;, k2=&apos;v2&apos;)
或
mget({&apos;k1&apos;: &apos;v1&apos;, &apos;k2&apos;: &apos;v2&apos;})
</code></pre><p>get(name)</p>
<p>   获取值<br>mget(keys, *args)</p>
<p>   批量获取<br>   如：</p>
<pre><code>mget(&apos;ylr&apos;, &apos;wupeiqi&apos;)
或
r.mget([&apos;ylr&apos;, &apos;wupeiqi&apos;])
</code></pre><p>getset(name, value)</p>
<p>   设置新值并获取原来的值<br>getrange(key, start, end)</p>
</li>
</ol>
</li>
</ol>
<pre><code>        # 获取子序列（根据字节获取，非字符）
        # 参数：
            # name，Redis 的 name
            # start，起始位置（字节）
            # end，结束位置（字节）
        # 如： &quot;武沛齐&quot; ，0-3表示 &quot;武&quot;
    setrange(name, offset, value)

        # 修改字符串内容，从指定字符串索引开始向后替换（新值太长时，则向后添加）
        # 参数：
            # offset，字符串的索引，字节（一个汉字三个字节）
            # value，要设置的值
    setbit(name, offset, value)    
        # 对name对应值的二进制表示的位进行操作

        # 参数：
            # name，redis的name
            # offset，位的索引（将值变换成二进制后再进行索引）
            # value，值只能是 1 或 0

        # 注：如果在Redis中有一个对应： n1 = &quot;foo&quot;，
                那么字符串foo的二进制表示为：01100110 01101111 01101111
            所以，如果执行 setbit(&apos;n1&apos;, 7, 1)，则就会将第7位设置为1，
                那么最终二进制则变成 01100111 01101111 01101111，即：&quot;goo&quot;

        # 扩展，转换二进制表示：

            # source = &quot;武沛齐&quot;
            source = &quot;foo&quot;

            for i in source:
                num = ord(i)
                print bin(num).replace(&apos;b&apos;,&apos;&apos;)

            特别的，如果source是汉字 &quot;武沛齐&quot;怎么办？
            答：对于utf-8，每一个汉字占 3 个字节，那么 &quot;武沛齐&quot; 则有 9个字节
               对于汉字，for循环时候会按照 字节 迭代，那么在迭代时，将每一个字节转换 十进制数，然后再将十进制数转换成二进制    
    假定统计UV，使用setbit可以进行相应UV数统计。

        #!/usr/local/env python3
        &apos;&apos;&apos;
        Author:@南非波波
        Blog:http://www.cnblogs.com/songqingbo/
        E-mail:qingbo.song@gmail.com
        &apos;&apos;&apos;
        import redis

        pool = redis.ConnectionPool(host = &apos;localhost&apos;,port = 6379)
        redis_cli = redis.Redis(connection_pool=pool)
        redis_cli.setbit(&apos;ip&apos;,5,1)
        redis_cli.setbit(&apos;ip&apos;,45,1)
        redis_cli.setbit(&apos;ip&apos;,15,1)
        redis_cli.setbit(&apos;ip&apos;,45,1)
        print(&quot;uv_count:&quot;,redis_cli.bitcount(&apos;ip&apos;))    
    getbit(name, offset)


        # 获取name对应的值的二进制表示中的某位的值 （0或1）
        bitcount(key, start=None, end=None)

        # 获取name对应的值的二进制表示中 1 的个数
        # 参数：
            # key，Redis的name
            # start，位起始位置
            # end，位结束位置
    bitop(operation, dest, *keys)

        # 获取多个值，并将值做位运算，将最后的结果保存至新的name对应的值

        # 参数：
            # operation,AND（并） 、 OR（或） 、 NOT（非） 、 XOR（异或）
            # dest, 新的Redis的name
            # *keys,要查找的Redis的name

        # 如：
            bitop(&quot;AND&quot;, &apos;new_name&apos;, &apos;n1&apos;, &apos;n2&apos;, &apos;n3&apos;)
            # 获取Redis中n1,n2,n3对应的值，然后讲所有的值做位运算（求并集），然后将结果保存 new_name 对应的值中
    strlen(name)

        # 返回name对应值的字节长度（一个汉字3个字节）
    incr(self, name, amount=1)

        做pv统计比较有用
        # 自增 name对应的值，当name不存在时，则创建name＝amount，否则，则自增。

        # 参数：
            # name,Redis的name
            # amount,自增数（必须是整数）

        # 注：同incrby
    incrbyfloat(self, name, amount=1.0)

        # 自增 name对应的值，当name不存在时，则创建name＝amount，否则，则自增。

        # 参数：
            # name,Redis的name
            # amount,自增数（浮点型）
    decr(self, name, amount=1)

        # 自减 name对应的值，当name不存在时，则创建name＝amount，否则，则自减。

        # 参数：
            # name,Redis的name
            # amount,自减数（整数）
    append(key, value)

        # 在redis name对应的值后面追加内容

        # 参数：
            key, redis的name
            value, 要追加的字符串        

5. Hash操作

    hset(name, key, value)

        # name对应的hash中设置一个键值对（不存在，则创建；否则，修改）

        # 参数：
            # name，redis的name
            # key，name对应的hash中的key
            # value，name对应的hash中的value

        # 注：
            # hsetnx(name, key, value),当name对应的hash中不存在当前key时则创建（相当于添加）
    hmset(name, mapping)

        # 在name对应的hash中批量设置键值对

        # 参数：
            # name，redis的name
            # mapping，字典，如：{&apos;k1&apos;:&apos;v1&apos;, &apos;k2&apos;: &apos;v2&apos;}

        # 如：
            # r.hmset(&apos;xx&apos;, {&apos;k1&apos;:&apos;v1&apos;, &apos;k2&apos;: &apos;v2&apos;})
    hget(name,key)

        # 在name对应的hash中获取根据key获取value
        hmget(name, keys, *args)

        # 在name对应的hash中获取多个key的值

        # 参数：
            # name，reids对应的name
            # keys，要获取key集合，如：[&apos;k1&apos;, &apos;k2&apos;, &apos;k3&apos;]
            # *args，要获取的key，如：k1,k2,k3

        # 如：
            # r.mget(&apos;xx&apos;, [&apos;k1&apos;, &apos;k2&apos;])
            # 或
            # print r.hmget(&apos;xx&apos;, &apos;k1&apos;, &apos;k2&apos;)
    hgetall(name)

        获取name对应hash的所有键值
    hlen(name)

        # 获取name对应的hash中键值对的个数
    hkeys(name)

        # 获取name对应的hash中所有的key的值
    hvals(name)

        # 获取name对应的hash中所有的value的值
    hexists(name, key)

        # 检查name对应的hash是否存在当前传入的key
    hdel(name,*keys)

        # 将name对应的hash中指定key的键值对删除
    hincrby(name, key, amount=1)

        # 自增name对应的hash中的指定key的值，不存在则创建key=amount
        # 参数：
            # name，redis中的name
            # key， hash对应的key
            # amount，自增数（整数）
    hincrbyfloat(name, key, amount=1.0)

        # 自增name对应的hash中的指定key的值，不存在则创建key=amount

        # 参数：
            # name，redis中的name
            # key， hash对应的key
            # amount，自增数（浮点数）

        # 自增name对应的hash中的指定key的值，不存在则创建key=amount
    hscan(name, cursor=0, match=None, count=None)

        # 增量式迭代获取，对于数据大的数据非常有用，hscan可以实现分片的获取数据，并非一次性将数据全部获取完，从而放置内存被撑爆

        # 参数：
            # name，redis的name
            # cursor，游标（基于游标分批取获取数据）
            # match，匹配指定key，默认None 表示所有的key
            # count，每次分片最少获取个数，默认None表示采用Redis的默认分片个数

        # 如：
            # 第一次：cursor1, data1 = r.hscan(&apos;xx&apos;, cursor=0, match=None, count=None)
            # 第二次：cursor2, data1 = r.hscan(&apos;xx&apos;, cursor=cursor1, match=None, count=None)
            # ...
            # 直到返回值cursor的值为0时，表示数据已经通过分片获取完毕
    hscan_iter(name, match=None, count=None)

        # 利用yield封装hscan创建生成器，实现分批去redis中获取数据

        # 参数：
            # match，匹配指定key，默认None 表示所有的key
            # count，每次分片最少获取个数，默认None表示采用Redis的默认分片个数

        # 如：
            # for item in r.hscan_iter(&apos;xx&apos;):
            #     print item
6. List操作

    lpush(name,values)

        # 在name对应的list中添加元素，每个新的元素都添加到列表的最左边

        # 如：
            # r.lpush(&apos;oo&apos;, 11,22,33)
            # 保存顺序为: 33,22,11

        # 扩展：
            # rpush(name, values) 表示从右向左操作
    lpushx(name,value)

        # 在name对应的list中添加元素，只有name已经存在时，值添加到列表的最左边

        # 更多：
            # rpushx(name, value) 表示从右向左操作
    llen(name)

        # name对应的list元素的个数
    linsert(name, where, refvalue, value))

        # 在name对应的列表的某一个值前或后插入一个新值

        # 参数：
            # name，redis的name
            # where，BEFORE或AFTER
            # refvalue，标杆值，即：在它前后插入数据
            # value，要插入的数据
    r.lset(name, index, value)

        # 对name对应的list中的某一个索引位置重新赋值

        # 参数：
            # name，redis的name
            # index，list的索引位置
            # value，要设置的值
    r.lrem(name, value, num)

        # 在name对应的list中删除指定的值

        # 参数：
            # name，redis的name
            # value，要删除的值
            # num，  num=0，删除列表中所有的指定值；
                   # num=2,从前到后，删除2个；
                   # num=-2,从后向前，删除2个
    lpop(name)

        # 在name对应的列表的左侧获取第一个元素并在列表中移除，返回值则是第一个元素

        # 更多：
            # rpop(name) 表示从右向左操作
    lindex(name, index)

        在name对应的列表中根据索引获取列表元素
    lrange(name, start, end)

        # 在name对应的列表分片获取数据
        # 参数：
            # name，redis的name
            # start，索引的起始位置
            # end，索引结束位置
    ltrim(name, start, end)

        # 在name对应的列表中移除没有在start-end索引之间的值
        # 参数：
            # name，redis的name
            # start，索引的起始位置
            # end，索引结束位置
    rpoplpush(src, dst)

        # 从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边
        # 参数：
            # src，要取数据的列表的name
            # dst，要添加数据的列表的name
    blpop(keys, timeout)

        # 将多个列表排列，按照从左到右去pop对应列表的元素

        # 参数：
            # keys，redis的name的集合
            # timeout，超时时间，当元素所有列表的元素获取完之后，阻塞等待列表内有数据的时间（秒）, 0 表示永远阻塞

        # 更多：
            # r.brpop(keys, timeout)，从右向左获取数据
    brpoplpush(src, dst, timeout=0)

        # 从一个列表的右侧移除一个元素并将其添加到另一个列表的左侧

        # 参数：
            # src，取出并要移除元素的列表对应的name
            # dst，要插入元素的列表对应的name
            # timeout，当src对应的列表中没有数据时，阻塞等待其有数据的超时时间（秒），0 表示永远阻塞
    自定义增量迭代

        # 由于redis类库中没有提供对列表元素的增量迭代，如果想要循环name对应的列表的所有元素，那么就需要：
            # 1、获取name对应的所有列表
            # 2、循环列表
        # 但是，如果列表非常大，那么就有可能在第一步时就将程序的内容撑爆，所有有必要自定义一个增量迭代的功能：

        def list_iter(name):
            &quot;&quot;&quot;
            自定义redis列表增量迭代
            :param name: redis中的name，即：迭代name对应的列表
            :return: yield 返回 列表元素
            &quot;&quot;&quot;
            list_count = r.llen(name)
            for index in xrange(list_count):
                yield r.lindex(name, index)

        # 使用
        for item in list_iter(&apos;pp&apos;):
            print item
7. Set操作，Set集合就是不允许重复的列表

    sadd(name,values)

        # name对应的集合中添加元素
    scard(name)

        获取name对应的集合中元素个数
    sdiff(keys, *args)

        在第一个name对应的集合中且不在其他name对应的集合的元素集合
    sdiffstore(dest, keys, *args)

        # 获取第一个name对应的集合中且不在其他name对应的集合，再将其新加入到dest对应的集合中
    sinter(keys, *args)

        # 获取多一个name对应集合的并集
    sinterstore(dest, keys, *args)

        # 获取多一个name对应集合的并集，再讲其加入到dest对应的集合中
    sismember(name, value)

        # 检查value是否是name对应的集合的成员
    smembers(name)

        # 获取name对应的集合的所有成员
    smove(src, dst, value)

        # 将某个成员从一个集合中移动到另外一个集合
    spop(name)

        # 从集合的右侧（尾部）移除一个成员，并将其返回
    srandmember(name, numbers)

        # 从name对应的集合中随机获取 numbers 个元素
    srem(name, values)

        # 在name对应的集合中删除某些值
    sunion(keys, *args)

        # 获取多一个name对应的集合的并集
    sunionstore(dest,keys, *args)

        # 获取多一个name对应的集合的并集，并将结果保存到dest对应的集合中
    sscan(name, cursor=0, match=None, count=None)
    sscan_iter(name, match=None, count=None)

        # 同字符串的操作，用于增量迭代分批获取元素，避免内存消耗太大


8. 有序集合，在集合的基础上，为每元素排序；元素的排序需要根据另外一个值来进行比较，所以，对于有序集合，每一个元素有两个值，即：值和分数，分数专门用来做排序。

    zadd(name, *args, **kwargs)

        # 在name对应的有序集合中添加元素
        # 如：
             # zadd(&apos;zz&apos;, &apos;n1&apos;, 1, &apos;n2&apos;, 2)
             # 或
             # zadd(&apos;zz&apos;, n1=11, n2=22)
    zcard(name)

        # 获取name对应的有序集合元素的数量
    zcount(name, min, max)

        # 获取name对应的有序集合中分数 在 [min,max] 之间的个数
    zincrby(name, value, amount)

        # 自增name对应的有序集合的 name 对应的分数
    r.zrange( name, start, end, desc=False, withscores=False, score_cast_func=float)

        # 按照索引范围获取name对应的有序集合的元素

        # 参数：
            # name，redis的name
            # start，有序集合索引起始位置（非分数）
            # end，有序集合索引结束位置（非分数）
            # desc，排序规则，默认按照分数从小到大排序
            # withscores，是否获取元素的分数，默认只获取元素的值
            # score_cast_func，对分数进行数据转换的函数

        # 更多：
            # 从大到小排序
            # zrevrange(name, start, end, withscores=False, score_cast_func=float)

            # 按照分数范围获取name对应的有序集合的元素
            # zrangebyscore(name, min, max, start=None, num=None, withscores=False, score_cast_func=float)
            # 从大到小排序
            # zrevrangebyscore(name, max, min, start=None, num=None, withscores=False, score_cast_func=float)
    zrank(name, value)

        # 获取某个值在 name对应的有序集合中的排行（从 0 开始）

        # 更多：
            # zrevrank(name, value)，从大到小排序
    zrangebylex(name, min, max, start=None, num=None)

        # 当有序集合的所有成员都具有相同的分值时，有序集合的元素会根据成员的 值 （lexicographical ordering）来进行排序，而这个命令则可以返回给定的有序集合键 key 中， 元素的值介于 min 和 max 之间的成员
        # 对集合中的每个成员进行逐个字节的对比（byte-by-byte compare）， 并按照从低到高的顺序， 返回排序后的集合成员。 如果两个字符串有一部分内容是相同的话， 那么命令会认为较长的字符串比较短的字符串要大

        # 参数：
            # name，redis的name
            # min，左区间（值）。 + 表示正无限； - 表示负无限； ( 表示开区间； [ 则表示闭区间
            # min，右区间（值）
            # start，对结果进行分片处理，索引位置
            # num，对结果进行分片处理，索引后面的num个元素

        # 如：
            # ZADD myzset 0 aa 0 ba 0 ca 0 da 0 ea 0 fa 0 ga
            # r.zrangebylex(&apos;myzset&apos;, &quot;-&quot;, &quot;[ca&quot;) 结果为：[&apos;aa&apos;, &apos;ba&apos;, &apos;ca&apos;]

        # 更多：
            # 从大到小排序
            # zrevrangebylex(name, max, min, start=None, num=None)
    zrem(name, values)

        # 删除name对应的有序集合中值是values的成员

        # 如：zrem(&apos;zz&apos;, [&apos;s1&apos;, &apos;s2&apos;])
    zremrangebyrank(name, min, max)

        # 根据排行范围删除
    zremrangebyscore(name, min, max)

        # 根据分数范围删除
    zremrangebylex(name, min, max)

        # 根据值返回删除
    zscore(name, value)

        # 获取name对应有序集合中 value 对应的分数
    zinterstore(dest, keys, aggregate=None)

        # 获取两个有序集合的交集，如果遇到相同值不同分数，则按照aggregate进行操作
        # aggregate的值为:  SUM  MIN  MAX
    zunionstore(dest, keys, aggregate=None)

        # 获取两个有序集合的并集，如果遇到相同值不同分数，则按照aggregate进行操作
        # aggregate的值为:  SUM  MIN  MAX
    zscan(name, cursor=0, match=None, count=None, score_cast_func=float)
    zscan_iter(name, match=None, count=None,score_cast_func=float)

        # 同字符串相似，相较于字符串新增score_cast_func，用来对分数进行操作
</code></pre><p>　　9. redis的发布与订阅</p>
<pre><code>基础类：

    #!/usr/local/env python3
    &apos;&apos;&apos;
    Author:@南非波波
    Blog:http://www.cnblogs.com/songqingbo/
    E-mail:qingbo.song@gmail.com
    &apos;&apos;&apos;
    import redis


    class RedisHelper:

        def __init__(self):
            self.__conn = redis.Redis(host=&apos;localhost&apos;,port=6379)
            self.chan_sub = &apos;fm104.5&apos;
            self.chan_pub = &apos;fm104.5&apos;

        def public(self, msg):
            self.__conn.publish(self.chan_pub, msg)
            return True

        def subscribe(self):
            pub = self.__conn.pubsub()
            pub.subscribe(self.chan_sub)
            pub.parse_response()
            return pub

redis_sub.py

    #!/usr/local/env python3
    &apos;&apos;&apos;
    Author:@南非波波
    Blog:http://www.cnblogs.com/songqingbo/
    E-mail:qingbo.song@gmail.com
    &apos;&apos;&apos;
    from RedisHelper import RedisHelper

    obj = RedisHelper()
    redis_sub = obj.subscribe()

    while True:
        msg= redis_sub.parse_response()
        print(msg)

redis_pub.py

    #!/usr/local/env python3
    &apos;&apos;&apos;
    Author:@南非波波
    Blog:http://www.cnblogs.com/songqingbo/
    E-mail:qingbo.song@gmail.com
    &apos;&apos;&apos;
    from RedisHelper import RedisHelper

    obj = RedisHelper()
    obj.public(&apos;hello&apos;)
</code></pre><ol>
<li><p>memcached</p>
<p>非持久化轻量级缓存，使用第三方工具可以实现数据的持久化存储</p>
</li>
<li><p>mongodb</p>
<p>天生的数据持久化，默认将数据持久化存储在本地磁盘。</p>
</li>
</ol>
<h3 id="四、消息队列rabbitmq"><a href="#四、消息队列rabbitmq" class="headerlink" title="四、消息队列rabbitmq"></a>四、消息队列rabbitmq</h3><p>通信模式：</p>
<ol>
<li><p>简单生产者消费者模型</p>
<p> rabbit_send</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
import pika
#与消息队列建立一个连接
connection = pika.BlockingConnection(pika.ConnectionParameters(
               &apos;localhost&apos;))
#创建一个管道
channel = connection.channel()

#在管道中声明一个名称为&apos;name&apos;的队列
channel.queue_declare(queue=&apos;name&apos;)

#一个消息不能直接发送给消息队列，需要通过一个路由器进行转发，这个路由器就是由exchange进行设置
channel.basic_publish(exchange=&apos;&apos;, #路由器
                      routing_key=&apos;name&apos;, #队列名称
                      body=&apos;swht&apos;) #消息
print(&quot; [swht] Sent a message&quot;)
connection.close()
</code></pre><p> rabbit_recive</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
import pika

#与消息队列服务器建立连接
connection = pika.BlockingConnection(pika.ConnectionParameters(
               &apos;localhost&apos;))
#创建一个管道
channel = connection.channel()
#消费者声明一个队列，为了防止生产者还没有启动没有完成创建队列时代码出错的问题。如果队列已存在，则忽略该操作，否则则创建队列
channel.queue_declare(queue=&apos;name&apos;)

def callback(ch, method, properties, body):
    print(&quot; [x] Received %r&quot; % body)

channel.basic_consume(callback,
                      queue=&apos;name&apos;,
                      no_ack=True) #接收消息不进行确认

print(&apos; [*] Waiting for messages. To exit press CTRL+C&apos;)
channel.start_consuming()
</code></pre></li>
<li><p>消息持久化</p>
<pre><code>channel.queue_declare(queue=&apos;name&apos;,durable=True)
</code></pre><p> 已经存在的队列是不能再进行持久化设置的，所以在只有创建队列的时候设置持久化选项</p>
<pre><code>basc_ack = (delivery_tag= method.delivry_tag)
</code></pre><p> 查看当前所有的queue  XX</p>
</li>
<li><p>消息公平分发</p>
<p> <img src="http://i.imgur.com/qBwPkju.png" alt=""></p>
<p> 只在消费者添加<br> channel.basic_qos(prefetch_count=1)</p>
<p> 示例代码：</p>
<pre><code>rabbit_slb_send.py
    #!/usr/local/env python3
    &apos;&apos;&apos;
    Author:@南非波波
    Blog:http://www.cnblogs.com/songqingbo/
    E-mail:qingbo.song@gmail.com
    &apos;&apos;&apos;
    import pika

    connection = pika.BlockingConnection(pika.ConnectionParameters(
                   &apos;192.168.137.6&apos;))
    channel = connection.channel()

    #声明queue
    channel.queue_declare(queue=&apos;task_queue&apos;)

    #n RabbitMQ a message can never be sent directly to the queue, it always needs to go through an exchange.
    import sys

    message = &apos; &apos;.join(sys.argv[1:]) or &quot;Hello World!&quot;
    channel.basic_publish(exchange=&apos;&apos;,
                          routing_key=&apos;task_queue&apos;,
                          body=message,
                          properties=pika.BasicProperties(
                          delivery_mode = 2, # make message persistent
                          ))
    print(&quot; [x] Sent %r&quot; % message)
    connection.close()
</code></pre></li>
</ol>
<ol>
<li><p>exchange路由</p>
<p> <img src="http://i.imgur.com/MFX1LTo.png" alt=""></p>
<p> 代码：</p>
<pre><code>publisher.py

    #!/usr/local/env python3
    &apos;&apos;&apos;
    Author:@南非波波
    Blog:http://www.cnblogs.com/songqingbo/
    E-mail:qingbo.song@gmail.com
    &apos;&apos;&apos;
    import pika
    import sys

    connection = pika.BlockingConnection(pika.ConnectionParameters(
            host=&apos;localhost&apos;))
    channel = connection.channel()

    channel.exchange_declare(exchange=&apos;logs&apos;,
                             type=&apos;fanout&apos;)

    message = &apos; &apos;.join(sys.argv[1:]) or &quot;info: Hello World!&quot;
    channel.basic_publish(exchange=&apos;logs&apos;,
                          routing_key=&apos;&apos;,
                          body=message)
    print(&quot; [x] Sent %r&quot; % message)
    connection.close()

subscriber.py

    import pika

    connection = pika.BlockingConnection(pika.ConnectionParameters(
            host=&apos;localhost&apos;))
    channel = connection.channel()

    channel.exchange_declare(exchange=&apos;logs&apos;,
                             type=&apos;fanout&apos;)

    result = channel.queue_declare(exclusive=True) #不指定queue名字,rabbit会随机分配一个名字,exclusive=True会在使用此queue的消费者断开后,自动将queue删除
    queue_name = result.method.queue

    channel.queue_bind(exchange=&apos;logs&apos;,
                       queue=queue_name)

    print(&apos; [*] Waiting for logs. To exit press CTRL+C&apos;)

    def callback(ch, method, properties, body):
        print(&quot; [x] %r&quot; % body)

    channel.basic_consume(callback,
                          queue=queue_name,
                          no_ack=True)

    channel.start_consuming()
</code></pre></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/19/s12-20160319-day10/" data-id="ciq8usaej000fogj5inkbr91a" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python开发之路/">Python开发之路</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-s12-20160312-day09" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/12/s12-20160312-day09/" class="article-date">
  <time datetime="2016-03-12T07:30:00.000Z" itemprop="datePublished">2016-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/12/s12-20160312-day09/">pytho自动化开发 day09</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author:@南非波波</p>
<p>课程大纲：</p>
<p>day08</p>
<p><a href="http://www.cnblogs.com/alex3714/articles/5227251.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5227251.html</a></p>
<p>day09</p>
<p><a href="http://www.cnblogs.com/alex3714/articles/5248247.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5248247.html</a></p>
<p>###推荐电影###</p>
<pre><code>&lt;权利的游戏:冰与火之歌&gt;  &lt;纸牌屋&gt; &lt;绝命毒师&gt;
《林大看美国》
</code></pre><h3 id="一、回顾进程、线程"><a href="#一、回顾进程、线程" class="headerlink" title="一、回顾进程、线程"></a>一、回顾进程、线程</h3><pre><code>python调用C的原生线程
GIL(全局解释器)防止数据被修改异常。使用线程锁控制同时仅有一个线程对数据有操作权限
全局解释器限制的是原生C线程，
python同一时刻只有一个线程
python会处理不同cpu核之间的进程切换
父进程与子进程之间默认不能共享数据
</code></pre><p>获取线程的数据</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
import time,threading

data = [] #列表是一个安全的内存空间，可以不用加线程锁
def run(n):
    &apos;&apos;&apos;
    定义一个run方法，返回的n的n次方
    :param n:
    :return:
    &apos;&apos;&apos;
    data.append(n**n)
    return n**n
#创建一个多线程
t = threading.Thread(target=run,args=[8,])
t.start()
t.join() #起阻塞作用，让主进程等待线程执行完再执行主进程  默认无限期的等待，添加一个超时时间timeout=3.在守护线程下面是不好使的
print(data)
</code></pre><h3 id="二、-队列"><a href="#二、-队列" class="headerlink" title="二、 队列"></a>二、 队列</h3><ol>
<li><p>先进先出</p>
<p>  python队列queue默认的是先进先出。<br>  import queue<br>  Queue = queue.Queue(maxsize=5)<br>  Queue.put((2,[“swht”,”shen”]))<br>  Queue.put((5,{“name”:”swht”}))<br>  Queue.put((1,”sdsd”),timeout=2)<br>  for i in range(Queue._qsize()):</p>
<pre><code>print(&quot;data%s:%s&quot; % (i,Queue.get()))
</code></pre><p>  返回结果：<br>  data0:(2, [‘swht’, ‘shen’])<br>  data1:(5, {‘name’: ‘swht’})<br>  data2:(1, ‘sdsd’)    </p>
</li>
<li><p>后进先出</p>
<p>  python队列支持后面进去的消息最先被取出。</p>
<pre><code>python队列queue默认的是先进先出。
</code></pre><p>  import queue<br>  Queue = queue.LifoQueue(maxsize=5)<br>  Queue.put((2,[“swht”,”shen”]))<br>  Queue.put((5,{“name”:”swht”}))<br>  Queue.put((1,”sdsd”),timeout=2)<br>  for i in range(Queue._qsize()):</p>
<pre><code>print(&quot;data%s:%s&quot; % (i,Queue.get()))
</code></pre><p>  返回结果：<br>  data0:(1, ‘sdsd’)<br>  data1:(5, {‘name’: ‘swht’})<br>  data2:(2, [‘swht’, ‘shen’])</p>
</li>
<li><p>按照优先级</p>
<p>  python queue支持设置优先级，取消息可以安装优先级顺序取出消息<br>  import queue<br>  Queue = queue.PriorityQueue(maxsize=5)<br>  Queue.put((2,[“swht”,”shen”]))<br>  Queue.put((5,{“name”:”swht”}))<br>  Queue.put((1,”sdsd”),timeout=2)<br>  for i in range(Queue._qsize()):</p>
<pre><code>print(&quot;data%s:%s&quot; % (i,Queue.get()))
</code></pre><p>  返回结果：<br>  data0:(1, ‘sdsd’)<br>  data1:(2, [‘swht’, ‘shen’])<br>  data2:(5, {‘name’: ‘swht’})</p>
</li>
</ol>
<p>生产者-消费者模型：</p>
<ol>
<li><p>一对一：</p>
<p>  import threading,queue,time<br>  def consumer(n):</p>
<pre><code>&apos;&apos;&apos;
消费者，消费生产者产生的消息、数据
:param n: 消费者标志
:return:
&apos;&apos;&apos;
while True:
    print(&quot;\033[32;1m消费者[%s]\033[0m 获取消息 %s&quot; % (n,q.get()))
    time.sleep(1)
    q.task_done() #消费者等待生产者生产消息
</code></pre><p>  def prodeucer(n):</p>
<pre><code>&apos;&apos;&apos;
生产者，生产消息、数据
:param n: 生产者标志
:return:
&apos;&apos;&apos;
count = 1
while True:
    print(&quot;\033[31;1m生产者[%s]\033[0m 生产消息 %s&quot; % (n,count))
    q.put(count)
    count += 1
    q.join() #生产者阻塞
    print(&quot;==================&quot;) #发出信号：消息已经生产
</code></pre><p>  q = queue.Queue()<br>  c1 = threading.Thread(target=consumer,args=[1,])</p>
<p>  p1 = threading.Thread(target=prodeucer,args=[“swht”,])</p>
<p>  c1.start()<br>  p1.start()</p>
<p>  结果：</p>
<p>  生产者[swht] 生产消息 1</p>
<h1 id="消费者-1-获取消息-1"><a href="#消费者-1-获取消息-1" class="headerlink" title="  消费者[1] 获取消息 1"></a>  消费者[1] 获取消息 1</h1><p>  生产者[swht] 生产消息 2</p>
<h1 id="消费者-1-获取消息-2"><a href="#消费者-1-获取消息-2" class="headerlink" title="  消费者[1] 获取消息 2"></a>  消费者[1] 获取消息 2</h1><p>  生产者[swht] 生产消息 3</p>
<h1 id="消费者-1-获取消息-3"><a href="#消费者-1-获取消息-3" class="headerlink" title="  消费者[1] 获取消息 3"></a>  消费者[1] 获取消息 3</h1><p>  生产者[swht] 生产消息 4</p>
<h1 id="消费者-1-获取消息-4"><a href="#消费者-1-获取消息-4" class="headerlink" title="  消费者[1] 获取消息 4"></a>  消费者[1] 获取消息 4</h1><p>  生产者[swht] 生产消息 5</p>
<h1 id="消费者-1-获取消息-5"><a href="#消费者-1-获取消息-5" class="headerlink" title="  消费者[1] 获取消息 5"></a>  消费者[1] 获取消息 5</h1><p>  生产者[swht] 生产消息 6</p>
<h1 id="消费者-1-获取消息-6"><a href="#消费者-1-获取消息-6" class="headerlink" title="  消费者[1] 获取消息 6"></a>  消费者[1] 获取消息 6</h1><p>  生产者[swht] 生产消息 7</p>
<h1 id="消费者-1-获取消息-7"><a href="#消费者-1-获取消息-7" class="headerlink" title="  消费者[1] 获取消息 7"></a>  消费者[1] 获取消息 7</h1></li>
<li><p>一对多：</p>
<p>  import threading,queue,time<br>  def consumer(n):</p>
<pre><code>&apos;&apos;&apos;
消费者，消费生产者产生的消息、数据
:param n: 消费者标志
:return:
&apos;&apos;&apos;
while True:
    print(&quot;\033[32;1m消费者[%s]\033[0m 获取消息 %s&quot; % (n,q.get()))
    time.sleep(1)
    q.task_done() #消费者等待生产者生产消息
</code></pre><p>  def prodeucer(n):</p>
<pre><code>&apos;&apos;&apos;
生产者，生产消息、数据
:param n: 生产者标志
:return:
&apos;&apos;&apos;
count = 1
while True:
    print(&quot;\033[31;1m生产者[%s]\033[0m 生产消息 %s&quot; % (n,count))
    q.put(count)
    count += 1
    q.join() #生产者阻塞
    print(&quot;==================&quot;) #发出信号：消息已经生产
</code></pre><p>  q = queue.Queue()<br>  c1 = threading.Thread(target=consumer,args=[1,])<br>  c2 = threading.Thread(target=consumer,args=[2,])<br>  c3 = threading.Thread(target=consumer,args=[3,])<br>  p1 = threading.Thread(target=prodeucer,args=[“swht”,])</p>
<p>  c1.start()<br>  c2.start()<br>  c3.start()<br>  p1.start()</p>
<p>  结果：</p>
<p>  生产者[swht] 生产消息 1</p>
<h1 id="消费者-1-获取消息-1-1"><a href="#消费者-1-获取消息-1-1" class="headerlink" title="  消费者[1] 获取消息 1"></a>  消费者[1] 获取消息 1</h1><p>  生产者[swht] 生产消息 2</p>
<h1 id="消费者-2-获取消息-2"><a href="#消费者-2-获取消息-2" class="headerlink" title="  消费者[2] 获取消息 2"></a>  消费者[2] 获取消息 2</h1><p>  生产者[swht] 生产消息 3</p>
<h1 id="消费者-3-获取消息-3"><a href="#消费者-3-获取消息-3" class="headerlink" title="  消费者[3] 获取消息 3"></a>  消费者[3] 获取消息 3</h1><p>  生产者[swht] 生产消息 4</p>
<h1 id="消费者-1-获取消息-4-1"><a href="#消费者-1-获取消息-4-1" class="headerlink" title="  消费者[1] 获取消息 4"></a>  消费者[1] 获取消息 4</h1><p>  生产者[swht] 生产消息 5</p>
<h1 id="消费者-2-获取消息-5"><a href="#消费者-2-获取消息-5" class="headerlink" title="  消费者[2] 获取消息 5"></a>  消费者[2] 获取消息 5</h1><p>  生产者[swht] 生产消息 6</p>
<h1 id="消费者-3-获取消息-6"><a href="#消费者-3-获取消息-6" class="headerlink" title="  消费者[3] 获取消息 6"></a>  消费者[3] 获取消息 6</h1><p>  生产者[swht] 生产消息 7</p>
<h1 id="消费者-1-获取消息-7-1"><a href="#消费者-1-获取消息-7-1" class="headerlink" title="  消费者[1] 获取消息 7"></a>  消费者[1] 获取消息 7</h1></li>
</ol>
<ol>
<li><p>多对多：</p>
<p>  import threading,queue,time<br>  def consumer(n):</p>
<pre><code>&apos;&apos;&apos;
消费者，消费生产者产生的消息、数据
:param n: 消费者标志
:return:
&apos;&apos;&apos;
while True:
    print(&quot;\033[32;1m消费者[%s]\033[0m 获取消息 %s&quot; % (n,q.get()))
    time.sleep(1)
    q.task_done() #消费者等待生产者生产消息
</code></pre><p>  def prodeucer(n):</p>
<pre><code>&apos;&apos;&apos;
生产者，生产消息、数据
:param n: 生产者标志
:return:
&apos;&apos;&apos;
count = 1
while True:
    print(&quot;\033[31;1m生产者[%s]\033[0m 生产消息 %s&quot; % (n,count))
    q.put(count)
    count += 1
    q.join() #生产者阻塞
    print(&quot;==================&quot;) #发出信号：消息已经生产
</code></pre><p>  q = queue.Queue()<br>  c1 = threading.Thread(target=consumer,args=[1,])<br>  c2 = threading.Thread(target=consumer,args=[2,])<br>  c3 = threading.Thread(target=consumer,args=[3,])<br>  p1 = threading.Thread(target=prodeucer,args=[“swht”,])<br>  p2 = threading.Thread(target=prodeucer,args=[“shen”,])<br>  p3 = threading.Thread(target=prodeucer,args=[“alex”,])</p>
<p>  c1.start()<br>  c2.start()<br>  c3.start()<br>  p1.start()<br>  p2.start()<br>  p3.start()</p>
<p>  结果：</p>
<p>  生产者[swht] 生产消息 1<br>  生产者[shen] 生产消息 1<br>  消费者[1] 获取消息 1<br>  生产者[alex] 生产消息 1<br>  消费者[2] 获取消息 1</p>
<h1 id="消费者-3-获取消息-1"><a href="#消费者-3-获取消息-1" class="headerlink" title="  消费者[3] 获取消息 1"></a>  消费者[3] 获取消息 1</h1><p>  生产者[swht] 生产消息 2</p>
<h1 id="消费者-1-获取消息-2-1"><a href="#消费者-1-获取消息-2-1" class="headerlink" title="  消费者[1] 获取消息 2"></a>  消费者[1] 获取消息 2</h1><p>  生产者[swht] 生产消息 3</p>
<h1 id="消费者-2-获取消息-3"><a href="#消费者-2-获取消息-3" class="headerlink" title="  消费者[2] 获取消息 3"></a>  消费者[2] 获取消息 3</h1><p>  生产者[swht] 生产消息 4</p>
<h1 id="消费者-3-获取消息-4"><a href="#消费者-3-获取消息-4" class="headerlink" title="  消费者[3] 获取消息 4"></a>  消费者[3] 获取消息 4</h1><p>  生产者[alex] 生产消息 2</p>
<h1 id="消费者-1-获取消息-2-2"><a href="#消费者-1-获取消息-2-2" class="headerlink" title="  消费者[1] 获取消息 2"></a>  消费者[1] 获取消息 2</h1><h1 id="生产者-swht-生产消息-5"><a href="#生产者-swht-生产消息-5" class="headerlink" title="  生产者[swht] 生产消息 5"></a>  生产者[swht] 生产消息 5</h1><p>  生产者[shen] 生产消息 2<br>  消费者[2] 获取消息 2</p>
<h1 id="消费者-3-获取消息-5"><a href="#消费者-3-获取消息-5" class="headerlink" title="  消费者[3] 获取消息 5"></a>  消费者[3] 获取消息 5</h1><h1 id="生产者-swht-生产消息-6"><a href="#生产者-swht-生产消息-6" class="headerlink" title="  生产者[swht] 生产消息 6"></a>  生产者[swht] 生产消息 6</h1><p>  生产者[shen] 生产消息 3<br>  消费者[1] 获取消息 3</p>
<h1 id="消费者-3-获取消息-6-1"><a href="#消费者-3-获取消息-6-1" class="headerlink" title="  消费者[3] 获取消息 6"></a>  消费者[3] 获取消息 6</h1><p>  生产者[shen] 生产消息 4</p>
<h1 id="消费者-2-获取消息-4"><a href="#消费者-2-获取消息-4" class="headerlink" title="  消费者[2] 获取消息 4"></a>  消费者[2] 获取消息 4</h1><p>  生产者[shen] 生产消息 5</p>
<h1 id="消费者-1-获取消息-5-1"><a href="#消费者-1-获取消息-5-1" class="headerlink" title="  消费者[1] 获取消息 5"></a>  消费者[1] 获取消息 5</h1><p>  生产者[shen] 生产消息 6</p>
<h1 id="消费者-3-获取消息-6-2"><a href="#消费者-3-获取消息-6-2" class="headerlink" title="  消费者[3] 获取消息 6"></a>  消费者[3] 获取消息 6</h1><p>  生产者[shen] 生产消息 7</p>
<h1 id="消费者-2-获取消息-7"><a href="#消费者-2-获取消息-7" class="headerlink" title="  消费者[2] 获取消息 7"></a>  消费者[2] 获取消息 7</h1></li>
</ol>
<h3 id="三、协程"><a href="#三、协程" class="headerlink" title="三、协程"></a>三、协程</h3><p>协程是一种用户态的轻量级线程。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。</p>
<p>通过协程进行线程内切换，虽然还是串行的执行，但是因为切换速度快，可以达到一种并发的效果。用户自行控制</p>
<p>协程的好处：</p>
<pre><code>无需线程上下文切换的开销
无需原子操作锁定及同步的开销
方便切换控制流，简化编程模型
高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。
</code></pre><p>缺点：</p>
<pre><code>无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。
进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序
</code></pre><p>通过<strong>yeild</strong>简单模拟协程</p>
<pre><code>import time
import queue
def consumer(name):
    print(&quot;---&gt;starting eating baozi...&quot;)
    while True:
        new_baozi = yield
        print(&quot;[%s] is eating baozi %s&quot; % (name,new_baozi))
        #time.sleep(1)

def producer():

    r = con.__next__()
    r = con2.__next__()
    n = 0
    while n &lt; 5:
        n +=1
        con.send(n)
        con2.send(n)
        print(&quot;\033[32;1m[producer]\033[0m is making baozi %s&quot; %n )


if __name__ == &apos;__main__&apos;:
    con = consumer(&quot;c1&quot;)
    con2 = consumer(&quot;c2&quot;)
    p = producer()

&apos;&apos;&apos;    
结果：
---&gt;starting eating baozi...
---&gt;starting eating baozi...
[c1] is eating baozi 1
[c2] is eating baozi 1
[producer] is making baozi 1
[c1] is eating baozi 2
[c2] is eating baozi 2
[producer] is making baozi 2
[c1] is eating baozi 3
[c2] is eating baozi 3
[producer] is making baozi 3
[c1] is eating baozi 4
[c2] is eating baozi 4
[producer] is making baozi 4
[c1] is eating baozi 5
[c2] is eating baozi 5
[producer] is making baozi 5
&apos;&apos;&apos;
</code></pre><p><strong>greenlet模块</strong></p>
<p>greenlet模块可以简单的实现协程之间的切换</p>
<p>示例代码：</p>
<pre><code>from greenlet import greenlet
def test1():
    print(12)
    gr2.switch()
    print(34)
    gr2.switch()
def test2():
    print(56)
    gr1.switch()
    print(78)

gr1 = greenlet(test1)
gr2 = greenlet(test2)
gr1.switch()
</code></pre><p><strong>gevent模块</strong></p>
<p>Gevent 是一个第三方库，可以轻松通过gevent实现并发同步或异步编程，在gevent中用到的主要模式是Greenlet, 它是以C扩展模块形式接入Python的轻量级协程。 Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。</p>
<p>gevent模块实现协程在遇到IO阻塞时进行切换的功能。避免了协程的致命缺点：一个协程阻塞，整个线程宕掉</p>
<p>示例代码：</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
import gevent

def foo():
    print(&apos;\033[32;1mRunning in foo\033[0m&apos;)
    gevent.sleep(1)
    print(&apos;\033[32;1mExplicit context switch to foo again\033[0m&apos;)

def bar():
    print(&apos;Explicit context to bar&apos;)
    gevent.sleep(1)
    print(&apos;Implicit context switch back to bar&apos;)

def exe():
    print(&apos;\033[31;1mExplicit context to bar\033[0m&apos;)
    gevent.sleep(1)
    print(&apos;\033[31;1mImplicit context switch back to bar\033[0m&apos;)

gevent.joinall([
    gevent.spawn(foo),
    gevent.spawn(bar),
    gevent.spawn(exe),
])
</code></pre><p>附注：</p>
<pre><code>gevent模块安装：
1. windows环境：

    使用pip进行安装：pip2 install gevent 
                   pip3 install gevent

2. Linux环境：

    使用pip进行安装：pip2 install gevent 
                      pip3 install gevent
    使用源码包编译安装：
</code></pre><h3 id="四、select、poll、epoll多路IO阻塞"><a href="#四、select、poll、epoll多路IO阻塞" class="headerlink" title="四、select、poll、epoll多路IO阻塞"></a>四、select、poll、epoll多路IO阻塞</h3><ol>
<li><p>select</p>
<p> select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点，事实上从现在看来，这也是它所剩不多的优点之一。</p>
<p> select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，不过可以通过修改宏定义甚至重新编译内核的方式提升这一限制。</p>
<p> select()所维护的存储大量文件描述符的数据结构，随着文件描述符数量的增大，其复制的开销也线性增长。同时，由于网络响应时间的延迟使得大量TCP连接处于非活跃状态，但调用select()会对所有socket进行一次线性扫描，所以这也浪费了一定的开销。</p>
</li>
<li><p>poll</p>
<p> poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</p>
<p> select()和poll()将就绪的文件描述符告诉进程后，如果进程没有对其进行IO操作，那么下次调用select()和poll()的时候将再次报告这些文件描述符，所以它们一般不会丢失就绪的消息，这种方式称为水平触发（Level Triggered）。    </p>
</li>
<li><p>epoll</p>
<p> epoll可以同时支持水平触发和边缘触发（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。</p>
<p> epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表就绪描述符数量的值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射（mmap）技术，这样便彻底省掉了这些文件描述符在系统调用时复制的开销。</p>
<p> 另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。</p>
</li>
</ol>
<p>select示例：</p>
<pre><code>server端

#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
&apos;&apos;&apos;
通过echo server例子了解select 是如何通过单进程实现同时处理多个非阻塞的socket连接
&apos;&apos;&apos;

import select
import socket
import sys
import queue

# 创建一个TCP/IP socket
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.setblocking(False) #设置非阻塞 ==&gt;server.setblocking(0)

# 绑定端口和ip地址
server_address = (&apos;localhost&apos;, 10000)
print(sys.stderr, &apos;starting up on %s port %s&apos; % server_address) #
# print &gt;&gt; sys.stderr,&apos;starting up on %s port %s&apos; % server_address
server.bind(server_address)

# 监听连接，允许同时有5个链接
server.listen(5)
#select()方法接收并监控3个通信列表
#1.所有的输入数据，即外部发过来的数据；
#2.监控和监听所要发出去的数据；
#3.监控错误信息
# 创建输入列表将输入的信息传递给select()
inputs = [ server ]

# 创建输出列表将输出的信息传递给select()
outputs = [ ]

#创建一个缓存队列，用来存储每个连接的输入或输出的数据，然后由select去出来再发出去。
message_queues = {}
#程序的主循环，当调用select()时会阻塞和等待直到新的连接和数据进来
while inputs:

    # Wait for at least one of the sockets to be ready for processing
    print( &apos;\nwaiting for the next event&apos;)
    #readable 代表socket连接有数据可以接收(resv)
    #writable 代表socket连接有可以进行发送(send)的数据
    #exceptional 存放连接通信出现的error错误信息。这里使用inputs信息代替
    readable, writable, exceptional = select.select(inputs, outputs, inputs)
    # Handle inputs
    #readsble list中可以有3种可能状态，第一种是如果这个socket是main&quot;server&quot; socket,它负责监听客户端的连接，
    for s in readable:
        # 如果这个main server socket出现在readable里，那代表这是server端已经ready来接收一个新的连接进来了
        if s is server:
            # A &quot;readable&quot; server socket is ready to accept a connection
            connection, client_address = s.accept() #接收一个新的连接
            print(&apos;new connection from&apos;, client_address) #打印客户端连接的地址
            connection.setblocking(False) #设置成非阻塞状态
            inputs.append(connection) #将链接添加到inputs链表中

            # Give the connection a queue for data we want to send
            message_queues[connection] = queue.Queue()
        #这种情况是这个socket是已经建立了的连接，它把数据发了过来，这个时候就可以通过recv()来接收它发过来的数据，
        # 然后把接收到的数据放到queue里，这样就可以把接收到的数据再传回给客户端了。
        else:
            data = s.recv(1024) #接收客户端传递的数据
            if data: #如果接收的数据不为空
                # A readable client socket has data
                print(sys.stderr, &apos;received &quot;%s&quot; from %s&apos; % (data, s.getpeername()) )
                message_queues[s].put(data) #从缓存队列里获取数据然后将其传递给客户端
                # 如果连接不在发送列表中，则将其添加到发送列表中
                if s not in outputs:
                    outputs.append(s)
            else: #如果接收的数据为空
                # Interpret empty result as closed connection
                print(&apos;closing&apos;, client_address, &apos;after reading no data&apos;)
                # Stop listening for input on the connection
                #停止监听这个连接
                # 这种情况就是这个客户端已经断开了，所以你再通过recv()接收到的数据就为空了，
                # 所以这个时候你就可以把这个跟客户端的连接关闭了。
                if s in outputs:
                    outputs.remove(s)  #既然客户端都断开了，我就不用再给它返回数据了，所以这时候如果这个客户端的连接对象还在outputs列表中，就把它删掉
                inputs.remove(s)    #inputs中也删除掉
                s.close()           #把这个连接关闭掉

                # Remove message queue
                del message_queues[s]
    # 对于writable list中的socket，也有几种状态，如果这个客户端连接在跟它对应的queue里有数据，就把这个数据取出来再发回给这个客户端，否则就把这个连接从output list中移除，
    # 这样下一次循环select()调用时检测到outputs list中没有这个连接，那就会认为这个连接还处于非活动状态
    for s in writable:
        try:
            next_msg = message_queues[s].get_nowait() #获取信息不阻塞等待
        except queue.Empty:
            # No messages waiting so stop checking for writability.
            print(&apos;output queue for&apos;, s.getpeername(), &apos;is empty&apos;)
            outputs.remove(s) #队列为空，则从发送列表中删除连接
        else:
            print( &apos;sending &quot;%s&quot; to %s&apos; % (next_msg, s.getpeername()))
            s.send(next_msg) #当从队列中获取到信息时将其发送给客户端
    #果在跟某个socket连接通信过程中出了错误，就把这个连接对象在inputs\outputs\message_queue中都删除，
    # 再把连接关闭掉
    for s in exceptional:
        print(&apos;handling exceptional condition for&apos;, s.getpeername() )
        # Stop listening for input on the connection
        inputs.remove(s)
        if s in outputs:
            outputs.remove(s)
        s.close()

        # Remove message queue
        del message_queues[s]

client端
#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
import socket
import sys

messages = [ &apos;This is the message. &apos;,
             &apos;It will be sent &apos;,
             &apos;in parts.&apos;,
             ]
server_address = (&apos;localhost&apos;, 10000)

# Create a TCP/IP socket
socks = [ socket.socket(socket.AF_INET, socket.SOCK_STREAM),
          socket.socket(socket.AF_INET, socket.SOCK_STREAM),
          ]

# Connect the socket to the port where the server is listening
print(sys.stderr, &apos;connecting to %s port %s&apos; % server_address)
for s in socks:
    s.connect(server_address)

for message in messages:

    # Send messages on both sockets
    for s in socks:
        print(sys.stderr, &apos;%s: sending &quot;%s&quot;&apos; % (s.getsockname(), message))
        s.send(bytes(message,&apos;utf8&apos;))

    # Read responses on both sockets
    for s in socks:
        data = s.recv(1024)
        print(sys.stderr, &apos;%s: received &quot;%s&quot;&apos; % (s.getsockname(), data))
        if not data:
            print(sys.stderr, &apos;closing socket&apos;, s.getsockname())
            s.close()
</code></pre><h3 id="五、堡垒机模块"><a href="#五、堡垒机模块" class="headerlink" title="五、堡垒机模块"></a>五、堡垒机模块</h3><p>参考：<a href="http://www.cnblogs.com/wupeiqi/articles/5095821.html" target="_blank" rel="external">http://www.cnblogs.com/wupeiqi/articles/5095821.html</a></p>
<ol>
<li><p>模块安装：</p>
<p>pip2 install paramiko</p>
<p>pip3 install paramiko<br>#win下python3安装paramiko模块涉及到编译工具的问题没有安装成功，在Linux环境下面测试下面的代码正常。</p>
</li>
<li><p>示例代码</p>
<p>  #!/usr/local/env python3<br>  ‘’’<br>  Author:@南非波波<br>  Blog:<a href="http://www.cnblogs.com/songqingbo/" target="_blank" rel="external">http://www.cnblogs.com/songqingbo/</a><br>  E-mail:qingbo.song@gmail.com<br>  ‘’’<br>  import paramiko<br>  ‘’’<br>  基于用户名密码连接<br>  ‘’’</p>
<h1 id="创建SSH对象"><a href="#创建SSH对象" class="headerlink" title="创建SSH对象"></a>创建SSH对象</h1><p>  ssh = paramiko.SSHClient()</p>
<h1 id="允许连接不在know-hosts文件中的主机"><a href="#允许连接不在know-hosts文件中的主机" class="headerlink" title="允许连接不在know_hosts文件中的主机"></a>允许连接不在know_hosts文件中的主机</h1><p>  ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</p>
<h1 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h1><p>  ssh.connect(hostname=’192.168.137.5’, port=22, username=’root’, password=’shen1234’)</p>
<h1 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h1><p>  stdin, stdout, stderr = ssh.exec_command(‘df -h’)</p>
<h1 id="获取命令结果"><a href="#获取命令结果" class="headerlink" title="获取命令结果"></a>获取命令结果</h1><p>  result = stdout.read()<br>  #打印结果<br>  print(result.decode())</p>
<h1 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h1><p>  ssh.close()</p>
<p>  import paramiko</p>
<p>  transport = paramiko.Transport((‘192.168.137.5’, 22))<br>  transport.connect(username=’root’, password=’shen1234’)</p>
<p>  ssh = paramiko.SSHClient()<br>  ssh._transport = transport</p>
<p>  stdin, stdout, stderr = ssh.exec_command(‘ifconfig’)<br>  print(stdout.read().decode())</p>
<p>  transport.close()</p>
<p>  import paramiko</p>
<p>  def ssh_connet(host,user,shell):</p>
<pre><code>&apos;&apos;&apos;
实现ssh远程登录服务器进行相关操作
:param host: 远程服务器地址和端口号 host_ip:port
:param user: 远程服务器用户名密码 user:passwd
:parm shell: 需要执行的shell命令
:return: 返回用户执行shell命令的
&apos;&apos;&apos;
host = host.split(&quot;:&quot;)
user = user.split(&quot;:&quot;)
transport = paramiko.Transport((host[0], int(host[1])))
transport.connect(username=user[0], password=user[1])
ssh = paramiko.SSHClient()
ssh._transport = transport
stdin, stdout, stderr = ssh.exec_command(shell)
reaults = stdout.read().decode()
transport.close()
return reaults
</code></pre><p>  print(ssh_connet(“192.168.137.5:22”,”root:shen1234”,”df -h”))</p>
</li>
</ol>
<p>基于公钥密钥连接：<br>    import paramiko</p>
<pre><code>def ssh_connet(host,user,private_key,shell):
    &apos;&apos;&apos;
    实现ssh远程登录服务器进行相关操作
    :param host: 远程服务器地址和端口号 host_ip:port
    :param user: 远程服务器用户名密码 user:passwd
    :param private_key: 基于公钥的形式登录
    :parm shell: 需要执行的shell命令
    :return: 返回用户执行shell命令的
    &apos;&apos;&apos;
    host = host.split(&quot;:&quot;)
    transport = paramiko.Transport((host[0], int(host[1])))
    transport.connect(username=user[0], key=private_key)
    ssh = paramiko.SSHClient()
    ssh._transport = transport
    stdin, stdout, stderr = ssh.exec_command(shell)
    reaults = stdout.read().decode()
    transport.close()
    return reaults
private_key = paramiko.RSAKey.from_private_key_file(&apos;/home/auto/.ssh/id_rsa&apos;)
print(ssh_connet(&quot;192.168.137.5:22&quot;,&quot;root&quot;,private_key,&quot;df -h&quot;))
</code></pre><h3 id="六、mysql操作模块"><a href="#六、mysql操作模块" class="headerlink" title="六、mysql操作模块"></a>六、mysql操作模块</h3><p>rollback()事务回滚<br>excutemany()</p>
<p>作业：</p>
<pre><code>1.    select（）代码，注释
2.    主机批量管理工具
    1.    saltstack文档阅读（常用架构弄清楚）
    2.    修改主机批量管理工具的架构
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/12/s12-20160312-day09/" data-id="ciq8usaeo000jogj5irk2y8j2" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python开发之路/">Python开发之路</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-s12-20160305-day08" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/05/s12-20160305-day08/" class="article-date">
  <time datetime="2016-03-05T07:30:00.000Z" itemprop="datePublished">2016-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/05/s12-20160305-day08/">pytho自动化开发 day08</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author:@南非波波</p>
<p>课程大纲：</p>
<p>day07</p>
<p><a href="http://www.cnblogs.com/alex3714/articles/5213184.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5213184.html</a></p>
<p>day08</p>
<p><a href="http://www.cnblogs.com/alex3714/articles/5227251.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5227251.html</a></p>
<p>###推荐电影###</p>
<pre><code>绝美之城  上帝之城 | 千与千寻  龙猫 卡尔的移动城堡
</code></pre><p>通过实例私有变量，需要将在类中封装一个方法，该方法返回私有变量的值</p>
<h3 id="一、socket深入"><a href="#一、socket深入" class="headerlink" title="一、socket深入"></a>一、socket深入</h3><p>1.概念</p>
<pre><code>Unix的进程通信机制。一个完整的socket有一个本地唯一的socket号，由操作系统分配。socket是面向客户/服务器模型而设计的，针对客户和服务器程序提供不同的socket系统调用。socket利用客户/服务器模式巧妙的解决了进程之间建立通信连接的问题。

套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。
</code></pre><p>2.地址簇</p>
<pre><code>socket.AF_UNIX unix本机进程间通信 
socket.AF_INET　使用IPV4地址协议进行进程间通信
socket.AF_INET6  使用IPV6地址协议进行进程间通信
</code></pre><p>3.套接字类型</p>
<pre><code>socket.SOCK_STREAM  #使用tcp协议
socket.SOCK_DGRAM   #使用udp协议
socket.SOCK_RAW     #原始套接字，普通的套接字无法处理ICMP、IFMP等网络报文，而SOCK_RAM可以。其次SOCK_RAM也可以处理特殊的IPV4报文,此外，利用原始套接字可以通过IP_HDRINCL套接字选项由用户构造IP头。
socket.SOCK_RDM    #是一种可靠的UDP形式，即保证交付数据报但不保证顺序。SOCK_RAW用来提供对原始协议的低级访问，在需要执行某些特殊操作时使用，如发送ICMP报文。SOCK_RAW通常仅限于高级用户或管理员运行的程序使用。
</code></pre><p>4.socket方法</p>
<pre><code>1. socket.socket(family=AF_INET, type=SOCK_STREAM, proto=0, fileno=None)
2. socket.socketpair([family[, type[, proto]]])
3. socket.create_connection(address[, timeout[, source_address]])
4. socket.getaddrinfo(host, port, family=0, type=0, proto=0, flags=0) 
    获取要连接的对端主机地址
5. sk.bind(address) 
    将套接字绑定到地址，地址的格式取决于地址簇。在AF_INET下，以元组(host.port)的形式表示地址。
6. sk.listen(backlog) 
    开始监听传入的连接，backlog指定在拒绝连接之前，可以挂起的最大连接数量。backlog等于5，表示内核已经连接到连接请求，但服务器还没有调用accept进行处理的连接个数最大为5.这个值根据内核和服务器物理配置进行设置。
7. sk.setblocking(bool) 
    是否阻塞（默认True），如果设置为False，那么accept和recv时一旦无数据则报错。
8. sk.accept() 
    接受连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据，address是连接客户端的地址。接收TCP客户的连接（阻塞式）等待连接的到来。
9. sk.connect(address)
    连接到address处的套接字。一般，address的格式为元组（hostname,port），如果连接出错，返回socket.err错误。
10. sk.connect_ex(address)
    同上，只是会有返回值，连接成功时返回0，连接失败时会返回编码，例如：10061
11. sk.close()
    关闭套接字
12. sk.recv(bufsize[,flag])
    接收套接字的数据，数据以字符串形式返回。bufsize指定最多可以接收的数量，建议不要超过1024*8。flag提供有关消息的其他信息。通常可以忽略。
13. sk.recvfrom(bufsize[.flag])
    与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址
14. sk.send(string[,flag])
    将string中的数据发送到连接的套接字，返回值是要发送的字节数量，该数量可能小于string的字节大小，即：可能未壮指定内容全部发送
15. sk.sendall(string[,flag])
    将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则跑出异常。内部通过递归调用send将所有内容发送出去。
16.    sk.sendto(string[,flag],address)
    将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。该函数主要用于UDP协议。
17. sk.settimeout(timeout)
    设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如 client 连接最多等待5s ）
18. sk.getpeername()
    返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）
19.    sk.getsockname()
    返回套接字自己的地址，通常在是一个元组（ipaddr,port）
20. socket.gethostname()
    获取程序运行所在计算机的主机名
21.    gethostbyname(name) 
    尝试将给定的主机名解释为一个IP地址。首先将检查当前计算机是否能够解释。如果不能，一个解释请求将发送给一个远程的DNS服务器（远程的DNS服务器 还可能将解释请求转发给另一个DNS服务器，直到该请求可以被处理）。gethostbyname函数返回这个IP地址或在查找失败后引发一个异常。例如： socket.gethostbyname(&apos;www.apicloud.com&apos;)
    扩展形式：socket.gethostbyname_ex(&apos;www.apicloud.com&apos;)
    (&apos;98e86f98d416f10c.7cname.com&apos;, [&apos;www.apicloud.com&apos;], [&apos;117.25.140.17&apos;])
    它返回一个包含三个元素的元组，分别是给定地址的主要的主机名、同一IP地址的可选的主机名的一个列表、关于同一主机的同一接口的其它IP地址的一个列表（列表可能都是空的）。
22. gethostbyaddr(address)
    函数的作用与gethostbyname_ex相同，只是你提供给它的参数是一个IP地址字符串。
    socket.gethostbyaddr(&apos;202.165.102.205&apos;)
    (&apos;homepage.vip.cnb.yahoo.com&apos;, [&apos;www.yahoo.com.cn&apos;], [&apos;202.165.102.205&apos;])
23.    getservbyname(service,protocol)
    函数要求一个服务名（如&apos;telnet&apos;或&apos;ftp&apos;）和一个协议（如&apos;tcp&apos;或&apos;udp&apos;），返回服务所使用的端口号：
    &gt;&gt;&gt; socket.getservbyname(&apos;http&apos;,&apos;tcp&apos;)
    80
    &gt;&gt;&gt; socket.getservbyname(&apos;https&apos;,&apos;tcp&apos;)
    443
    &gt;&gt;&gt; socket.getservbyname(&apos;telnet&apos;,&apos;tcp&apos;)
24.    sk.fileno()
    套接字的文件描述符
    socket.sendfile(file, offset=0, count=None)
    发送文件 ，但目前多数情况下并无什么卵用
</code></pre><h3 id="二、socketserver"><a href="#二、socketserver" class="headerlink" title="二、socketserver"></a>二、socketserver</h3><p>参考链接：<a href="http://my.oschina.net/u/1433482/blog/190612" target="_blank" rel="external">http://my.oschina.net/u/1433482/blog/190612</a></p>
<p>SocketServer简化了网络服务器的编写。它有4个类：TCPServer，UDPServer，UnixStreamServer，UnixDatagramServer。这4个类是同步进行处理的，另外通过ForkingMixIn和ThreadingMixIn类来支持异步。</p>
<p><strong>创建服务器的步骤</strong></p>
<pre><code>首先，你必须创建一个请求处理类，它是BaseRequestHandler的子类并重载其handle()方法。其次，你必须实例化一个服务器类，传入服务器的地址和请求处理程序类。最后，调用handle_request()(一般是调用其他事件循环或者使用select())或serve_forever()。
</code></pre><p><strong>服务器类型</strong></p>
<pre><code>5种类型：BaseServer，TCPServer，UnixStreamServer，UDPServer，UnixDatagramServer。 注意：BaseServer不直接对外服务。
</code></pre><p><strong>服务器对象</strong></p>
<pre><code>class SocketServer.BaseServer：这是模块中的所有服务器对象的超类。它定义了接口，如下所述，但是大多数的方法不实现，在子类中进行细化。

BaseServer.fileno()：返回服务器监听套接字的整数文件描述符。通常用来传递给select.select(), 以允许一个进程监视多个服务器。

BaseServer.handle_request()：处理单个请求。处理顺序：get_request(), verify_request(), process_request()。如果用户提供handle()方法抛出异常，将调用服务器的handle_error()方法。如果self.timeout内没有请求收到， 将调用handle_timeout()并返回handle_request()。

BaseServer.serve_forever(poll_interval=0.5): 处理请求，直到一个明确的shutdown()请求。每poll_interval秒轮询一次shutdown。忽略self.timeout。如果你需要做周期性的任务，建议放置在其他线程。

BaseServer.shutdown()：告诉serve_forever()循环停止并等待其停止。python2.6版本。

BaseServer.address_family: 地址家族，比如socket.AF_INET和socket.AF_UNIX。

BaseServer.RequestHandlerClass：用户提供的请求处理类，这个类为每个请求创建实例。

BaseServer.server_address：服务器侦听的地址。格式根据协议家族地址的各不相同，请参阅socket模块的文档。

BaseServer.socketSocket：服务器上侦听传入的请求socket对象的服务器。

服务器类支持下面的类变量：

BaseServer.allow_reuse_address：服务器是否允许地址的重用。默认为false ，并且可在子类中更改。

BaseServer.request_queue_size

请求队列的大小。如果单个请求需要很长的时间来处理，服务器忙时请求被放置到队列中，最多可以放request_queue_size个。一旦队列已满，来自客户端的请求将得到 “Connection denied”错误。默认值通常为5 ，但可以被子类覆盖。

BaseServer.socket_type：服务器使用的套接字类型; socket.SOCK_STREAM和socket.SOCK_DGRAM等。

BaseServer.timeout：超时时间，以秒为单位，或 None表示没有超时。如果handle_request()在timeout内没有收到请求，将调用handle_timeout()。

下面方法可以被子类重载，它们对服务器对象的外部用户没有影响。

BaseServer.finish_request()：实际处理RequestHandlerClass发起的请求并调用其handle()方法。 常用。

BaseServer.get_request()：接受socket请求，并返回二元组包含要用于与客户端通信的新socket对象，以及客户端的地址。

BaseServer.handle_error(request, client_address)：如果RequestHandlerClass的handle()方法抛出异常时调用。默认操作是打印traceback到标准输出，并继续处理其他请求。

BaseServer.handle_timeout()：超时处理。默认对于forking服务器是收集退出的子进程状态，threading服务器则什么都不做。

BaseServer.process_request(request, client_address) :调用finish_request()创建RequestHandlerClass的实例。如果需要，此功能可以创建新的进程或线程来处理请求,ForkingMixIn和ThreadingMixIn类做到这点。常用。

BaseServer.server_activate()：通过服务器的构造函数来激活服务器。默认的行为只是监听服务器套接字。可重载。

BaseServer.server_bind()：通过服务器的构造函数中调用绑定socket到所需的地址。可重载。

BaseServer.verify_request(request, client_address)：返回一个布尔值，如果该值为True ，则该请求将被处理，反之请求将被拒绝。此功能可以重写来实现对服务器的访问控制。默认的实现始终返回True。client_address可以限定客户端，比如只处理指定ip区间的请求。 常用。
</code></pre><p><strong>请求处理器</strong></p>
<pre><code>处理器接收数据并决定如何操作。它负责在socket层之上实现协议（i.e., HTTP, XML-RPC, or AMQP)，读取数据，处理并写反应。可以重载的方法如下：

setup(): 准备请求处理. 默认什么都不做，StreamRequestHandler中会创建文件类似的对象以读写socket.

handle(): 处理请求。解析传入的请求，处理数据，并发送响应。默认什么都不做。常用变量：self.request，self.client_address，self.server。

finish(): 环境清理。默认什么都不做，如果setup产生异常，不会执行finish。

通常只需要重载handle。self.request的类型和数据报或流的服务不同。对于流服务，self.request是socket 对象；对于数据报服务，self.request是字符串和socket 。可以在子类StreamRequestHandler或DatagramRequestHandler中重载，重写setup()和finish() ，并提供self.rfile和self.wfile属性。 self.rfile和self.wfile可以读取或写入，以获得请求数据或将数据返回到客户端。
</code></pre><p><strong>示例代码</strong></p>
<ol>
<li><p>server</p>
<p>  #!/usr/local/env python3<br>  ‘’’<br>  Author:@南非波波<br>  Blog:<a href="http://www.cnblogs.com/songqingbo/" target="_blank" rel="external">http://www.cnblogs.com/songqingbo/</a><br>  E-mail:qingbo.song@gmail.com<br>  ‘’’<br>  import socketserver</p>
<p>  class MyHandleServer(socketserver.BaseRequestHandler):</p>
<pre><code>&apos;&apos;&apos;
定义一个测试socketserver类
&apos;&apos;&apos;
def handle(self):
    &apos;&apos;&apos;
    定义一个函数，用来处理每个客户端发来的请求
    :return:
    &apos;&apos;&apos;
    print(&quot;新建立一个连接：&quot;,self.client_address)
    while True:
        try:
            client_data = self.request.recv(1024)
            if not client_data:
                print(&quot;客户端发送的数据为空,主动断开!&quot;,self.client_address)
                break
            print(&quot;客户端发来的请求:&quot;,client_data.decode())
            self.request.send(client_data)
        except ConnectionResetError:
            print(&quot;客户端主动断开!&quot;,self.client_address)
            break
</code></pre><p>  if <strong>name</strong> == “<strong>main</strong>“:</p>
<pre><code>HOST,PORT = &quot;127.0.0.1&quot;,5000
server = socketserver.ThreadingTCPServer((HOST,PORT),MyHandleServer)
server.serve_forever()
</code></pre></li>
</ol>
<ol>
<li><p>client</p>
<p>  #!/usr/local/env python3<br>  ‘’’<br>  Author:@南非波波<br>  Blog:<a href="http://www.cnblogs.com/songqingbo/" target="_blank" rel="external">http://www.cnblogs.com/songqingbo/</a><br>  E-mail:qingbo.song@gmail.com<br>  ‘’’<br>  import socket</p>
<p>  ip_port = (“127.0.0.1”,5000)</p>
<p>  sk = socket.socket()<br>  sk.connect(ip_port)<br>  while True:</p>
<pre><code>msg = input(&quot;&gt;&gt;:&quot;).strip()
if not msg:
    break
sk.sendall(bytes(msg,&quot;utf8&quot;))
server_reply = sk.recv(1024)
print(&quot;服务端返回:&quot;,str(server_reply,&quot;utf8&quot;))
</code></pre><p>  sk.close()</p>
</li>
</ol>
<h3 id="三、异常处理"><a href="#三、异常处理" class="headerlink" title="三、异常处理"></a>三、异常处理</h3><p><a href="http://www.cnblogs.com/wupeiqi/articles/5017742.html" target="_blank" rel="external">http://www.cnblogs.com/wupeiqi/articles/5017742.html</a></p>
<ol>
<li><p>异常基础(python3的写法)</p>
<p> 在编程过程中为了增加友好性，在程序出现bug时一般不会将错误信息显示给用户，而是显示一个提示的页面，通俗来说就是不让用户看见代码出错的页面</p>
<pre><code>try:
    pass
except Exception as ex:
    pass
</code></pre></li>
<li><p>异常种类</p>
<p> 常用异常：</p>
<pre><code>AttributeError 试图访问一个对象没有的树形，比如foo.x，但是foo没有属性x
IOError 输入/输出异常；基本上是无法打开文件
ImportError 无法引入模块或包；基本上是路径问题或名称错误
IndentationError 语法错误（的子类） ；代码没有正确对齐
IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问x[5]
KeyError 试图访问字典里不存在的键
KeyboardInterrupt Ctrl+C被按下
NameError 使用一个还未被赋予对象的变量
SyntaxError Python代码非法，代码不能编译(个人认为这是语法错误，写错了）
TypeError 传入对象类型与要求的不符合
UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的全局变量，
导致你以为正在访问它
ValueError 传入一个调用者不期望的值，即使值的类型是正确的
</code></pre><p> 更多种类：</p>
<pre><code>ArithmeticError
AssertionError
AttributeError
BaseException
BufferError
BytesWarning
DeprecationWarning
EnvironmentError
EOFError
Exception  #捕获一般的所有异常
FloatingPointError
FutureWarning
GeneratorExit
ImportError  #捕获导入模块异常
ImportWarning
IndentationError
IndexError  #捕获索引异常
IOError  #捕获IO异常
KeyboardInterrupt  #捕获键盘组合键异常
KeyError
LookupError
MemoryError
NameError
NotImplementedError
OSError
OverflowError
PendingDeprecationWarning
ReferenceError
RuntimeError
RuntimeWarning
StandardError
StopIteration
SyntaxError
SyntaxWarning
SystemError
SystemExit
TabError
TypeError
UnboundLocalError
UnicodeDecodeError
UnicodeEncodeError
UnicodeError
UnicodeTranslateError
UnicodeWarning
UserWarning
ValueError
Warning
ZeroDivisionError
</code></pre></li>
<li><p>自定义异常类</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
class SwhtError(Exception):
    &apos;&apos;&apos;
    自定义异常
    &apos;&apos;&apos;
    def __init__(self,msg):
        &apos;&apos;&apos;
        初始化函数
        :param msg:用户输入message
        :return:
        &apos;&apos;&apos;
        self.message = msg

    def __str__(self): #名称可以自行定义，只是通过该方法返回message的值
        &apos;&apos;&apos;
        返回用户输入的信息
        :return:
        &apos;&apos;&apos;
        return self.message

try:
    raise SwhtError(&quot;这是一个致命的错误！&quot;)
except Exception as e:
    print(&quot;dsdsd&quot;,e)
</code></pre></li>
<li><p>示例代码：</p>
<pre><code>dic = [&quot;swht&quot;, &apos;shen&apos;]
try:
    dic[10]
except IndexError as e:
    print(&quot;IndexError:&quot;,e)

dic = {&apos;k1&apos;:&apos;v1&apos;}
try:
    dic[&apos;k20&apos;]
except KeyError as e:
    print(&quot;keyError:&quot;,e)

s1 = &apos;hello&apos;
try:
    int(s1)
except ValueError as e:
    print(&quot;ValueError:&quot;,e)
</code></pre></li>
<li><p>特殊异常</p>
<p> 虽然python自带的一个处理万能异常类Exception，但是并不是有一些异常都能被捕获的。如果要想捕获这些特殊的异常，就需要进行自定义异常类</p>
</li>
<li><p>异常其他架构</p>
<pre><code>try:
    # 主代码块
    pass
except KeyError as e:
    # 异常时，执行该块
    pass
else:
    # 主代码块执行完，执行该块
    pass
finally:
    # 无论异常与否，最终执行该块
    pass
</code></pre></li>
<li><p>主动触发异常</p>
<pre><code>try:
    raise Exception(&apos;错误了。。。&apos;)
except Exception as e:
    print(&quot;Error&quot;,e)
</code></pre></li>
<li><p>Asser断言：</p>
<p> 至关重要的判断，强制判断前面的业务结果是否符合要求，否则就抛出异常</p>
<pre><code>a = 1
try:
    assert a == 2
    print(&quot;True&quot;)
except Exception as e:
    print(&quot;False&quot;,e)
</code></pre></li>
</ol>
<h3 id="四、进程与线程"><a href="#四、进程与线程" class="headerlink" title="四、进程与线程"></a>四、进程与线程</h3><ol>
<li><p>概念</p>
<ol>
<li><p>进程</p>
<p>  一个具有一定独立功能的程序关于某个数据集合的一次运行活动，是系统进行资源分配和调度运行的基本单位</p>
</li>
<li><p>线程</p>
<p>  线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务</p>
</li>
<li><p>进程与线程的区别</p>
<ol>
<li><p>进程是一个动态的概念</p>
<p>进程是程序的一次执行过程，是动态概念</p>
<p>程序是一组有序的指令集和，是静态概念</p>
</li>
<li><p>不同的进程可以执行同一个程序</p>
<p>区分进程的条件：所执行的程序和数据集合。</p>
<p>两个进程即使执行在相同的程序上，只要他们运行在不同的数据集合上，他们也是两个进程。例如：多个用户同时调用同一个编译程序编译他们编写的C语言源程序，由于编译程序运行在不同的数据集合（不同的C语言源程序）上，于是产生了一个个不同的进程</p>
</li>
<li><p>每个进程都有自己的生命周期</p>
<p>当操作系统要完成某个任务时，它会创建一个进程。当进程完成任务之后，系统就会撤销这个进程，收回它所占用的资源。从创建到撤销的时间段就是进程的生命期</p>
</li>
<li><p>进程之间存在并发性</p>
<p>在一个系统中，同时会存在多个进程。他们轮流占用CPU和各种资源</p>
</li>
<li><p>进程间会相互制约</p>
<p>进程是系统中资源分配和运行调度的单位，在对资源的共享和竞争中，必然相互制约，影响各自向前推进的速度</p>
</li>
<li><p>进程可以创建子进程，程序不能创建子程序</p>
</li>
<li><p>从结构上讲，每个进程都由程序、数据和一个进程控制块（Process Control Block, PCB）组成</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>进程锁</p>
<p>Python threading模块</p>
<ol>
<li>线程的两种调用方式<ol>
<li>直接调用</li>
<li>继承式调用</li>
</ol>
</li>
<li>join&amp;&amp;Demo</li>
<li>线程锁<ol>
<li>互斥锁：同时仅且只有一个线程在运行</li>
<li>共享锁：同时可以有多个线程共同运行，可以实现一个线程池的效果</li>
<li>递归锁</li>
<li>Semaphore(信号量)</li>
</ol>
</li>
<li></li>
</ol>
</li>
</ol>
<p>示例代码：</p>
<pre><code>#!/usr/local/env python3

import threading,time

def addNum():
    global num #声明修改全局变量
    print(&quot;--get num:&quot;,num)
    time.sleep(1)
    lock.acquire()
    num -=1
    lock.release()

lock = threading.Lock()
num = 100
threading_list = []
for i in range(2040):
    t = threading.Thread(target=addNum)
    t.start()
    threading_list.append(t)
for t in threading_list: #等待所有线程执行完毕
    t.join()

print(&quot;num:&quot;,num)
</code></pre><p>event</p>
<p>多进程</p>
<p>进程间通讯</p>
<pre><code>队列
管道
manager
    Manager 所有的子进程和父进程之间都能进行数据的共享
    Manager 是一个安全的进程管理池，不需要加进程锁
</code></pre><p>进程同步</p>
<p>进程池</p>
<pre><code>开启一个进程的系统开销太大，设置进程池限制启动的进程数，以达到保护系统的目的。另外在线程池内的进程可以实现同步或异步调用。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/05/s12-20160305-day08/" data-id="ciq8usaej000hogj5n0bae7ib" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python开发之路/">Python开发之路</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-s12-20160227-day07" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/27/s12-20160227-day07/" class="article-date">
  <time datetime="2016-02-27T07:30:00.000Z" itemprop="datePublished">2016-02-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/27/s12-20160227-day07/">pytho自动化开发 day07</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author:@南非波波</p>
<p>课程大纲：</p>
<p>day06</p>
<p><a href="http://www.cnblogs.com/alex3714/articles/5188179.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5188179.html</a></p>
<p>day07</p>
<p><a href="http://www.cnblogs.com/alex3714/articles/5213184.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5213184.html</a></p>
<h2 id="一、类的多态、继承"><a href="#一、类的多态、继承" class="headerlink" title="一、类的多态、继承"></a>一、类的多态、继承</h2><p>类的多态：统一接口调用</p>
<pre><code>#!/usr/bin/env python
# -*- coding:utf-8 -*-
class Animal:
    def __init__(self, name):    # Constructor of the class
        self.name = name
    def talk(self):              # Abstract method, defined by convention only
        raise NotImplementedError(&quot;Subclass must implement abstract method&quot;)
    hobbie = &apos;ddd&apos;
class Cat(Animal):
    def talk(self):
        return &apos;Meow!&apos;
class Dog(Animal):
    def talk(self):
        return &apos;Woof! Woof!&apos;

animals = [Cat(&apos;Missy&apos;),
           Dog(&apos;Lassie&apos;)]

for animal in animals:
    print(animal.name + &apos;: &apos; + animal.talk())
</code></pre><p>类的方法：示例</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
class Animal(object):
    &apos;&apos;&apos;
    定义一个动物类
    &apos;&apos;&apos;
    def __init__(self,name):
        self.name = name
        self.__num = None #定义成私有变量，只能在类中访问

    # def talk(self):
    #     print(&quot;%s is talking!&quot; % self.name)
    hobbie = &quot;shen&quot; #类变量，静态字段
    @classmethod  #类方法，不能访问实例变量
    def talk(self):
        print(&quot;%s is talking!&quot; % self.hobbie)
    # def work(self):
    #     print(&quot;%s is working!&quot; % self.name)

    @staticmethod #静态方法，不能访问类变量和实例变量
    def work():
        print(&quot;It is working!&quot;)

    # def walk(self):
    #     print(&quot;%s is walking!&quot; % self.name)
    @property #把方法编程静态属性
    def walk(self,num):
        return self.__num
    @walk.setter #传值
    def walk(self,num):
        self.__num = num
        print(self.__num)
    @walk.deleter  #删值
    def walk(self):
        print(&quot;del num&quot;)
c = Animal(&quot;swht&quot;)
# c.talk()
# c.work()
c.walk = 3
del c.walk
print(&quot;OUT:&quot;,c._Animal__num)  #特例情况下可以通过这种方式访问私有变量
</code></pre><p><strong>经典类与新式类</strong></p>
<p>经典类和新式类区别：</p>
<p>经典类：使用深度优先进行继承<br>新式类：使用广度优先进行继承</p>
<p>另外：经典类和新式类在python-3.X平台上会默认使用广度优先进行继承，而在python-2.X中则体现上述区别</p>
<p>示例代码：</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;

class A:
    print(&quot;A&quot;)
    def f2(self):
        print(&quot;f2 from A&quot;)
class B(A):
    print(&quot;B&quot;)
    def f1(self):
        print(&quot;f1 from B&quot;)
    def f2(self):
        print(&quot;f2 from B&quot;)
class C(A):
    print(&quot;C&quot;)
    def f2(self):
        print(&quot;f2 from C&quot;)

class D(B,C):
    pass

d = D()
d.f1()
d.f2()

&apos;&apos;&apos;
广度优先算法继承。先将B类中的f2()注释掉，D自动继承C.f2()，如果再将C类中的f2()，D自动继承A.f2()
&apos;&apos;&apos;
</code></pre><p><strong>类的特殊成员</strong></p>
<pre><code>__doc__:查看类的注释
__init__:构造方法，通过类创建对象时，自动触发执行。
__module__:表示当前操作的对象在那个模块
__class__:表示当前操作的对象的类是什么
__del__:析构方法,解释器进行垃圾回收时自动触发
__call__:对象加()执行call方法
__new__：实例化时new方法执行了__init__
__metaclass__：通过改写metaclass方法达到构建自己需要的类的目的
__dict__:以字典的形式显示类对象中的成员。使用场景：查看类中有多少成员（只显示类变量，不显示实例变量）
__str__:如果一个类中定义了__str__方法，那么在打印 对象 时，默认输出该方法的返回值。
__iter__:用于迭代器，之所以列表、字典、元组可以进行for循环，是因为类型内部定义了 __iter__ 
</code></pre><p>示例：</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;

class People(object):
    &apos;&apos;&apos;
    定义一个人类
    &apos;&apos;&apos;
    def __init__(self,name,age):
        &apos;&apos;&apos;
        定义属性
        :param name: 人类的名字
        :param age: 人类的年龄属性
        :return:
        &apos;&apos;&apos;
        self.name = name
        self.age = age

    def china_man(self):
        pass

chinese = People(&quot;swht&quot;,27)
#__doc__:查看类的注释
print(chinese.__doc__) #  定义一个人类
#__dict__:以字典的形式显示类对象中的成员。使用场景：查看类中有多少成员（只显示类变量，不显示实例变量）
print(chinese.__dict__) #{&apos;age&apos;: 27, &apos;name&apos;: &apos;swht&apos;}
#__module__:表示当前操作的对象在那个模块
print(chinese.__module__) #__main__
#__class__:表示当前操作的对象的类是什么
print(chinese.__class__) #&lt;class &apos;__main__.People&apos;&gt;
</code></pre><p><strong>构造类的方法</strong></p>
<p><a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python" target="_blank" rel="external">http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python</a></p>
<p>一句话构建一个类</p>
<pre><code>Foo = type(&apos;Foo&apos;,(object,), {&apos;func&apos;: func}) 
    #type第一个参数：类名
    #type第二个参数：当前类的基类
    #type第三个参数：类的成员
</code></pre><p><img src="http://i.imgur.com/dmSh15M.png" alt=""></p>
<h3 id="反射方法"><a href="#反射方法" class="headerlink" title="反射方法"></a>反射方法</h3><p>hasattr：判断实例中是否存在指定输入的方法</p>
<pre><code>hasattr(server,sys.argv[1])  返回值是布尔型 True or False
</code></pre><p>getattr:获取实例中的方法</p>
<pre><code>func = getattr(server,sys.argv[1])  获取对象方法的内存地址
</code></pre><p>setattr:将自定义的某个方法设定到特定实例中去使用</p>
<pre><code>setattr(server,&apos;run&apos;,test_run) 将特定方法test_run绑定给实例server，并重命名为run方法
server.run()  实例server可以指定调用方法run
</code></pre><p>delattr:删除实例的成员变量或者类的方法，不能删除实例的方法</p>
<pre><code>#delattr可以删除类的方法、实例的成员变量
# delattr(server,&apos;start&apos;) #尝试删除实例的方法是错误的
# delattr(server,&quot;host&quot;) #删除实例的变量
# delattr(Webserver,&apos;start&apos;)
# server.start() #AttributeError: &apos;Webserver&apos; object has no attribute &apos;start&apos;
</code></pre><p>完整示例代码：</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;

import sys
class Webserver(object):
    &apos;&apos;&apos;
    定义一个web server启动、关闭类
    &apos;&apos;&apos;
    def __init__(self,host,port):
        &apos;&apos;&apos;
        初始化类
        :param host: 主机地址
        :param port: 主机端口号
        :return:
        &apos;&apos;&apos;
        self.host = host
        self.port = port
    def start(self):
        &apos;&apos;&apos;
        服务启动方法
        :return:
        &apos;&apos;&apos;
        print(&quot;service is starting...&quot;)

    def stop(self):
        &apos;&apos;&apos;
        服务停止方法
        :return:
        &apos;&apos;&apos;
        print(&quot;service is stopping ...&quot;)

    def restart(self):
        &apos;&apos;&apos;
        服务重启方法
        :return:
        &apos;&apos;&apos;
        self.stop()
        self.start()

#定义一个特殊运行的函数，绑定到实例server上去
def test_run():
    print(&quot;测试运行...&quot;)

server = Webserver(&quot;localhost&quot;,80)
if hasattr(server,sys.argv[1]):
    func = getattr(server,sys.argv[1])
    func()
#setattr主要作用是将一个单独定义的函数添加到实例中，对于类或者其他实例而言，该函数对其不生效
setattr(server,&apos;run&apos;,test_run)
server.run()

#delattr可以删除类的方法、实例的成员变量
# delattr(server,&apos;start&apos;) #尝试删除实例的方法是错误的
# delattr(server,&quot;host&quot;) #删除实例的变量
# delattr(Webserver,&apos;start&apos;)
# server.start() #AttributeError: &apos;Webserver&apos; object has no attribute &apos;start&apos;
</code></pre><h2 id="二、socket网络编程"><a href="#二、socket网络编程" class="headerlink" title="二、socket网络编程"></a>二、socket网络编程</h2><p>简单实现C/S交互实例：</p>
<p>示例代码：</p>
<pre><code>实现简单的client与server端数据交互（一句话）
</code></pre><p>socket_server</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;

import socket

ip_port = (&quot;127.0.0.1&quot;,5000)
sk = socket.socket()
sk.bind(ip_port)
sk.listen(5)

while True:
    print(&quot;南非波波server is Listening....&quot;)
    conn,addr = sk.accept()
    client_data = conn.recv(1024)
    print(str(client_data,&quot;utf8&quot;))
    conn.sendall(bytes(&quot;落花不是无情物，化作春泥更护花！&quot;,&quot;utf8&quot;))
    conn.close()
</code></pre><p>socket_client</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;

import socket
ip_port = (&quot;127.0.0.1&quot;,5000)

sk = socket.socket()
sk.connect(ip_port)

sk.sendall(bytes(&quot;夕阳无限好，只是近黄昏&quot;,&quot;utf8&quot;))

server_reply = sk.recv(1024)
print(str(server_reply,&quot;utf8&quot;))
sk.close()
</code></pre><p>改善代码1：</p>
<pre><code>实现多个client与server进行串行交互
</code></pre><p>socket-server1 </p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;

import socket

ip_port = (&quot;127.0.0.1&quot;,5000)
sk = socket.socket()
sk.bind(ip_port)
sk.listen(5)

while True:
    print(&quot;南非波波server is Listening....&quot;)
    conn,addr = sk.accept()
    client_data = conn.recv(1024)
    print(str(client_data,&quot;utf8&quot;))
    # conn.sendall(bytes(&quot;落花不是无情物，化作春泥更护花！&quot;,&quot;utf8&quot;))
    while True:
        try:
            client_data = conn.recv(1024)
            if not client_data:
                break
            print(&quot;recv:&quot;,str(client_data,&quot;utf8&quot;))
            conn.send(client_data)
        except Exception:
            print(&quot;客户端断开!&quot;)
            break
    conn.close()
</code></pre><p>socket-client1</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;

import socket
ip_port = (&quot;127.0.0.1&quot;,5000)

sk = socket.socket()
sk.connect(ip_port)

# sk.sendall(bytes(&quot;夕阳无限好，只是近黄昏&quot;,&quot;utf8&quot;))

server_reply = sk.recv(1024)
print(str(server_reply,&quot;utf8&quot;))
while True:
    client_data = input(&quot;&gt;&gt;:&quot;).strip()
    if not client_data:
        continue
    if client_data == &apos;q&apos;:
        break
    sk.send(bytes(client_data,&quot;utf8&quot;))
    print(client_data)
sk.close()
</code></pre><p>最终代码：</p>
<pre><code>实现简单的ssh命令交互，获取Linux系统的相关信息
</code></pre><p>socket-server2</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
import socket
import subprocess

ip_port = (&quot;127.0.0.1&quot;,5000)  #定义服务监听的ip地址和端口
ssh = socket.socket()
ssh.bind(ip_port) #进行地址和端口绑定
ssh.listen(5) #设定做多5个并发连接

while True:
    print(&quot;南非波波Server is waiting...&quot;)
    conn,addr = ssh.accept()
    while True:
        client_data = conn.recv(1024)  #介绍client发过来的数据，最大接收字节1024
        if not client_data: #如果client_data为空，则跳出循环
            break
        cmd = str(client_data,&quot;utf8&quot;) #获取client_data数据并进行类型和编码转换
        print(&quot;server recv:&quot;,cmd)
        cmd_call = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE) #以原生shell命令的形式指定client的强求指定，并将结果输出到cmd_result
        cmd_result = cmd_call.stdout.read()
        if len(cmd_result) == 0: #如果命令没有结果返回，则需要给client返回一个提示，否则控制台会阻塞
            cmd_result = b&quot;cmd execution has no output..&quot;

        #client不能一次性接收过多的数据包，需要server端先告知client端需要传输的数据多少。然后由client端分开接收
        ack_msg = bytes(&quot;CMD_RESULT_SIZE|%s&quot; % len(cmd_result),&quot;utf8&quot;) #发送数据传输认证标志
        conn.send(ack_msg)
        client_ack = conn.recv(50)
        if client_ack.decode() == &apos;CLIENT_READY_TO_RECV&apos;:
            conn.send(cmd_result) #数据传输
    conn.close()
</code></pre><p>socket-client2</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
import socket

ip_port = (&quot;127.0.0.1&quot;,5000)
ssh_client = socket.socket()
ssh_client.connect(ip_port)

while True:
    user_input = input(&quot;ssh-client:&quot;).strip()
    if len(user_input) == 0:
        continue
    if user_input == &apos;q&apos;:
        break
    ssh_client.send(bytes(user_input,&apos;utf8&apos;))
    #ack_msg = b&quot;CMD_RESULT_SIZE|%s&quot; % len(cmd_result)
    server_ack_msg = ssh_client.recv(100)
    cmd_res_msg = str(server_ack_msg.decode()).split(&quot;|&quot;)
    if cmd_res_msg[0] == &quot;CMD_RESULT_SIZE&quot;:
        cmd_res_size = int(cmd_res_msg[1])
        ssh_client.send(b&quot;CLIENT_READY_TO_RECV&quot;)
    res = &apos;&apos;
    received_size = 0
    while received_size &lt; cmd_res_size:
        server_data = ssh_client.recv(500)
        received_size += len(server_data)
        res += str(server_data.decode())
    else:
        print(res)
        print(&quot;-----------recv don----------&quot;)
ssh_client.close()
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/02/27/s12-20160227-day07/" data-id="ciq8usae90009ogj5v9rkqtdm" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python开发之路/">Python开发之路</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-s12-20160130-day06" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/20/s12-20160130-day06/" class="article-date">
  <time datetime="2016-02-20T07:30:00.000Z" itemprop="datePublished">2016-02-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/20/s12-20160130-day06/">pytho自动化开发 day06</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author:@南非波波</p>
<p>课程大纲：</p>
<p>day05</p>
<p><a href="http://www.cnblogs.com/alex3714/articles/5161349.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5161349.html</a></p>
<p>day06</p>
<p><a href="http://www.cnblogs.com/alex3714/articles/5188179.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5188179.html</a></p>
<h3 id="一、模块回顾"><a href="#一、模块回顾" class="headerlink" title="一、模块回顾"></a>一、模块回顾</h3><h4 id="1-os模块"><a href="#1-os模块" class="headerlink" title="1. os模块"></a>1. os模块</h4><h4 id="2-sys模块"><a href="#2-sys模块" class="headerlink" title="2. sys模块"></a>2. sys模块</h4><h4 id="3-shutil模块"><a href="#3-shutil模块" class="headerlink" title="3. shutil模块"></a>3. shutil模块</h4><p>高级的 文件、文件夹、压缩包 处理模块</p>
<p>shutil.copyfileobj(fsrc, fdst[, length])</p>
<pre><code>功能：将文件内容拷贝到另一个文件中，可以部分内容
</code></pre><p>shutil.copyfile(src, dst)</p>
<pre><code>功能：仅拷贝文件
</code></pre><p>shutil.copymode(src, dst)</p>
<pre><code>功能：仅拷贝权限，内容、组、用户均不变
</code></pre><p>shutil.copystat(src, dst)</p>
<pre><code>功能：拷贝状态的信息，包括：mode bits, atime, mtime, flags
</code></pre><p>shutil.copy(src, dst)</p>
<pre><code>功能：拷贝文件和权限
</code></pre><p>shutil.copy2(src, dst)</p>
<pre><code>功能：拷贝文件和状态信息

1. zipfile


2. tarfile
</code></pre><h4 id="4-shelve模块"><a href="#4-shelve模块" class="headerlink" title="4. shelve模块"></a>4. shelve模块</h4><p>二次封装pickle模块功能，对比pickle而言，shelve实现了按照‘键’来取值</p>
<p>示例：</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
import shelve

name = [&apos;swht&apos;,&apos;shen&apos;,&apos;test&apos;]
class Test(object):
    def __init__(self,n):
        self.n = n
t1 = Test(1234)
t2 = Test(123456)

#存数据
# shelve_file = shelve.open(&apos;ret.txt&apos;)
# shelve_file[&apos;use&apos;] = name
# shelve_file[&apos;t1&apos;] = t1
# shelve_file[&apos;t2&apos;] = t2
# shelve_file.close()

#取数据
shelve_load = shelve.open(&apos;ret.txt&apos;)
a = shelve_load.get(&apos;use&apos;)
print(a)
b = shelve_load.get(&apos;t1&apos;)
print(b.n)
c = shelve_load.get(&apos;t2&apos;)
print(c.n)
shelve_load.close()
</code></pre><h4 id="5-configparser模块"><a href="#5-configparser模块" class="headerlink" title="5.configparser模块"></a>5.configparser模块</h4><p>示例：</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
import configparser

#生成文档
#[&quot;DEFAULT&quot;]是一个全局模块，对所有的模块生效
&apos;&apos;&apos;
config = configparser.ConfigParser()
config[&quot;DEFAULT&quot;] = {&apos;ServerAliveInterval&apos;: &apos;45&apos;,
                      &apos;Compression&apos;: &apos;yes&apos;,
                     &apos;CompressionLevel&apos;: &apos;9&apos;}

config[&apos;bitbucket.org&apos;] = {}
config[&apos;bitbucket.org&apos;][&apos;User&apos;] = &apos;hg&apos;
config[&apos;topsecret.server.com&apos;] = {}
topsecret = config[&apos;topsecret.server.com&apos;]
topsecret[&apos;Host Port&apos;] = &apos;50022&apos;     # mutates the parser
topsecret[&apos;ForwardX11&apos;] = &apos;no&apos;  # same here
config[&apos;DEFAULT&apos;][&apos;ForwardX11&apos;] = &apos;yes&apos;
with open(&apos;example.ini&apos;, &apos;w&apos;) as configfile:
   config.write(configfile)
&apos;&apos;&apos;

#查询
&apos;&apos;&apos;
config = configparser.ConfigParser()
config.read(&apos;example.ini&apos;)
print(config.sections())  #[&apos;bitbucket.org&apos;, &apos;topsecret.server.com&apos;]
if &apos;bitbucket.org&apos; in config:
    print(&apos;True&apos;)
print(&quot;[&apos;bitbucket.org&apos;][&apos;User&apos;]:&quot;,config[&apos;bitbucket.org&apos;][&apos;User&apos;])
print(&quot;[&apos;bitbucket.org&apos;][&apos;Compression&apos;]:&quot;,config[&apos;bitbucket.org&apos;][&apos;Compression&apos;])
for key in config[&apos;bitbucket.org&apos;]:
    print(key)
&apos;&apos;&apos;
#读
&apos;&apos;&apos;
config = configparser.ConfigParser()
config.read(&apos;example.ini&apos;)
secs = config.sections()
print(secs) #[&apos;bitbucket.org&apos;, &apos;topsecret.server.com&apos;]

options = config.options(&apos;topsecret.server.com&apos;)
print(options) #[&apos;host port&apos;, &apos;forwardx11&apos;, &apos;compression&apos;, &apos;serveraliveinterval&apos;, &apos;compressionlevel&apos;]

item_list = config.items(&apos;bitbucket.org&apos;)
print(item_list) #[(&apos;compression&apos;, &apos;yes&apos;), (&apos;serveraliveinterval&apos;, &apos;45&apos;), (&apos;compressionlevel&apos;, &apos;9&apos;), (&apos;forwardx11&apos;, &apos;yes&apos;), (&apos;user&apos;, &apos;hg&apos;)]

val = config.get(&apos;bitbucket.org&apos;,&apos;compression&apos;)
print(val)
&apos;&apos;&apos;

#改写
config = configparser.ConfigParser()
config.read(&apos;example.ini&apos;)

#实现从原来的文件中读取，删除[bitbucket.org]模块后将其他内容写到example_new.ini文件中
# sec = config.remove_section(&apos;bitbucket.org&apos;)
# config.write(open(&apos;example_new.ini&apos;, &quot;w&quot;))

#添加[swht]模块
# sec = config.has_section(&apos;swht&apos;)
# sec = config.add_section(&apos;swht&apos;)
# config.write(open(&apos;example_new1.ini&apos;, &quot;w&quot;))
</code></pre><h4 id="6-hashlib模块"><a href="#6-hashlib模块" class="headerlink" title="6. hashlib模块"></a>6. hashlib模块</h4><p>该模块提供了多个算法对字符串进行加密操作。</p>
<p>示例代码：</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
import hashlib

&apos;&apos;&apos;
#md5加密
md5num = hashlib.md5()
md5num.update(b&quot;shendiaoxia1278@sohu.com&quot;)
print(md5num.hexdigest()) #7e023c9fafc96423da854e4923f466a1
&apos;&apos;&apos;

&apos;&apos;&apos;
#sha1加密
sha1num = hashlib.sha1()
sha1num.update(b&quot;shendiaoxia1278@sohu.com&quot;)
print(sha1num.hexdigest()) #dd8d5deaa16c2dde03785aac99943f8f75bfaba9
&apos;&apos;&apos;

&apos;&apos;&apos;
#sha256加密
hash = hashlib.sha256()
hash.update(b&quot;shendiaoxia1278@sohu.com&quot;)
print(hash.hexdigest()) #14b03e2271da2cc9b0cc3ff73727c6d3ba6ba17077470a92162f7b46c9d1d968
&apos;&apos;&apos;

&apos;&apos;&apos;
#sha384加密
hash = hashlib.sha384()
hash.update(b&quot;shendiaoxia1278@sohu.com&quot;)
print(hash.hexdigest()) #a27bbc0d66d6b8b00a7ebfcad662ebed385fe2098898dfe23b88ffa88e1b6565d82e7eee5c9950c90231d0c0aa286e00
&apos;&apos;&apos;

&apos;&apos;&apos;
#sha512加密
hash = hashlib.sha512()
hash.update(b&quot;shendiaoxia1278@sohu.com&quot;)
print(hash.hexdigest()) #42bb1886bba49373c8f8177fba32a58a1f31af7272219789db52776428789f4a39970da9a36fdef6ab76651ed9f07e0fa140e4fa7dd325cb52559389bb80ceab
&apos;&apos;&apos;
</code></pre><p>高级加密代码</p>
<pre><code>&apos;&apos;&apos;
# import hashlib

# ######## md5 #######
hash = hashlib.md5(b&apos;898oaFs09f&apos;)
hash.update(b&quot;shendiaoxia1278@sohu.com&quot;)
print(hash.hexdigest()) #2aa29d812ca08b39d96f9441775420ba
&apos;&apos;&apos;

&apos;&apos;&apos;
import hmac

#可以使用在用户登录的时候，使用用户输入的用户名和密码进行加密后作为用户的密码

hash = hmac.new(b&quot;shendiaoxia1278@sohu.com&quot;)
hash.update(b&quot;swht&quot;)
print(hash.hexdigest()) #c65d9bc3f37d6cfb9a9c959a18463bf4

&apos;&apos;&apos;
</code></pre><h4 id="7-subprocess模块"><a href="#7-subprocess模块" class="headerlink" title="7. subprocess模块"></a>7. subprocess模块</h4><pre><code>1. python2.7

    import subprocess
    #默认状态shell = False，必须使用一个列表的方式将shell命令传递进去
    ret = subprocess.call([&quot;ls&quot;, &quot;-l&quot;], shell=False)
    #使用shell = True告诉subprocess模块对用户传入的shell命令不转义，即使用原生shell命令
    ret = subprocess.call(&quot;ls -l&quot;, shell=True)


2. python3.5
</code></pre><h4 id="8-logging模块"><a href="#8-logging模块" class="headerlink" title="8. logging模块"></a>8. logging模块</h4><p>示例：</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
import logging

# logging.warning(&quot;user [swht] is start the systerm!&quot;)
# logging.critical(&quot;server is down!&quot;)
#创建日志
logger = logging.getLogger(&apos;[Test-Log]&apos;)
logger.setLevel(logging.DEBUG) #全局级别优先级较高

#创建一个控制台的handler并设置日志级别
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)

#创建一个文件的handler并设置日志级别
fh = logging.FileHandler(&quot;access.log&quot;)
fh.setLevel(logging.WARNING)
#创建日期格式

fomatter = logging.Formatter(&apos;%(asctime)s %(name)s %(levelname)s %(message)s&apos;,datefmt=&apos;%Y-%m-%d %H:%M:%S&apos;)

#add formatter to ch and fh
ch.setFormatter(fomatter)
fh.setFormatter(fomatter)

logger.addHandler(ch)
logger.addHandler(fh)

# &apos;application&apos; code
logger.debug(&apos;debug message&apos;)
logger.info(&apos;info message&apos;)
logger.warn(&apos;warn message&apos;)
logger.error(&apos;error message&apos;)
logger.critical(&apos;critical message&apos;)

#输出格式：
&apos;&apos;&apos;
2016-02-20 16:53:27 [Test-Log] DEBUG debug message
2016-02-20 16:53:27 [Test-Log] INFO info message
2016-02-20 16:53:27 [Test-Log] WARNING warn message
2016-02-20 16:53:27 [Test-Log] ERROR error message
2016-02-20 16:53:27 [Test-Log] CRITICAL critical message
&apos;&apos;&apos;
</code></pre><h3 id="二、面向对象编程"><a href="#二、面向对象编程" class="headerlink" title="二、面向对象编程"></a>二、面向对象编程</h3><h4 id="1-面向对象的介绍"><a href="#1-面向对象的介绍" class="headerlink" title="1. 面向对象的介绍"></a>1. 面向对象的介绍</h4><pre><code>1.    不要写重复的代码
2.    代码易扩展，程序遵循易读、易改的原则
</code></pre><h4 id="2-面向对象的特性"><a href="#2-面向对象的特性" class="headerlink" title="2. 面向对象的特性"></a>2. 面向对象的特性</h4><pre><code>1.    封装
2.    继承
    1.    基类或父类或超类
    2.    子类或派生类
    一般情况下，一个子类只能有一个基类，但在python中，一个子类是可以继承多个基类，实现多重继承，可以通过多级继承来实现；继承的过程就是从一般到特殊的过程
3.    多态
    实现接口的重用
</code></pre><h4 id="3-类、方法"><a href="#3-类、方法" class="headerlink" title="3. 类、方法"></a>3. 类、方法</h4><p><strong>类 class</strong></p>
<p>示例：</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
class Role(object):
    def __init__(self,name,role,weapon,life_value):
        self.name = name
        self.role = role
        self.weapon = weapon
        self.life_value = life_value
    def buy_weapon(self,weapon):
        self.weapon = weapon
        print(&quot;%s 成功购买[%s]&quot; % (self.name,weapon))

#实例化
p1 = Role(&apos;swht&apos;,&apos;p&apos;,&apos;A11&apos;,100)
t1 = Role(&apos;shen&apos;,&apos;t&apos;,&apos;A11&apos;,100)

print(&quot;p1[weapon]初始值:&quot;,p1.weapon)
print(&quot;t1[weapon]初始值:&quot;,t1.weapon)

#买枪行为
p1.buy_weapon(&quot;AK65&quot;)
t1.buy_weapon(&quot;AK60&quot;)

print(&quot;p1[weapon]当前值:&quot;,p1.weapon)
print(&quot;t1[weapon]当前值:&quot;,t1.weapon)
</code></pre><h4 id="作业："><a href="#作业：" class="headerlink" title="作业："></a>作业：</h4><pre><code>模拟人生游戏

    1.    至少有两个不同的角色
    2.    玩的过程中，必须有交互
    3.    根据不同的交互产生不同的行为
    4.    一定要用到面向对象编程的语法及思想
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/02/20/s12-20160130-day06/" data-id="ciq8usaee000dogj5wp12syzk" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python开发之路/">Python开发之路</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python开发之路/">Python开发之路</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Python开发之路/" style="font-size: 10px;">Python开发之路</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/05/14/s12-20160514-day17/">pytho自动化开发 day17</a>
          </li>
        
          <li>
            <a href="/2016/05/07/s12-20160507-day16/">pytho自动化开发 day16</a>
          </li>
        
          <li>
            <a href="/2016/04/30/s12-20160430-day15/">pytho自动化开发 day15</a>
          </li>
        
          <li>
            <a href="/2016/04/21/s12-20160421-day14/">pytho自动化开发 day14</a>
          </li>
        
          <li>
            <a href="/2016/04/09/s12-20160409-day13/">pytho自动化开发 day13</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 南非波波<br>
      Powered by <a href="http://blog.songqingbo,cn/" target="_blank">南非波波</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">文章</a>
  
    <a href="http://www.cnblogs.com/songqingbo/" class="mobile-nav-link">cnblogs博客</a>
  
    <a href="https://github.com/swht" class="mobile-nav-link">github</a>
  
</nav>
    

<script src="/js/jquery-2.2.3.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>