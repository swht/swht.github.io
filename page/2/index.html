<!DOCTYPE html>
<html lang="zh-CN">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="南非波波" />


    
    


<meta name="description" content="这是一个记录学习和工作的个人博客。">
<meta property="og:type" content="website">
<meta property="og:title" content="南非波波博客">
<meta property="og:url" content="http://blog.songqingbo.cn/page/2/index.html">
<meta property="og:site_name" content="南非波波博客">
<meta property="og:description" content="这是一个记录学习和工作的个人博客。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="南非波波博客">
<meta name="twitter:description" content="这是一个记录学习和工作的个人博客。">

<link rel="apple-touch-icon" href= "/南非波波.png">


    <link rel="alternate" href="/atom.xml" title="南非波波博客" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>南非波波博客</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">南非波波</a></h1>
        </hgroup>

        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:qingbo.song@gmail.com" title="Email"></a>
                            
                                <a class="fa 新浪微博" href="/sina weibo" title="新浪微博"></a>
                            
                                <a class="fa GitHub" href="https://github.com/swht" title="GitHub"></a>
                            
                                <a class="fa V2EX" href="http://www.v2ex.com/member/swht" title="V2EX"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa 知乎" href="https://www.zhihu.com/people/nanfeibobo" title="知乎"></a>
                            
                                <a class="fa 豆瓣" href="https://www.douban.com/people/swht/" title="豆瓣"></a>
                            
                                <a class="fa 简书" href="http://www.jianshu.com/users/247fb1ce1573/timeline" title="简书"></a>
                            
                                <a class="fa SegmentFault" href="https://segmentfault.com/u/swht" title="SegmentFault"></a>
                            
                                <a class="fa 博客园" href="http://www.cnblogs.com/songqingbo" title="博客园"></a>
                            
                                <a class="fa QQ" href="tencent://message/?uin=1018584989&Site=南非波波&Menu=yes" title="QQ"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python开发之路/">Python开发之路</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">读书、爬山、码代码</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">南非波波</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">南非波波</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:qingbo.song@gmail.com" title="Email"></a>
                            
                                <a class="fa 新浪微博" target="_blank" href="/sina weibo" title="新浪微博"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/swht" title="GitHub"></a>
                            
                                <a class="fa V2EX" target="_blank" href="http://www.v2ex.com/member/swht" title="V2EX"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa 知乎" target="_blank" href="https://www.zhihu.com/people/nanfeibobo" title="知乎"></a>
                            
                                <a class="fa 豆瓣" target="_blank" href="https://www.douban.com/people/swht/" title="豆瓣"></a>
                            
                                <a class="fa 简书" target="_blank" href="http://www.jianshu.com/users/247fb1ce1573/timeline" title="简书"></a>
                            
                                <a class="fa SegmentFault" target="_blank" href="https://segmentfault.com/u/swht" title="SegmentFault"></a>
                            
                                <a class="fa 博客园" target="_blank" href="http://www.cnblogs.com/songqingbo" title="博客园"></a>
                            
                                <a class="fa QQ" target="_blank" href="tencent://message/?uin=1018584989&Site=南非波波&Menu=yes" title="QQ"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-s12-20160130-day05" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/30/s12-20160130-day05/" class="article-date">
      <time datetime="2016-01-30T07:30:00.000Z" itemprop="datePublished">2016-01-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/30/s12-20160130-day05/">pytho自动化开发 day05</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Author:@南非波波</p>
<p>课程大纲：</p>
<p>day04</p>
<p><a href="http://www.cnblogs.com/alex3714/articles/5143440.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5143440.html</a></p>
<p>day05</p>
<p><a href="http://www.cnblogs.com/alex3714/articles/5161349.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5161349.html</a></p>
<h3 id="一、正则深入"><a href="#一、正则深入" class="headerlink" title="一、正则深入"></a>一、正则深入</h3><p>re</p>
<p>匹配数字开头</p>
<pre><code>import re
#匹配以数字开头
p = re.compile(&quot;^[0-9]&quot;) #使用compile进行编译正则表达式，在大量匹配处理的时候非常有效
m = p.match(&quot;14534Abc&quot;)
print(m.group()) #输出结果：1
&apos;&apos;&apos;
m = re.match(&quot;^[0-9]&quot;,&quot;14534Abc&quot;)
print(m.group()) #输出结果：1
&apos;&apos;&apos;
</code></pre><p>匹配数字、字母等开头</p>
<pre><code>import re
#匹配以数字和字母开头
p = re.compile(&quot;^[0-9A-Za-z]&quot;)
m = p.match(&quot;AK14534Abc&quot;)
print(m.group()) #输出结果：A
</code></pre><p>匹配IP地址：</p>
<pre><code>#匹配IP地址
string = &apos;180.115.183.45 - - [03/Feb/2016:10:35:50 +0800] &quot;CONNECT imppl.tradedoubler.com:443 HTTP/1.0&quot; 400 172 &quot;-&quot; &quot;-&quot;&apos;
p = re.compile(&quot;([0-9]{1,3}\.){3}\d{1,3}&quot;)
ip = p.match(string).group()
# ip = re.match(&quot;([0-9]{1,3}\.){3}\d{1,3}&quot;,string).group()
print(ip)
</code></pre><p><strong>正则表达式常用5种操作</strong></p>
<p>re.match(pattern,string) #从头匹配</p>
<p>re.search(pattern,string) #匹配整个字符串，直到找到一个匹配</p>
<p>re.split() #将匹配到的格式当做分隔点对字符串分成列表类型</p>
<pre><code>示例：
import re
string = &quot;2016 02 02  00:26:35 Statistic_Svncommit.py[line:50] INFO [&apos;A6909850956019&apos;, &apos;A6997448878578&apos;, &apos;A6909712867884&apos;, &apos;A6996408725555&apos;, &apos;A6908651568946&apos;, &apos;A6996150172637&apos;, &apos;A6909747538711&apos;, &apos;A6994084740002&apos;, &apos;A6908427730549&apos;, &apos;A6982187752993&apos;, &apos;A6909861345295&apos;, &apos;A6909860252981&apos;, &apos;A6905214359647&apos;, &apos;A6995115894134&apos;]&quot;
strlist = re.search(&quot;\[\&apos;.*?\&apos;\]&quot;,string).group().lstrip(&quot;[&quot;).rstrip(&quot;]&quot;)
list1 = re.sub(&quot;[\&apos;&apos; &apos;]&quot;,&quot;&quot;,strlist).split(&quot;,&quot;)
print(list1)

返回结果：[&apos;A6909850956019&apos;, &apos;A6997448878578&apos;, &apos;A6909712867884&apos;, &apos;A6996408725555&apos;, &apos;A6908651568946&apos;, &apos;A6996150172637&apos;, &apos;A6909747538711&apos;, &apos;A6994084740002&apos;, &apos;A6908427730549&apos;, &apos;A6982187752993&apos;, &apos;A6909861345295&apos;, &apos;A6909860252981&apos;, &apos;A6905214359647&apos;, &apos;A6995115894134&apos;]
列表类型

m = re.split(&quot;[0-9]&quot;, &quot;swht1swht2jack3helenrachel8&quot;)
print(m) #[&apos;swht&apos;, &apos;swht&apos;, &apos;jack&apos;, &apos;helenrachel&apos;, &apos;&apos;]
</code></pre><p>re.findall()　# 找到所有要匹配的字符并返回列表格式</p>
<pre><code>示例：
import re
string = &quot;sdsdss(welcome)dff(china)&quot;
m = re.findall(&apos;\(.*?\)&apos;,string) #匹配所有以（开头和以）结尾的字符串,返回类型为list
print(m) #[&apos;(welcome)&apos;, &apos;(china)&apos;]
print(type(m))  #&lt;class &apos;list&apos;&gt;
</code></pre><p>re.sub(pattern, repl, string, count,flag) # 替换匹配到的字符</p>
<pre><code>示例：
import re
string = &quot;sdsdss(welcome)dff(china)&quot;
m = re.sub(&quot;\(|\)&quot;,&quot;\&quot;&quot;,string) #匹配&quot;(&quot;或者&quot;)&quot;，然后将其替换成双引号
print(m) #sdsdss&quot;welcome&quot;dff&quot;china&quot;
print(type(m)) #&lt;class &apos;str&apos;&gt;
</code></pre><p><strong>模式</strong></p>
<p>re.I #大小写不敏感</p>
<pre><code>import rz
string = &quot;swht&quot;
m = re.search(&quot;[A-Z]&quot;,string,flags = re.I)
print(m.group()) #s
</code></pre><p>匹配手机号：</p>
<pre><code>import re
string = &quot;sdssaawa15865921165sdsdscf&quot;
m = re.search(&quot;(1)([358]\d{9})&quot;,string)
print(m.group())
</code></pre><p>匹配IP地址:</p>
<pre><code>import re
ip_addr = &quot;inet 192.168.60.223 netmask 0xffffff00 broadcast 192.168.60.255&quot;
IP = re.search(&quot;(([1-9]|[1-9][0-9]|[1][0-9][0-9]|[2][0-5][0-5])\.){3}[0-9]{1,3}&quot;,ip_addr)
print(IP.group()) #192.168.60.223
</code></pre><p>匹配邮箱地址：</p>
<pre><code>import re
emailstr = &quot;qingbo.song@gmail.com www.baidu.com&quot;
email = re.search(&quot;^[a-z]([0-9a-z]|\.){4,20}@[0-9a-z]{0,10}\.[0-9a-z]{0,8}&quot;,emailstr)
print(email.group()) #qingbo.song@gmail.com

#只匹配gmail邮箱
import
emailstr = &quot;qingbo.song@gmail.com www.baidu.com&quot;
email = re.search(&quot;^[a-z]([0-9a-z]|\.){4,20}@gmail\.com&quot;,emailstr)
if email:
    print(email.group()) #qingbo.song@gmail.com
else:
    print(&quot;系统只接受gamil邮箱注册,感谢你的支持!&quot;)
</code></pre><h3 id="二、冒泡排序算法"><a href="#二、冒泡排序算法" class="headerlink" title="二、冒泡排序算法"></a>二、冒泡排序算法</h3><pre><code>示例代码：
#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;

li = [11,78,45,12,90,34,56]

# for m in range(1,len(li)):
#     for i in range(len(li) - 1):
#         if li[i] &gt; li[i+1]:
#             temp = li[i]
#             li[i] = li[i+1]
#             li[i+1] = temp
# print(li)

for m in range(len(li) - 1):
    for n in range(m+1,len(li)):
        if li[m] &gt; li[n]:
            temp = li[m]
            li[m] = li[n]
            li[n] = temp
print(li) #[11, 12, 34, 45, 56, 78, 90]

#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;

data = [11,78,45,12,90,34,56]
for i in range(1,len(data)):
    for j in range(len(data) - i):
        if data[j] &gt; data[j+1]:
            tmp = data[j]
            data[j+1] = data[j]
            data[j] = tmp
print(data)
</code></pre><h3 id="三、模块"><a href="#三、模块" class="headerlink" title="三、模块"></a>三、模块</h3><p><strong>模块介绍</strong></p>
<pre><code>模块：用一坨代码实现了某个功能的代码集合。
类似于函数式编程和面向过程编程，函数式编程则完成一个功能，其他代码用来处理和代码间的耦合。可能需要多个.py的文件组成。

模块类型：
    1. 自定义模块
    2. 内置标准模块（标准库）
    3. 开源模块
        1. 下载：
            1. yum
            2. apt-get
            3. pip
            4. easy_install
            5. 源码编译安装 python stup.py install
</code></pre><p><strong>导入模块</strong></p>
<pre><code>import module
from module.xx.xx import xx
from module.xx.xx import xx as rename  
#不推荐下面的导入方式，如果被导入的模块中含有与当前文件中相同名称的函数，容易产生调用混乱。
from module.xx.xx import * 
</code></pre><h4 id="四、自定义模块"><a href="#四、自定义模块" class="headerlink" title="四、自定义模块"></a>四、自定义模块</h4><p> 模块框架</p>
<pre><code>1. backend
    1. logic
        handle.py
            #!/usr/local/env python3
            &apos;&apos;&apos;
            Author:@南非波波
            Blog:http://www.cnblogs.com/songqingbo/
            E-mail:qingbo.song@gmail.com
            &apos;&apos;&apos;
            from backend.database.sql_select import select
            def home():
                print(&quot;welcome to home page!&quot;)
                q_data = select(&quot;user&quot;,&quot;test&quot;)
                print(&quot;query res:%s&quot; % q_data)

            def tv():
                print(&quot;welcome to tv page!&quot;)

            def moive():
                print(&quot;welcome to moive page!&quot;)
    2. database
        1. sql_select.py
            #!/usr/local/env python3
            &apos;&apos;&apos;
            Author:@南非波波
            Blog:http://www.cnblogs.com/songqingbo/
            E-mail:qingbo.song@gmail.com
            &apos;&apos;&apos;
            &apos;&apos;&apos;
            增加模块的路径。下面的语句增加的是dj路径
            该功能解决的是在子模块中的文件单独调试的时候无法获取父模块路径，导致在导入其他模块的时候报错
            &apos;&apos;&apos;
            import sys,os
            #获取dj的绝对路径
            base_dir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
            #将获取的路径添加到系统环境变量中
            sys.path.append(base_dir)


            from config import settings
            from backend.database.user_auth import db_auth

            def select(table,column):
                if db_auth(settings):
                    if table == &quot;user&quot;:
                        user_info = {
                            &quot;001&quot;:[&quot;swht&quot;,24,&quot;yunwei&quot;],
                            &quot;002&quot;:[&quot;shen&quot;,26,&quot;dba&quot;],
                            &quot;003&quot;:[&quot;test&quot;,28,&quot;student&quot;],
                        }
                        return user_info
        2. user_auth.py
            #!/usr/local/env python3
            &apos;&apos;&apos;
            Author:@南非波波
            Blog:http://www.cnblogs.com/songqingbo/
            E-mail:qingbo.song@gmail.com
            &apos;&apos;&apos;
            def db_auth(configs):
                if configs.DATABASES[&quot;user&quot;] == &quot;root&quot; and configs.DATABASES[&quot;password&quot;] == 123:
                    print(&quot;验证通过!&quot;)
                    return True
                else:
                    print(&quot;验证错误!&quot;)

2. frontend
3. config
    settings
        #!/usr/local/env python3
        &apos;&apos;&apos;
        Author:@南非波波
        Blog:http://www.cnblogs.com/songqingbo/
        E-mail:qingbo.song@gmail.com
        &apos;&apos;&apos;

        DATABASES = {
            &quot;engine&quot;:&quot;mysql&quot;,
            &quot;host&quot;:&quot;localhost&quot;,
            &quot;port&quot;:3306,
            &quot;user&quot;:&quot;root&quot;,
            &quot;password&quot;:123,
        }
4. user_main.py
    #!/usr/local/env python3
    &apos;&apos;&apos;
    Author:@南非波波
    Blog:http://www.cnblogs.com/songqingbo/
    E-mail:qingbo.song@gmail.com
    &apos;&apos;&apos;

    from backend.logic import handle

    handle.home()
</code></pre><h4 id="五、标准模块"><a href="#五、标准模块" class="headerlink" title="五、标准模块"></a>五、标准模块</h4><p>参考：<a href="http://www.cnblogs.com/wupeiqi/articles/4963027.html" target="_blank" rel="external">http://www.cnblogs.com/wupeiqi/articles/4963027.html</a></p>
<p><strong>time &amp; datetime模块</strong></p>
<pre><code>import time
import datetime

#作用：计算一个程序从执行到结束用的时间 
print(time.clock()) #返回处理器时间,3.3开始已废弃
print(time.process_time()) #返回处理器时间,3.3开始已废弃

#获取系统的当前时间，从1970年1月1日0：00到当前时间的秒数
print(time.time()) #返回当前系统时间戳

#格式化输出的时间
print(time.ctime()) #输出Tue Jan 26 18:23:48 2016 ,当前系统时间
print(time.ctime(time.time()-86640)) #将时间戳转为字符串格式，输出昨天的时间Tue Jan 25 18:23:48 2016

#time.struct_time(tm_year=2016, tm_mon=2,c=48, tm_wday=5, tm_yday=44, tm_isdst=0)
#gmtime是从零时区算起的格林时间
print(time.gmtime(time.time()-86640)) #将时间戳转换成struct_time格式
#当前时间，是按照系统当前时区算起的
print(time.localtime(time.time()-86640)) #将时间戳转换成struct_time格式,但返回 的本地时间
print(time.mktime(time.localtime())) #与time.localtime()功能相反,将struct_time格式转回成时间戳格式
#time.sleep(4) #sleep

#格式化输出时间
print(time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,time.gmtime()) ) #将struct_time格式转成指定的字符串格式
#time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,time.localtime())
#&apos;2016-02-14 12:45:49&apos;

print(time.strptime(&quot;2016-01-28&quot;,&quot;%Y-%m-%d&quot;) ) #将字符串格式转换成struct_time格式

#datetime module

#将时间戳转换成日期格式
print(datetime.date.today()) #输出格式python2 2016-01-26  python3：datetime.date(2016, 2, 14)
print(datetime.date.fromtimestamp(time.time()-864400) ) #2016-01-16 将时间戳转成日期格式
current_time = datetime.datetime.now() #
print(current_time) #输出2016-01-26 19:04:30.335935
print(current_time.timetuple()) #返回struct_time格式

#datetime.replace([year[, month[, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]]]]])
#将当前的时间替换成输入的时间
print(current_time.replace(2014,9,12)) #输出2014-09-12 19:06:24.074900,返回当前时间,但指定的值将被替换

str_to_date = datetime.datetime.strptime(&quot;21/11/06 16:30&quot;, &quot;%d/%m/%y %H:%M&quot;) #将字符串转换成日期格式
new_date = datetime.datetime.now() + datetime.timedelta(days=10) #比现在加10天
new_date = datetime.datetime.now() + datetime.timedelta(days=-10) #比现在减10天
new_date = datetime.datetime.now() + datetime.timedelta(hours=-10) #比现在减10小时
new_date = datetime.datetime.now() + datetime.timedelta(seconds=120) #比现在+120s
print(new_date)
</code></pre><p><strong>random模块</strong></p>
<p>产生随机数</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
import random

#产生随机小数
print(random.random())
&apos;&apos;&apos;
0.8426794741026359
0.8703558703687821
&apos;&apos;&apos;

#产生随机整数
print(random.randint(1,10))
print(random.randrange(1,10))
&apos;&apos;&apos;
1
9
&apos;&apos;&apos;
</code></pre><p>生成随机验证码</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
&apos;&apos;&apos;
生成n位随机数，包含大写字母和数字
&apos;&apos;&apos;
import random
def checkcode(n):
    checkcode = &apos;&apos;
    for i in range(n):
        current = random.randrange(0,4)
        if current != i:
            tmp = chr(random.randint(65,90))
        else:
            tmp = random.randint(0,9)
        checkcode += str(tmp)
    return checkcode

print(checkcode(6))
</code></pre><p><strong>os模块</strong></p>
<p>提供对操作系统进行调用的接口</p>
<pre><code>os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径
os.chdir(&quot;dirname&quot;)  改变当前脚本工作目录；相当于shell下cd
os.curdir  返回当前目录: (&apos;.&apos;)
os.pardir  获取当前目录的父目录字符串名：(&apos;..&apos;)
os.makedirs(&apos;dirname1/dirname2&apos;)    可生成多层递归目录
os.removedirs(&apos;dirname1&apos;) 删除空的目录，或多级空目录
os.mkdir(&apos;dirname&apos;)    生成单级目录；相当于shell中mkdir dirname
os.rmdir(&apos;dirname&apos;)    删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname
os.listdir(&apos;dirname&apos;)    列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印
os.remove()  删除一个文件
os.rename(&quot;oldname&quot;,&quot;newname&quot;)  重命名文件/目录，或者移动，相当于shell命令mv
os.stat(&apos;path/filename&apos;)  获取文件/目录信息
os.sep    输出操作系统特定的路径分隔符，win下为&quot;\\&quot;,Linux下为&quot;/&quot;
os.linesep    输出当前平台使用的行终止符，win下为&quot;\t\n&quot;,Linux下为&quot;\n&quot;
os.pathsep    输出用于分割文件路径的字符串
os.name    输出字符串指示当前使用平台。win-&gt;&apos;nt&apos;; Linux-&gt;&apos;posix&apos;
os.system(&quot;bash command&quot;)  运行shell命令，直接显示，只是单个shell命令的执行
os.environ  获取系统环境变量
os.path.abspath(path)  返回path规范化的绝对路径
os.path.split(path)  将path分割成目录和文件名二元组返回
os.path.dirname(path)  返回path的目录。其实就是os.path.split(path)的第一个元素
os.path.basename(path)  返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素
os.path.exists(path)  如果path存在，返回True；如果path不存在，返回False
os.path.isabs(path)  如果path是绝对路径，返回True
os.path.isfile(path)  如果path是一个存在的文件，返回True。否则返回False
os.path.isdir(path)  如果path是一个存在的目录，则返回True。否则返回False
os.path.join(path1[, path2[, ...]])  将多个路径组合后返回，第一个绝对路径之前的参数将被忽略
os.path.getatime(path)  返回path所指向的文件或者目录的最后存取时间
os.path.getmtime(path)  返回path所指向的文件或者目录的最后修改时间
</code></pre><p><strong>sys模块</strong></p>
<pre><code>sys.argv           命令行参数List，第一个元素是程序本身路径
sys.exit(n)        退出程序，正常退出时exit(0)
sys.version        获取Python解释程序的版本信息
sys.maxint         最大的Int值
sys.path           返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值
sys.platform       返回操作系统平台名称
sys.stdout.write(&apos;please:&apos;)
val = sys.stdin.readline()[:-1] #输入一行内容，减去后面的最后一个\n
</code></pre><p>使用sys和time模块生成进度条</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
&apos;&apos;&apos;
生成进度条。调用函数输入的参数为进度条长度
&apos;&apos;&apos;
import sys,time
def processbar(rangenum):
    for i in range(rangenum):
        if i == 0:
            sys.stdout.write(&quot;0%[#&quot;)
        elif i == rangenum - 1:
            sys.stdout.write(&quot;#]100%&quot;)
        else:
            sys.stdout.write(&quot;#&quot;)
            #刷新缓存，使其实时显示出来
            sys.stdout.flush()
            time.sleep(0.5)

processbar(16)
</code></pre><p><strong>json 和 pickle</strong> </p>
<p>json和pickle是用于序列化的两个模块：</p>
<pre><code>json：用于处理字符串和python数据类型间的转换
pickle：用于处理python特有类型和python数据类型间的转换
</code></pre><p>json</p>
<pre><code>json模块提供了四个功能：dumps、dump、loads、load
json在所有的语言中都通用，存取的直接字符
</code></pre><p>pickle</p>
<pre><code>pickle模块提供了四个功能：dumps、dump、loads、load
在python中独有一个模块，存取二进制字符
不仅仅可以序列化简单的字符、列表、字典，还能序列化函数、类以至于整个程序
</code></pre><p>关于dump和dumps的区别</p>
<pre><code>dump直接将序列化后的字符写到文件中，dumps是将序列化后的字符先赋给一个变量，然后再有write方法将其写入到文件中
</code></pre><p>关于load和loads的区别</p>
<pre><code>load直接从文件中读取内容，loads是从内存中获取文件的内容
</code></pre><p><strong>shutil模块</strong></p>
<p>高级的 文件、文件夹、压缩包 处理模块</p>
<p>shutil.copyfileobj(fsrc, fdst[, length])</p>
<pre><code>功能：将文件内容拷贝到另一个文件中，可以部分内容
</code></pre><p>shutil.copyfile(src, dst)</p>
<pre><code>功能：仅拷贝文件
</code></pre><p>shutil.copymode(src, dst)</p>
<pre><code>功能：仅拷贝权限，内容、组、用户均不变
</code></pre><p>shutil.copystat(src, dst)</p>
<pre><code>功能：拷贝状态的信息，包括：mode bits, atime, mtime, flags
</code></pre><p>shutil.copy(src, dst)</p>
<pre><code>功能：拷贝文件和权限
</code></pre><p>shutil.copy2(src, dst)</p>
<pre><code>功能：拷贝文件和状态信息
</code></pre><h4 id="作业需求："><a href="#作业需求：" class="headerlink" title="作业需求："></a>作业需求：</h4><pre><code>模拟实现一个ATM + 购物商城程序

额度 15000或自定义
实现购物商城，买东西加入 购物车，调用信用卡接口结账
可以提现，手续费5%
每月22号出账单，每月10号为还款日，过期未还，按欠款总额 万分之5 每日计息
支持多账户登录
支持账户间转账
记录每月日常消费流水
提供还款接口
ATM记录操作日志
提供管理接口，包括添加账户、用户额度，冻结账户等。
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python开发之路/">Python开发之路</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-s12-20160123-day04" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/23/s12-20160123-day04/" class="article-date">
      <time datetime="2016-01-23T07:30:00.000Z" itemprop="datePublished">2016-01-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/23/s12-20160123-day04/">pytho自动化开发 day04</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Author:@南非波波</p>
<p>课程大纲：</p>
<p>day03</p>
<p><a href="http://www.cnblogs.com/wupeiqi/articles/5133343.html" target="_blank" rel="external">http://www.cnblogs.com/wupeiqi/articles/5133343.html</a></p>
<p>day04</p>
<p><a href="http://www.cnblogs.com/alex3714/articles/5143440.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5143440.html</a></p>
<h3 id="一、迭代器-amp-amp-生成器"><a href="#一、迭代器-amp-amp-生成器" class="headerlink" title="一、迭代器 &amp;&amp; 生成器"></a>一、迭代器 &amp;&amp; 生成器</h3><h4 id="1-迭代器"><a href="#1-迭代器" class="headerlink" title="1.迭代器"></a>1.迭代器</h4><pre><code>迭代器是访问集合元素的一种方式。迭代器只能往前不能往后。迭代器对象从集合的第一个集合开始访问，直到所有的元素被访问完。
优点：不需要事先准备整个迭代过程中的所有元素
</code></pre><p>测试代码</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;

names = iter([&apos;swht&apos;,&apos;shen&apos;,&apos;jack&apos;])
print(names)
print(names.__next__())
print(names.__next__())
print(names.__next__())

返回结果：
    &lt;list_iterator object at 0x000000000114C7B8&gt;
    swht
    shen
    jack
</code></pre><h4 id="2-生成器"><a href="#2-生成器" class="headerlink" title="2.生成器"></a>2.生成器</h4><pre><code>定义：generator，一个函数调用时返回一个迭代器，那这个函数就叫做生成器。

作用：yield实现函数中断，并保存函数中断时的状态。中断后，程序可以继续执行下面的代码，而且可以随时可以回头再执行之前中断的函数。
    可以通过yield实现在单线程的情况下实现并发运算的效果
</code></pre><p>测试代码</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;

def money(num):
    while num &gt; 0:
        print(&quot;取款100元!&quot;)
        num -= 100
        yield 100
        print(&quot;你当前还有%s元&quot; % num)

ATM = money(500)
print(type(ATM))
print(ATM.__next__())
print(ATM.__next__())
print(&quot;吃包子....&quot;)
print(ATM.__next__())
print(ATM.__next__())

返回结果：
    &lt;class &apos;generator&apos;&gt;
    取款100元!
    100
    你当前还有400元
    取款100元!
    100
    吃包子....
    你当前还有300元
    取款100元!
    100
    你当前还有200元
    取款100元!
    100
</code></pre><p>实现异步：【生产者-消费者模型】</p>
<p>yield参数可以实现返回参数和接收参数，使用send方法可以将值传递到生成器中去</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;

import time
def consumer(name):
    print(&quot;%s 开始准备吃包子!&quot; % name)
    while True:
        baozi = yield #yield可以返回一个值，也可以接收一个值
        print(&quot;第[%s]波包子来了,被[%s]吃了!&quot; % (baozi,name))

def producer(name):
    c1 = consumer(&apos;swht&apos;)
    c2 = consumer(&apos;shen&apos;)
    c1.__next__()
    c2.__next__()
    print(&quot;==%s开始准备做包子!==&quot; % name)
    for i in range(10):
        time.sleep(1)
        print(&quot;**%s做了两个包子!**&quot; % name)
        c1.send(i) #使用send方法将值传递给yield
        c2.send(i)

producer(&apos;alex&apos;)
</code></pre><p>返回结果：</p>
<pre><code>swht 开始准备吃包子!
shen 开始准备吃包子!
==alex开始准备做包子!==
**alex做了两个包子!**
第[0]波包子来了,被[swht]吃了!
第[0]波包子来了,被[shen]吃了!
**alex做了两个包子!**
第[1]波包子来了,被[swht]吃了!
第[1]波包子来了,被[shen]吃了!
**alex做了两个包子!**
第[2]波包子来了,被[swht]吃了!
第[2]波包子来了,被[shen]吃了!
**alex做了两个包子!**
第[3]波包子来了,被[swht]吃了!
第[3]波包子来了,被[shen]吃了!
**alex做了两个包子!**
第[4]波包子来了,被[swht]吃了!
第[4]波包子来了,被[shen]吃了!
**alex做了两个包子!**
第[5]波包子来了,被[swht]吃了!
第[5]波包子来了,被[shen]吃了!
**alex做了两个包子!**
第[6]波包子来了,被[swht]吃了!
第[6]波包子来了,被[shen]吃了!
**alex做了两个包子!**
第[7]波包子来了,被[swht]吃了!
第[7]波包子来了,被[shen]吃了!
**alex做了两个包子!**
第[8]波包子来了,被[swht]吃了!
第[8]波包子来了,被[shen]吃了!
**alex做了两个包子!**
第[9]波包子来了,被[swht]吃了!
第[9]波包子来了,被[shen]吃了!
</code></pre><h3 id="二、装饰器"><a href="#二、装饰器" class="headerlink" title="二、装饰器"></a>二、装饰器</h3><pre><code>装饰器又叫语法塘
</code></pre><p>装饰器调用原理</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
def login(func):
    print(&quot;To passed!&quot;)
    return func

def home(name):
    print(&quot;Welcome [%s] to home page!&quot; % name)

def tv(name):
    print(&quot;Welcome [%s] to TV page!&quot; % name)

def moive(name):
    print(&quot;Welcome [%s] to Moive page!&quot; % name)

tv = login(tv)  #将tv函数的内存地址传递到login()函数中，然后将tv的内存地址返回并赋给变量tv
tv(&quot;swht&quot;) #变量调用相当于函数的调用
</code></pre><p>装饰器实现</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
def login(func): #程序执行时返回inner函数的内存地址
    def inner(*arg,**kwargs):
        print(&quot;To passed!&quot;)
        return func(*arg,**kwargs)
    return inner

def home(name):
    print(&quot;Welcome [%s] to home page!&quot; % name)

@login
def tv(name):
    print(&quot;Welcome [%s] to TV page!&quot; % name)

def moive(name):
    print(&quot;Welcome [%s] to Moive page!&quot; % name)
tv(&quot;swht&quot;)
</code></pre><p>返回结果：</p>
<pre><code>To passed!
Welcome [swht] to TV page!
</code></pre><p>多参数装饰器</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;

def Before(request,kargs):
    print(&apos;before&apos;)

def After(request,kargs):
    print(&apos;after&apos;)


def Filter(before_func,after_func):
    def outer(main_func):
        def wrapper(request,kargs):

            before_result = before_func(request,kargs)
            if(before_result != None):
                return before_result

            main_result = main_func(request,kargs)
            if(main_result != None):
                return main_result

            after_result = after_func(request,kargs)
            if(after_result != None):
                return after_result

        return wrapper
    return outer

@Filter(Before, After)
def Index(request,kargs):
    print(&apos;index&apos;)

Index(&quot;swht&quot;,&quot;123&quot;)
</code></pre><p>实现流程</p>
<pre><code>&apos;&apos;&apos;
1.程序运行，读取顺序 @Filter --&gt; Index()
2.@Filter运行机制：
    1）将Before, After传递给Filter()，执行outer()；
    2）将Index传递给outer()函数，执行wrapper()，返回outer；
    3）将Index()中的两个参数request,kargs传递给wrapper()函数，执行：
        1）执行before_func()即Before()并判断返回值，打印before
        2）执行main_func()即Index()并判断返回值，打印index
        3）执行after_func()即After()并判断返回值，打印after
3.程序结束
&apos;&apos;&apos;
</code></pre><h3 id="三、递归"><a href="#三、递归" class="headerlink" title="三、递归"></a>三、递归</h3><p>演示递归进出过程：【栈的实现：后进先出】</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;

def calc(n):
    print(n)
    if n/2 &gt; 1:
        res = calc(n/2)
        print(&apos;res:&apos;,res)
    print(&apos;n:&apos;,n)
    return n
calc(10)
&apos;&apos;&apos;
递归进入多少层，最后函数结束退出的时候就是退出多少层
&apos;&apos;&apos;
</code></pre><p>返回结果：</p>
<pre><code>10
5.0
2.5
1.25
n: 1.25
res: 1.25
n: 2.5
res: 2.5
n: 5.0
res: 5.0
n: 10
</code></pre><p>斐波那契数列</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;

def sum(arg1,arg2,stop):
    if arg1 == 0:
        print(arg1,arg2)
    arg3 = arg1 + arg2
    print(arg3)
    if arg3 &lt; stop:
        sum(arg2,arg3,stop)

sum(0,1,500)
</code></pre><p>返回结果：</p>
<pre><code>0 1
1
2
3
5
8
13
21
34
55
89
144
233
377
610
</code></pre><h3 id="四、二分查找"><a href="#四、二分查找" class="headerlink" title="四、二分查找"></a>四、二分查找</h3><pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
def binary_search(data_source,find_num):
    mid = int(len(data_source)/2)  #列表折中
    if len(data_source) &gt;= 1: #如果列表的长度值大于1，则递归
        if data_source[mid] &gt; find_num: #如果中间值大于查找值，这说明查找值在中间值的左侧
            print(&quot;%s\tis\tthe\tleft\tof \t%s&quot; % (find_num,data_source[mid]))
            binary_search(data_source[:mid],find_num)
        elif data_source[mid] &lt; find_num: #如果中间值小于查找值，这说明查找值在中间值的右侧
            print(&quot;%s\tis\tthe\tright\tof \t%s&quot; % (find_num,data_source[mid]))
            binary_search(data_source[mid:],find_num)
        else:
            print(&quot;已经查找到\t%s&quot; % find_num)
    else: #否则返回值，查找不到
        print(&quot;查不到该数值!&quot;)

if __name__ == &quot;__main__&quot;:
    data = list(range(1,90000))
    binary_search(data,65535)
</code></pre><h3 id="五、二维数组"><a href="#五、二维数组" class="headerlink" title="五、二维数组"></a>五、二维数组</h3><p>二维数组的概念是在c、c++等语言中出现并定义，在python没有数组概念，对应的则是列表。所以我们这里称为二维数组则是对二维列表的称谓。</p>
<p>需求：</p>
<pre><code>转换二维数组
初始列表：
    [0, 1, 2, 3]
    [0, 1, 2, 3]
    [0, 1, 2, 3]
    [0, 1, 2, 3]
    =================
转换后列表：
    [0, 0, 0, 0]
    [1, 1, 1, 1]
    [2, 2, 2, 2]
    [3, 3, 3, 3]
</code></pre><p>代码实现：</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
data = [[col for col in range(4)] for row in range(4)]
# for i in a:
#     print(i)
for col in range(4):
    for row in range(col,4):
        data[col][row],data[row][col] = data[row][col],data[col][row]
for i in data:
    print(i)
print(a)
</code></pre><p>改进型：</p>
<pre><code>data = [[col for col in range(4)] for row in range(4)]
for col in range(len(data)):
    for row in data[col]:
        data[col][row],data[row][col] = data[row][col],data[col][row]
for i in data:
    print(i)
</code></pre><h3 id="六、正则表达式"><a href="#六、正则表达式" class="headerlink" title="六、正则表达式"></a>六、正则表达式</h3><pre><code>熟悉Linux环境的朋友肯定熟悉，用来操作字符或者文本文件时操作的快速匹配语言。正则表达式是用于处理字符串的强大工具，拥有自己独特的语法以及一个独立的处理引擎，效率上可能不如str自带的方法，但功能十分强大。
</code></pre><p>语法：</p>
<p><strong>一般字符</strong></p>
<pre><code>匹配自身
示例：
import re

str1 = &apos;23434sjsjdd523^&amp;(csd#@52&apos;
print(re.match(&apos;abc&apos;,str1))
返回值为：None #说明此时没有匹配到。
print(re.match(&apos;23&apos;,str1))
返回值为：&lt;_sre.SRE_Match object; span=(0, 2), match=&apos;23&apos;&gt; #匹配到自身并返回类型
</code></pre><p><strong>.</strong></p>
<pre><code>匹配任意除换行符&apos;\n&apos;外的字符，在DOALL模式中也能匹配换行符。
示例：
import re

str1 = &apos;23434sjsjdd523^&amp;(csd#@52&apos;
print(re.match(&apos;.&apos;,str1))
返回结果：&lt;_sre.SRE_Match object; span=(0, 1), match=&apos;2&apos;&gt; #匹配到任意字符&apos;2&apos;
</code></pre><p><strong>\</strong></p>
<pre><code>转义字符，使后一个字符改变原来的意思。如果字符串中有字符*需要匹配，可以使用\*或者字符集[*]
示例：
a\\c  --&gt;a\c
</code></pre><p><strong>[…]</strong></p>
<pre><code>字符集(字符类).对应的位置可以是字符集中任意字符。字符集中的字符可以逐个列出，也可以给出范围，如[abc]或[a-c]。第一个字符如果是^则表示取反，如[^abc]表示不是abc的其他字符。
所有的特殊字符在字符集中都失去其原有的特殊含义。在字符集中如果要使用]、-或^，都可以在前面加上反斜杠，或把]、-放在第一个字符，把^放在非第一个字符。
示例：a[bcd]e --&gt;abe ace ade
</code></pre><p><strong>预定义字符：</strong><br><img src="http://i.imgur.com/6Kgqmam.png" alt=""></p>
<p><strong>数量词：</strong><br><img src="http://i.imgur.com/DDsI4dU.png" alt=""></p>
<p><strong>边界匹配：</strong><br><img src="http://i.imgur.com/Ga3Fdf1.png" alt=""></p>
<p><strong>逻辑、分组</strong><br><img src="http://i.imgur.com/1qVGb25.png" alt=""></p>
<p>正则表达式模块<strong>re</strong></p>
<pre><code>Python通过re模块提供对正则表达式的支持。使用re的一般步骤是先将正则表达式的字符串形式编译为Pattern实例，然后使用Pattern实例处理文本并获得匹配结果（一个Match实例），最后使用Match实例获得信息，进行其他的操作。
</code></pre><p>示例：</p>
<pre><code>import re

test1 = re.compile(r&apos;hello&apos;)  #使用re.compile编译成Pattern实例
test12 = test1.match(&apos;hello world!&apos;) #使用Pattern匹配文本，获得匹配结果，无法匹配时返回None

if test12:
    print(test12.group()) #使用test12获得分组信息
#输出  hello

#the same as top
m = re.match(r&apos;hello&apos;, &apos;hello world!&apos;)
print(m.group())
</code></pre><p><strong>match</strong></p>
<pre><code>match(string[,pos[endpos]])|re.match(patern,string[,flags]):
从string的pos下标处起尝试匹配pattern；如果pattern结束时仍可匹配，则返回一个Match对象；如果匹配过程中pattern无法匹配，或者匹配未结束就已到达endpos，则返回None。 
pos和endpos的默认值分别是0和len(sring);re.match()无法指定这两个参数，参数flags用于编译pattern时指定匹配模式。
（re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none.）
测试代码：
    m = re.match(&apos;hello&apos;, &apos;hello world!&apos;)
    print(m.group())
    返回值为：hello

    print(re.match(&apos;www&apos;,&apos;www.apicloud.com&apos;).span()) #在起始位置匹配
    print(re.match(&apos;com&apos;,&apos;www.apicloud.com&apos;)) #不在起始位置匹配

    返回结果：
    (0, 3)
    None

    import re

    line = &quot;Cats are smarter than dogs&quot;
    matchObj = re.match( r&apos;(.*) are (.*?) .*&apos;, line, re.M|re.I)
    #.* 匹配任意字符且匹配前一个字符0或无限次
    #.*? 匹配任意字符，且匹配前一个字符0或无限次，且匹配前一个字符0次或1次
    if matchObj:
       print(&quot;matchObj.group() : &quot;, matchObj.group())
       print(&quot;matchObj.group(1) : &quot;, matchObj.group(1))
       print(&quot;matchObj.group(2) : &quot;, matchObj.group(2))
    else:
       print(&quot;No match!!&quot;)

    返回结果：
    matchObj.group() :  Cats are smarter than dogs
    matchObj.group(1) :  Cats
    matchObj.group(2) :  smarter
</code></pre><p><strong>search</strong></p>
<pre><code>功能：re.search 扫描整个字符串并返回第一个成功的匹配
语法：re.search(pattern, string, flags=0)
参数：pattern 匹配的正则表达式
     string  要匹配的字符串
     flags   标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。

测试代码：
    import re
    print(re.search(&apos;www&apos;, &apos;www.apicloud.com&apos;).span())  # 在起始位置匹配
    print(re.search(&apos;com&apos;, &apos;www.apicloud.com&apos;).span())         # 不在起始位置匹配
    返回结果：
    (0, 3)
    (13, 16)

    import re
    line = &quot;Cats are smarter than dogs&quot;
    searchObj = re.search( r&apos;(.*) are (.*?) .*&apos;, line, re.M|re.I)
    if searchObj:
       print(&quot;searchObj.group() : &quot;, searchObj.group())
       print(&quot;searchObj.group(1) : &quot;, searchObj.group(1))
       print(&quot;searchObj.group(2) : &quot;, searchObj.group(2))
    else:
       print(&quot;Nothing found!!&quot;)

    #返回结果：
    # searchObj.group() :  Cats are smarter than dogs
    # searchObj.group(1) :  Cats
    # searchObj.group(2) :  smarter
</code></pre><p><strong>对比match和search</strong></p>
<pre><code>re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。
示例代码：
    import re
    line = &quot;Cats are smarter than dogs&quot;
    matchObj = re.match( r&apos;dogs&apos;, line, re.M|re.I)
    if matchObj:
       print(&quot;match --&gt; matchObj.group() : &quot;, matchObj.group())
    else:
       print(&quot;match --&gt; No match!!&quot;)

    searchObj = re.search( r&apos;dogs&apos;, line, re.M|re.I)
    if searchObj:
       print(&quot;search --&gt; searchObj.group() : &quot;, searchObj.group())
    else:
       print(&quot;search --&gt; No search!!&quot;)

    #返回结果：
    # match --&gt; No match!!
    # search --&gt; searchObj.group() :  dogs
</code></pre><p><strong>sub</strong></p>
<pre><code>功能：re.sub用户替换字符串中的匹配项
语法：re.sub(pattern, repl, string, max=0)
测试代码：
    import re
    phone = &quot;2004-959-559 # This is Phone Number&quot;
    # Delete Python-style comments
    num1 = re.sub(r&apos; .*$&apos;, &quot;&quot;, phone) #匹配&apos; &apos;空格到字符串默认的所有任意字符，删除
    print(&quot;Phone Num : &quot;, num1)  #Phone Num :  2004-959-559   最后一个字符后面没有空格
    num2 = re.sub(r&apos;#.*$&apos;, &quot;&quot;, phone) #匹配#到字符串默认的所有任意字符，删除
    print(&quot;Phone Num : &quot;, num2) #Phone Num :  2004-959-559  最后一个字符后面有一个空格

    # Remove anything other than digits
    num3 = re.sub(r&apos;\D&apos;, &quot;&quot;, phone) #匹配非数字字符，然后删除
    print(&quot;Phone Num : &quot;, num3) #Phone Num :  2004959559
</code></pre><p>作业：</p>
<pre><code>计算器开发

1. 实现加减乘除及拓号优先级解析
2. 用户输入 1 - 2 * ( (60-30 +(-40/5) * (9-2*5/3 + 7 /3*99/4*2998 +10 * 568/14 )) - (-4*3)/ (16-3*2) )等类似公式后，必须自己解析里面的(),+,-,*,/符号和公式，运算后得出结果，结果必须与真实的计算器所得出的结果一致

博客地址：http://www.cnblogs.com/songqingbo/p/5168125.html
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python开发之路/">Python开发之路</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-s12-20160116-day03" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/16/s12-20160116-day03/" class="article-date">
      <time datetime="2016-01-16T07:30:00.000Z" itemprop="datePublished">2016-01-16</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/16/s12-20160116-day03/">pytho自动化开发 day03</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Author:@南非波波</p>
<p>课程大纲：</p>
<p>day2<br><a href="http://www.cnblogs.com/wupeiqi/articles/5115190.html" target="_blank" rel="external">http://www.cnblogs.com/wupeiqi/articles/5115190.html</a></p>
<p>day3<br><a href="http://www.cnblogs.com/wupeiqi/articles/5133343.html" target="_blank" rel="external">http://www.cnblogs.com/wupeiqi/articles/5133343.html</a></p>
<h3 id="一、set集合"><a href="#一、set集合" class="headerlink" title="一、set集合"></a>一、set集合</h3><p>博客链接：<a href="http://www.cnblogs.com/songqingbo/p/5128066.html" target="_blank" rel="external">http://www.cnblogs.com/songqingbo/p/5128066.html</a></p>
<pre><code>优点：访问速度快；
     自带一套解决元素重复的解决方案
</code></pre><p><strong>测试程序</strong></p>
<pre><code>old_dict = {
    &quot;#1&quot;:{ &apos;hostname&apos;:&apos;c1&apos;, &apos;cpu_count&apos;: 2, &apos;mem_capicity&apos;: 80 },
    &quot;#2&quot;:{ &apos;hostname&apos;:&apos;c1&apos;, &apos;cpu_count&apos;: 2, &apos;mem_capicity&apos;: 80 },
    &quot;#3&quot;:{ &apos;hostname&apos;:&apos;c1&apos;, &apos;cpu_count&apos;: 2, &apos;mem_capicity&apos;: 80 },
}
new_dict = {
    &quot;#1&quot;:{ &apos;hostname&apos;:&apos;c1&apos;, &apos;cpu_count&apos;: 2, &apos;mem_capicity&apos;: 800 },
    &quot;#3&quot;:{ &apos;hostname&apos;:&apos;c1&apos;, &apos;cpu_count&apos;: 2, &apos;mem_capicity&apos;: 80 },
    &quot;#4&quot;:{ &apos;hostname&apos;:&apos;c2&apos;, &apos;cpu_count&apos;: 2, &apos;mem_capicity&apos;: 80 },
}

获取三个列表：
    1. 需要更新的列表 update_list
    2. 需要删除的列表 del_list
    3. 需要增加的列表 add_list

代码实现：
    #!/usr/local/env python3
    &apos;&apos;&apos;
    Author:@南非波波
    Blog:http://www.cnblogs.com/songqingbo/
    E-mail:qingbo.song@gmail.com
    &apos;&apos;&apos;

    old_dict = {
        &quot;#1&quot;:{ &apos;hostname&apos;:&apos;c1&apos;, &apos;cpu_count&apos;: 2, &apos;mem_capicity&apos;: 80 },
        &quot;#2&quot;:{ &apos;hostname&apos;:&apos;c1&apos;, &apos;cpu_count&apos;: 2, &apos;mem_capicity&apos;: 80 },
        &quot;#3&quot;:{ &apos;hostname&apos;:&apos;c1&apos;, &apos;cpu_count&apos;: 2, &apos;mem_capicity&apos;: 80 },
    }
    new_dict = {
        &quot;#1&quot;:{ &apos;hostname&apos;:&apos;c1&apos;, &apos;cpu_count&apos;: 2, &apos;mem_capicity&apos;: 800 },
        &quot;#3&quot;:{ &apos;hostname&apos;:&apos;c1&apos;, &apos;cpu_count&apos;: 2, &apos;mem_capicity&apos;: 80 },
        &quot;#4&quot;:{ &apos;hostname&apos;:&apos;c2&apos;, &apos;cpu_count&apos;: 2, &apos;mem_capicity&apos;: 80 },
    }

    #设置set
    old_set = set(old_dict.keys())
    new_set = set(new_dict.keys())

    #更新的set
    update_set = new_set.intersection(old_dict)
    delate_set = old_set.difference(update_set)
    add_set = new_set.difference(update_set)

    update_list = []
    del_list = []
    add_list = []
    # print(update_set)
    # print(delate_set)
    # print(add_set)
    for i in update_set:
        update_list.append({i:new_dict[i]})
        print(&apos;需要更新的列表:%s&apos; % update_list)

    for i in delate_set:
        del_list.append({i:old_dict[i]})
        print(&quot;需要删除的列表:%s&quot; % del_list)

    for i in add_set:
        add_list.append({i:new_dict[i]})
        print(&quot;需要增加的列表:%s&quot; % add_list)
</code></pre><h4 id="二、collection系列"><a href="#二、collection系列" class="headerlink" title="二、collection系列"></a>二、collection系列</h4><p>博客链接：<a href="http://www.cnblogs.com/songqingbo/p/5137785.html" target="_blank" rel="external">http://www.cnblogs.com/songqingbo/p/5137785.html</a></p>
<pre><code>不常用功能，需要进行模块功能导入:
    import collection
</code></pre><h4 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h4><p>常用方法测试：</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
import collections

obj = collections.Counter(&apos;sjndsjkdsdmslaladsldsldms&apos;)

print(&quot;输出字符出现的次数字典:&quot;)
for k,v in obj.items():
    print(&quot;{%s:%s}&quot; % (k,v))

print(&quot;输出每一个字符:&quot;) #遍历获取原始字符元素
for k in obj.elements():
    print(k)

print(&quot;输出前四个出现次数最多的字符:&quot;)
for k in obj.most_common(4):
    print(k)


输出结果：
    输出字符出现的次数字典:
    {s:7}
    {l:4}
    {m:2}
    {d:6}
    {k:1}
    {n:1}
    {j:2}
    {a:2}
    输出每一个字符:
    s
    s
    s
    s
    s
    s
    s
    l
    l
    l
    l
    m
    m
    d
    d
    d
    d
    d
    d
    k
    n
    j
    j
    a
    a
    输出前四个出现次数最多的字符:
    (&apos;s&apos;, 7)
    (&apos;d&apos;, 6)
    (&apos;l&apos;, 4)
    (&apos;m&apos;, 2)
</code></pre><p><strong>__missing__</strong></p>
<pre><code>功能：对于不存在的元素，返回计数器为0
import collections
c = collections.Counter(&apos;adjsdkskdjksjaksklklakl&apos;)
c.__missing__(5)
返回结果：0
</code></pre><p><strong>most_common</strong></p>
<pre><code>功能：获取出现次数的前几个字母排名
import collections
c = collections.Counter(&apos;adjsdkskdjksjaksklklakl&apos;)
c.most_common(3)
[(&apos;k&apos;, 7), (&apos;s&apos;, 4), (&apos;a&apos;, 3)]
c.most_common(8)
[(&apos;k&apos;, 7), (&apos;s&apos;, 4), (&apos;a&apos;, 3), (&apos;j&apos;, 3), (&apos;l&apos;, 3), (&apos;d&apos;, 3)]
</code></pre><p><strong>elements</strong></p>
<pre><code>功能：计数器中的所有元素，并且按照ascii码进行了排序
    返回一个迭代器。元素被重复了多少次，在该迭代器中就包含多少个该元素。所有元素按照字母序排序，个数小于1的元素不被包含。
import collections
c = collections.Counter(&apos;adjsdkskdjksjaksklklakl&apos;)
sorted(c.elements())
返回结果：[&apos;a&apos;, &apos;a&apos;, &apos;a&apos;, &apos;d&apos;, &apos;d&apos;, &apos;d&apos;, &apos;j&apos;, &apos;j&apos;, &apos;j&apos;, &apos;k&apos;, &apos;k&apos;, &apos;k&apos;, &apos;k&apos;, &apos;k&apos;, &apos;k&apos;, &apos;k&apos;,&apos;l&apos;, &apos;l&apos;, &apos;l&apos;, &apos;s&apos;, &apos;s&apos;, &apos;s&apos;, &apos;s&apos;]
</code></pre><p><strong>计数值的访问与缺失的键</strong></p>
<pre><code>功能：默认将计数器中所有的字符认为一个键，然后统计键出现的次数，即键值。如果键不存在则返回0.
import collections
c = collections.Counter(&apos;adjsdkskdjksjaksklklakl&apos;)
&gt;&gt;&gt; c[&apos;a&apos;]
3
&gt;&gt;&gt; c[&apos;b&apos;]
0
&gt;&gt;&gt; c[&apos;l&apos;]
3
</code></pre><p><strong>update &amp;&amp; subtract</strong></p>
<pre><code>功能：都是更新计数器，update是增加，subtract是减少
import collections
&gt;&gt;&gt; c = collections.Counter(&apos;which&apos;)
&gt;&gt;&gt; c[&apos;h&apos;]  #这里的h出现2次
2
&gt;&gt;&gt; c.update(&apos;with&apos;)
&gt;&gt;&gt; c
Counter({&apos;h&apos;: 3, &apos;i&apos;: 2, &apos;w&apos;: 2, &apos;t&apos;: 1, &apos;c&apos;: 1})
&gt;&gt;&gt; c[&apos;h&apos;] #这里则完成了update操作，h出现了3次
3

&gt;&gt;&gt; c.subtract(&apos;with&apos;) 
&gt;&gt;&gt; c
Counter({&apos;h&apos;: 2, &apos;c&apos;: 1, &apos;i&apos;: 1, &apos;w&apos;: 1, &apos;t&apos;: 0})
&gt;&gt;&gt; c[&apos;h&apos;] #这里完成subtract操作之后，h出现的次数又恢复到2次
2
</code></pre><p><strong>del</strong></p>
<pre><code>功能：删除键
import collections
&gt;&gt;&gt; c = collections.Counter(&apos;which&apos;)
&gt;&gt;&gt; c[&apos;h&apos;]  #这里的h出现2次
2
&gt;&gt;&gt; del c[&apos;h&apos;]
&gt;&gt;&gt; c
Counter({&apos;c&apos;: 1, &apos;i&apos;: 1, &apos;w&apos;: 1, &apos;t&apos;: 0})
&gt;&gt;&gt; c[&apos;h&apos;]  #del操作删除了键&apos;h&apos;
0
</code></pre><p><strong>copy</strong></p>
<pre><code>功能：浅拷贝
import collections
&gt;&gt;&gt; c = collections.Counter(&apos;which&apos;)
&gt;&gt;&gt; d = c.copy()
&gt;&gt;&gt; d
Counter({&apos;h&apos;: 2, &apos;c&apos;: 1, &apos;i&apos;: 1, &apos;w&apos;: 1})
&gt;&gt;&gt; id(c)
7150792
&gt;&gt;&gt; id(d)
6511976
</code></pre><p><strong>算术和集合操作</strong></p>
<pre><code>功能：+、-、&amp;、|操作也可以用于Counter。其中&amp;和|操作分别返回两个Counter对象各元素的最小值和最大值。需要注意的是，得到的Counter对象将删除小于1的元素。
</code></pre><p><img src="http://i.imgur.com/dpBUpJJ.png" alt=""></p>
<p><strong>常用操作</strong></p>
<pre><code>说明：Counter继承dict的所有方法，常用的操作列在下面，仅供参考
</code></pre><p><img src="http://i.imgur.com/5EmjmX2.png" alt=""></p>
<h4 id="有序字典orderedDict"><a href="#有序字典orderedDict" class="headerlink" title="有序字典orderedDict"></a>有序字典orderedDict</h4><pre><code>有序字典继承字典的一切属性，只是在顺序上是有序的。
d = collections.OrderedDict({&apos;name&apos;:&apos;swht&apos;,&apos;age&apos;:18})
print(d)
返回结果：OrderedDict([(&apos;name&apos;, &apos;swht&apos;), (&apos;age&apos;, 18)])
print(type(d))
返回结果：&lt;class &apos;collections.OrderedDict&apos;&gt;
</code></pre><p><strong>move_to_end</strong></p>
<pre><code>功能：将指定的键值对从开头移动到末尾。
d = collections.OrderedDict({&apos;name&apos;:&apos;swht&apos;,&apos;age&apos;:18,&apos;address&apos;:&apos;shandong&apos;,})
d.move_to_end(&apos;name&apos;)
print(d)
返回结果：OrderedDict([(&apos;age&apos;, 18), (&apos;address&apos;, &apos;shandong&apos;), (&apos;name&apos;, &apos;swht&apos;)])
</code></pre><p><strong>pop</strong></p>
<pre><code>功能：移除字典键值，并返回删除键值的values
d = collections.OrderedDict({&apos;name&apos;:&apos;swht&apos;,&apos;age&apos;:18,&apos;address&apos;:&apos;shandong&apos;,})
d.pop(&apos;address&apos;)
print(d)
返回结果：OrderedDict([(&apos;age&apos;, 18), (&apos;name&apos;, &apos;swht&apos;)])
</code></pre><p><strong>clear</strong></p>
<pre><code>功能：清空有序字典的值
d = collections.OrderedDict({&apos;name&apos;:&apos;swht&apos;,&apos;age&apos;:18,&apos;address&apos;:&apos;shandong&apos;,})
d.clear()
print(d)
返回结果：OrderedDict()
</code></pre><p><strong>keys,values,items</strong></p>
<pre><code>功能：继承字典的属性，获取字典的所有键和所有值
d = collections.OrderedDict({&apos;name&apos;:&apos;swht&apos;,&apos;age&apos;:18,&apos;address&apos;:&apos;shandong&apos;,})
l1 = d.keys()
l2 = d.values()
l3 = d.items()
print(l1,l2，l3)
返回结果：odict_keys([&apos;address&apos;, &apos;age&apos;, &apos;name&apos;]) odict_values([&apos;shandong&apos;, 18, &apos;swht&apos;]) odict_items([(&apos;age&apos;, 18), (&apos;name&apos;, &apos;swht&apos;), (&apos;address&apos;, &apos;shandong&apos;)])
</code></pre><h4 id="默认字典defaultdict"><a href="#默认字典defaultdict" class="headerlink" title="默认字典defaultdict"></a>默认字典defaultdict</h4><pre><code>defaultdict是对字典的类型的补充，他默认给字典的值设置了一个类型。创建一个默认字典，value值类型为列表.
dic = collections.defaultdict(list)
</code></pre><h4 id="可命名元组nametuple"><a href="#可命名元组nametuple" class="headerlink" title="可命名元组nametuple"></a>可命名元组nametuple</h4><pre><code>没有现成的类，用户需要自行创建相应的类
</code></pre><p>测试代码</p>
<pre><code>#!/usr/local/env python3
&apos;&apos;&apos;
Author:@南非波波
Blog:http://www.cnblogs.com/songqingbo/
E-mail:qingbo.song@gmail.com
&apos;&apos;&apos;
import collections
MytupleClass = collections.namedtuple(&quot;MytupleClass&quot;,[&apos;x&apos;,&apos;y&apos;,&apos;z&apos;])
obj = MytupleClass(11,22,33)
print(obj.x,obj.y,obj.z)
返回结果：11 22 33
总结：相当于在元组的基础上增加一个key，使其成为一个类字典的样子
</code></pre><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p><img src="http://i.imgur.com/DnEPoMR.png" alt=""></p>
<p>双向队列</p>
<pre><code>下面两种方法都可以创建双向列表，虽然在最初的引用的类不同，但最后创建的类型 都是collections.deque
#创建双向队列
import collections
d = collections.deque()
返回结果：&lt;class &apos;collections.deque&apos;&gt;

#but这样创建双向队列呢
import queue
p = queue.deque()
print(type(p))
#&lt;class &apos;collections.deque&apos;&gt;
</code></pre><p>单向队列</p>
<pre><code>#创建单向队列
import queue
q = queue.Queue()
print(type(q))
#&lt;class &apos;queue.Queue&apos;&gt;
</code></pre><h3 id="三、深浅拷贝"><a href="#三、深浅拷贝" class="headerlink" title="三、深浅拷贝"></a>三、深浅拷贝</h3><p>博客链接：<a href="http://www.cnblogs.com/songqingbo/p/5139015.html" target="_blank" rel="external">http://www.cnblogs.com/songqingbo/p/5139015.html</a></p>
<pre><code>#对于 数字 和 字符串 而言，赋值、浅拷贝和深拷贝无意义，因为其永远指向同一个内存地址
    import copy
    a1 = 22255
    a2 = 22255
    print(id(a1),id(a2)) #3428240 3428240

#对于字典、元祖、列表 而言，进行赋值、浅拷贝和深拷贝时，其内存地址的变化是不同的。

    import copy
    #字典
    n1 = {&quot;k1&quot;: &quot;wu&quot;, &quot;k2&quot;: 123, &quot;k3&quot;: [&quot;alex&quot;, 456]}
    ##赋值
    n2 = n1
    print(n1,n2) #{&apos;k1&apos;: &apos;wu&apos;, &apos;k2&apos;: 123, &apos;k3&apos;: [&apos;alex&apos;, 456]} {&apos;k1&apos;: &apos;wu&apos;, &apos;k2&apos;: 123, &apos;k3&apos;: [&apos;alex&apos;, 456]}
    print(id(n1),id(n2))  #6674440 6674440 #内存地址一样
    ##浅拷贝
    n3 = copy.copy(n1)
    print(n1,n3) #{&apos;k1&apos;: &apos;wu&apos;, &apos;k2&apos;: 123, &apos;k3&apos;: [&apos;alex&apos;, 456]} {&apos;k1&apos;: &apos;wu&apos;, &apos;k2&apos;: 123, &apos;k3&apos;: [&apos;alex&apos;, 456]}
    print(id(n1),id(n3)) #6936584 12067848  #浅拷贝第一级，内存地址相同
    print(id(n1[&apos;k3&apos;]),id(n3[&apos;k3&apos;])) #18741768 18741768
    ##深拷贝
    n4 = copy.deepcopy(n1)
    print(n1,n4) #{&apos;k3&apos;: [&apos;alex&apos;, 456], &apos;k2&apos;: 123, &apos;k1&apos;: &apos;wu&apos;} {&apos;k3&apos;: [&apos;alex&apos;, 456], &apos;k1&apos;: &apos;wu&apos;, &apos;k2&apos;: 123}
    print(id(n1),id(n4)) #6805512 11736904
    print(id(n1[&apos;k3&apos;]),id(n4[&apos;k3&apos;])) #7601032 7599496 #深拷贝第二级，内存地址也不相同

    #列表
    n1 = [1,2,3,4,5,[6,7],]
    ##赋值
    n2 = n1
    print(n1,n2) #[1, 2, 3, 4, 5, [6, 7]] [1, 2, 3, 4, 5, [6, 7]]
    print(id(n1),id(n2)) #18609928 18609928
    print(id(n1[5]),id(n2[5])) #18609544 18609544
    ##浅拷贝
    n3 = copy.copy(n1)
    print(n1,n3) #[1, 2, 3, 4, 5, [6, 7]] [1, 2, 3, 4, 5, [6, 7]]
    print(id(n1),id(n3)) #18609928 18232904
    print(id(n1[5]),id(n3[5])) #18609544 18609544
    ##深拷贝
    n4 = copy.deepcopy(n1)
    print(n1,n4) #[1, 2, 3, 4, 5, [6, 7]] [1, 2, 3, 4, 5, [6, 7]]
    print(id(n1),id(n4)) #18609928 18611848
    print(id(n1[5]),id(n4[5])) #18609544 18611912


    #元组
    一个小插曲：
        import copy
        n1 = (1,2,3,4,5,(6,7,),)
        #赋值
        n2 = n1
        print(&apos;n1:&apos;,n1,&apos;n2:&apos;,n2) #n1: (1, 2, 3, 4, 5, (6, 7)) n2: (1, 2, 3, 4, 5, (6, 7))
        print(id(n1),id(n2)) #10416584 10416584
        print(id(n1[5]),id(n2[5])) #18415304 18415304
        print(type(n1),type(2)) #&lt;class &apos;tuple&apos;&gt; &lt;class &apos;int&apos;&gt;
        #浅拷贝
        n3 = copy.copy(n1)
        print(&apos;n1:&apos;,n1,&apos;n3:&apos;,n3) #n1: (1, 2, 3, 4, 5, (6, 7)) n2: (1, 2, 3, 4, 5, (6, 7))
        print(id(n1),id(n3)) #10416584 10416584
        print(id(n1[5]),id(n3[5])) #18415304 18415304
        print(type(n1),type(3)) #&lt;class &apos;tuple&apos;&gt; &lt;class &apos;int&apos;&gt;
        #深拷贝
        n4 = copy.deepcopy(n1)
        print(&apos;n1:&apos;,n1,&apos;n4:&apos;,n4) #n1: (1, 2, 3, 4, 5, (6, 7)) n2: (1, 2, 3, 4, 5, (6, 7))
        print(id(n1),id(n4)) #10416584 10416584
        print(id(n1[5]),id(n4[5])) #18415304 18415304
        print(type(n1),type(5)) #&lt;class &apos;tuple&apos;&gt; &lt;class &apos;int&apos;&gt;
</code></pre><p><img src="http://i.imgur.com/SHmoN06.png" alt="">    </p>
<pre><code>再一个小插曲：
    import copy
    n1 = (1,2,3,4,5,[6,7,],)
    #赋值
    n2 = n1
    print(&apos;n1:&apos;,n1,&apos;n2:&apos;,n2) #(1, 2, 3, 4, 5, [6, 7]) n2: (1, 2, 3, 4, 5, [6, 7])
    print(id(n1),id(n2)) #11465160 11465160
    print(id(n1[5]),id(n2[5])) #18480456 18480456
    print(type(n1),type(2)) #&lt;class &apos;tuple&apos;&gt; &lt;class &apos;int&apos;&gt;
    #浅拷贝
    n3 = copy.copy(n1)
    print(&apos;n1:&apos;,n1,&apos;n3:&apos;,n3) #n1: (1, 2, 3, 4, 5, [6, 7]) n3: (1, 2, 3, 4, 5, [6, 7])
    print(id(n1),id(n3)) #11465160 11465160
    print(id(n1[5]),id(n3[5])) #18480456 18480456
    print(type(n1),type(3)) #&lt;class &apos;tuple&apos;&gt; &lt;class &apos;int&apos;&gt;
    #深拷贝
    n4 = copy.deepcopy(n1)
    print(&apos;n1:&apos;,n1,&apos;n4:&apos;,n4) #n1: (1, 2, 3, 4, 5, [6, 7]) n4: (1, 2, 3, 4, 5, [6, 7])
    print(id(n1),id(n4)) #11465160 18109736
    print(id(n1[5]),id(n4[5])) #18480456 18478920
    print(type(n1),type(5)) #&lt;class &apos;tuple&apos;&gt; &lt;class &apos;int&apos;&gt;
</code></pre><p><img src="http://i.imgur.com/DubYez7.png" alt=""><br>出现以上问题有可能跟下面的说法有关：<br><img src="http://i.imgur.com/XCsFOj6.png" alt=""></p>
<pre><code>案例代码

    import copy
    dic = {
        &quot;cpu&quot;:[80,],
        &quot;mem&quot;:[80,],
        &quot;disk&quot;:[80,],
    }

    print(&quot;old:&quot;,dic)
    new_dic1 = copy.copy(dic)
    new_dic1[&quot;cpu&quot;][0] = 50
    print(&quot;old:&quot;,dic)
    print(&quot;浅拷贝:&quot;,new_dic1)
    #返回结果：
    #old: {&apos;disk&apos;: [80], &apos;cpu&apos;: [80], &apos;mem&apos;: [80]}
    #浅拷贝: {&apos;disk&apos;: [80], &apos;cpu&apos;: [50], &apos;mem&apos;: [80]}

    new_dic2 = copy.deepcopy(dic)
    new_dic2[&quot;cpu&quot;][0] = 60
    print(&quot;old:&quot;,dic)
    print(&quot;深拷贝:&quot;,new_dic2)
    #返回结果
    # old: {&apos;mem&apos;: [80], &apos;cpu&apos;: [50], &apos;disk&apos;: [80]}
    # 深拷贝: {&apos;mem&apos;: [80], &apos;cpu&apos;: [60], &apos;disk&apos;: [80]}
</code></pre><h3 id="四、函数"><a href="#四、函数" class="headerlink" title="四、函数"></a>四、函数</h3><p>博客链接：<a href="http://www.cnblogs.com/songqingbo/p/5142957.html" target="_blank" rel="external">http://www.cnblogs.com/songqingbo/p/5142957.html</a></p>
<pre><code>定义：

    #!/usr/local/env python3
    &apos;&apos;&apos;
    Author:@南非波波
    Blog:http://www.cnblogs.com/songqingbo/
    E-mail:qingbo.song@gmail.com
    &apos;&apos;&apos;
    #定义函数，作用打印一个值
    def num_print():
        n = 456
        n += 1
        print(n)
使用：

    #函数调用
    num_print()
    #将f变量指向函数num_print，然后调用f()相当于调用num_print()
    f = num_print
    f()
</code></pre><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><pre><code>形参：函数中一个变量，在函数执行前无意义，在函数调用时必须指定实际参数。
实参：实际参数用户传递给所调用的函数的一个变量，其值赋值到函数中的形式参数，然后在函数中       作为变量参与函数执行
默认参数：必须放在最后
    def show(a1,a2,a3 = 5):
        print(a1,a2,a3)
    show(&quot;wu&quot;,&quot;ha&quot;)
    #返回结果：wu ha 5

指定参数：
    def show(a1,a2):
        print(a1,a2)
    show(a2=52,a1=8)
    #返回结果：8 52

动态参数：
    *arg --序列：自动转换成一个元组
        def show(*arg):
            print(arg,type(arg))
        show(23,45,67)
        #返回结果：(23, 45, 67) &lt;class &apos;tuple&apos;&gt;
        #or
        l = [23,45,67]
        show(*l)
        #返回结果：(23, 45, 67) &lt;class &apos;tuple&apos;&gt;

    **arg --字典：自动转换成一个字典
        #默认字典处理
        def show(**arg):
            print(arg,type(arg))
        show(name1=&apos;swht&apos;,name2=&apos;shen&apos;)
        #返回结果：{&apos;name1&apos;: &apos;swht&apos;, &apos;name2&apos;: &apos;shen&apos;} &lt;class &apos;dict&apos;&gt;
        #or
        d = {&quot;name1&quot;=&quot;swht&quot;,&quot;name2&quot;=&quot;shen&quot;}
        show(**d)
        #返回结果：{&apos;name1&apos;: &apos;swht&apos;, &apos;name2&apos;: &apos;shen&apos;} &lt;class &apos;dict&apos;&gt;

    *arg，**kwarges --序列和字典
        def show(*args,**kwargs):
            print(args,type(args),&apos;\n&apos;,kwargs,type(kwargs))
        show(23,45,67,82,name1=&apos;swht&apos;,name2=&apos;shen&apos;)
        #返回结果：(23, 45, 67, 82) &lt;class &apos;tuple&apos;&gt; 
                   {&apos;name2&apos;: &apos;shen&apos;, &apos;name1&apos;: &apos;swht&apos;} &lt;class &apos;dict&apos;&gt;        
        注意：使用*arg，**kwarges组合参数，必须是*arg在前，**kwarges在后，否则系统报错；另外实参在输入的时候也应该是按照上述顺序。
</code></pre><p><img src="http://i.imgur.com/NR71YzT.png" alt=""></p>
<p><strong>拓展：</strong></p>
<pre><code>def show(*args,**kwargs):
    print(args,type(args),&apos;\n&apos;,kwargs,type(kwargs))
l = [23,45,67,82]
d = {&apos;name1&apos;:&apos;swht&apos;,&apos;name2&apos;:&apos;shen&apos;}
show(l,d)
#返回结果：
([23, 45, 67, 82], {&apos;name1&apos;: &apos;swht&apos;, &apos;name2&apos;: &apos;shen&apos;}) &lt;class &apos;tuple&apos;&gt; 
{} &lt;class &apos;dict&apos;&gt;

def show(*args,**kwargs):
    print(args,type(args),&apos;\n&apos;,kwargs,type(kwargs))
l = [23,45,67,82]
d = {&apos;name1&apos;:&apos;swht&apos;,&apos;name2&apos;:&apos;shen&apos;}
show(*l,**d)
#返回结果：
(23, 45, 67, 82) &lt;class &apos;tuple&apos;&gt; 
{&apos;name2&apos;: &apos;shen&apos;, &apos;name1&apos;: &apos;swht&apos;} &lt;class &apos;dict&apos;&gt;

总结：
    函数可以传递元组、列表、字典等类型的值，由于带&apos;*&apos;、&apos;**&apos;的参数允许传入多个参数，所以在调用函数的时候默认将传入的参数识别到第一个*args。为了指定将参数传给某个args，这里需要对实参进行加&apos;*&apos;进行标识。

#list
show = &quot;Welcome to {0},there have too many {1}!&quot;
# reault = show.format(&quot;China&quot;,&quot;Foods&quot;)
l = [&quot;China&quot;,&quot;Foods&quot;]
reault = show.format(*l)
print(reault)
#返回结果：Welcome to China,there have too many Foods!

#dict
show = &quot;{name} is a {acter}!&quot;
# reault = show.format(name=&apos;swht&apos;,acter=&apos;teacher&apos;)
d = {&apos;name&apos;:&apos;swht&apos;,&apos;acter&apos;:&apos;teacher&apos;}
reault = show.format(**d)
print(reault)
#返回结果：swht is a teacher!
</code></pre><h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><p><img src="http://i.imgur.com/ICv89lK.jpg" alt=""></p>
<pre><code>    功能：简单函数的表示方式
    func = lambda a:a+1
    函数名  关键字 形参：函数体
    创建形式参数a，函数内容为a+1,并将结果return
测试代码：
    f = lambda x:x + 1
    ret = f(4)
    print(ret)
</code></pre><h4 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h4><p><img src="http://i.imgur.com/5so1j4e.png" alt=""></p>
<p><strong>abs()</strong></p>
<pre><code>功能：取绝对值
&gt;&gt;&gt; abs(5)
5
&gt;&gt;&gt; abs(-85)
85
</code></pre><p><strong>all(iterable)</strong></p>
<pre><code>功能：iterable所有的元素都为真,返回True，否则返回False
备注：为False的元素：0、&apos;&apos;、False或者空，其他的为True
参数：iterable为可迭代对象
all的功能可以使用下面的函数进行理解：
    def all(iterable):
    for element in iterable:
        if not element:
            return False
    return True
测试代码：
    all(&apos;test,hh&apos;)
    返回值为：True
    &gt;&gt;&gt; all([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;])  #列表list，元素都不为空或0
    True
    &gt;&gt;&gt; all([&apos;a&apos;, &apos;b&apos;, &apos;&apos;, &apos;d&apos;])  #列表list，存在一个为空的元素
    False
    &gt;&gt;&gt; all([0, 1，2, 3])  #列表list，存在一个为0的元素
    False              
    &gt;&gt;&gt; all((&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;))  #元组tuple，元素都不为空或0
    True
    &gt;&gt;&gt; all((&apos;a&apos;, &apos;b&apos;, &apos;&apos;, &apos;d&apos;))  #元组tuple，存在一个为空的元素
    False
    &gt;&gt;&gt; all((0, 1，2, 3))  #元组tuple，存在一个为0的元素
    False
    &gt;&gt;&gt; all([]) # 空列表
    True
    &gt;&gt;&gt; all(()) # 空元组
    True    
</code></pre><p><strong>any(iterable)</strong></p>
<pre><code>功能：iterable中元素只要有一个元素为真，则返回True,否则返回False(即iterable中所有的元素为假才会返回False)
参数：iterable为可迭代对象
any的功能可以使用下面的函数进行理解：
def any(iterable):
   for element in iterable:
       if  element:
           return False
   return True
测试代码：
    &gt;&gt;&gt; any([0,1,2,3]) #列表中仅有一个元素0为假，返回True
    True
    &gt;&gt;&gt; any([&apos; &apos;, &apos;  &apos;, &apos;&apos;, 0])
    True
    &gt;&gt;&gt; any([0]) #列表中元素只有一个元素0，返回False
    False
    &gt;&gt;&gt; any([0,&apos;&apos;])
    False
    &gt;&gt;&gt; any([0,&apos;&apos;,4])
    True    
    &gt;&gt;&gt; any((&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;))  #元组tuple，元素都不为空或0
    True
    &gt;&gt;&gt; any((&apos;a&apos;, &apos;b&apos;, &apos;&apos;, &apos;d&apos;))  #元组tuple，存在一个为空的元素
    True
    &gt;&gt;&gt; any((0, &apos;&apos;, False))  #元组tuple，元素全为0,&apos;&apos;,false
    False
    &gt;&gt;&gt; any([]) # 空列表
    False
    &gt;&gt;&gt; any(()) # 空元组
    False
</code></pre><p><strong>map(iterable)</strong></p>
<pre><code>功能：对可迭代函数&apos;iterable&apos;中的每一个元素应用‘function’方法，将结果作为list返回
参考链接：http://segmentfault.com/a/1190000000322433
测试代码：
    def add_100(num):
        return num + 100
    li1 = [25,26,27]
    ret = list(map(add_100,li1))
    print(ret)
    返回结果：[125, 126, 127]
</code></pre><p><img src="http://i.imgur.com/DVA1NXt.jpg" alt=""><br><img src="http://i.imgur.com/YqzknXX.jpg" alt=""></p>
<pre><code>python2.7                                python3.5
两个版本的对比，真是让人感到诧异，python3上执行map明明已经获取了值，但非得加个list进行展示，超乎寻常。

def abc(a,b,c):
    return a*1000 + b*100 + c*10

list1 = [11,22,33]
list2 = [44,55,66]
list3 = [77,88,99]
ret = list(map(abc,list1,list2,list3))
print(ret) #返回结果 [16170, 28380, 40590]
</code></pre><p><strong>ascii(object)</strong></p>
<pre><code>功能：该函数与python2中的repr()函数一样，返回一个可打印的对象字符串。当遇到非ascii码时，就会输出\x，\u或\U等字符来表示。例如：ascii(4) = int.__repr__(4) = repr(4)等号两边的方式是对等的。
测试代码：
    &gt;&gt;&gt; ascii(54)
    &apos;54&apos;
    &gt;&gt;&gt; ascii(&apos;o&apos;)
    &quot;&apos;o&apos;&quot;
    &gt;&gt;&gt; type(ascii(54))
    &lt;class &apos;str&apos;&gt;    
    &gt;&gt;&gt; print(ascii(10), ascii(9000000), ascii(&apos;b\31&apos;), ascii(&apos;0x\1000&apos;))
        10 9000000 &apos;b\x19&apos; &apos;0x@0&apos;
</code></pre><p><strong>bin()</strong></p>
<pre><code>功能：将整数转换为二进制字符串
&gt;&gt;&gt; bin(56)
&apos;0b111000&apos;
&gt;&gt;&gt; bin(100)
&apos;0b1100100&apos;
注意：如果bin()函数的实际参数不是一个整数,则该该实参(由类创建的对象)返回值必须是整数型
如：
&gt;&gt;&gt; class myType:
...     def __index__(self):
...             return 56
...
&gt;&gt;&gt; myvar = myType()
&gt;&gt;&gt; bin(myvar)
&apos;0b111000&apos;
</code></pre><p><strong>bool()</strong></p>
<pre><code>功能：获取对象的bool值
bool(0) #False
bool(5) #True
bool(&apos;&apos;) #False
#为假的元素：0 none 空列表 空字典 空元组 空字符串
</code></pre><p><strong>bytearray()</strong></p>
<pre><code>功能：转成字符字典。Bytearray类型是一个可变的序列，并且序列中的元素的取值范围为 [0 ,255]。
&gt;&gt;&gt; a = bytearray([5,8])
&gt;&gt;&gt; a[0]
5
&gt;&gt;&gt; a[1]
8
&gt;&gt;&gt; a
bytearray(b&apos;\x05\x08&apos;)
</code></pre><p><strong>bytes()</strong></p>
<pre><code>    功能：返回一个新的数组对象，这个数组不能对数组元素进行修改，每个元素的取值范围为[0 ,255]
    测试代码：
    bytes(iterable_of_ints) 
        &gt;&gt;&gt; b = bytes((5,8,6,8))
        &gt;&gt;&gt; print(b)
        b&apos;\x05\x08\x06\x08&apos;
    bytes(string, encoding[, errors])     
        &gt;&gt;&gt; bytes(&apos;sdjsd&apos;,encoding=&apos;utf-8&apos;)
        b&apos;sdjsd&apos;
    bytes(bytes_or_buffer)  ？
    bytes(int) 
        &gt;&gt;&gt; bytes(5)
        b&apos;\x00\x00\x00\x00\x00&apos;
    bytes()  
        &gt;&gt;&gt; bytes()
        b&apos;&apos;

总结：（参考：http://blog.csdn.net/caimouse/article/details/40860827）
    bytes函数与bytearray函数主要区别是bytes函数产生的对象的元素不能修改，而bytearray函数产生的对象的元素可以修改。因此，除了可修改的对象函数跟bytearray函数不一样之外，其它使用方法全部是相同的。最后它的参数定义方式也与bytearray函数是一样的。
</code></pre><p><strong>callable()</strong></p>
<pre><code>功能：判断函数或者对象是否可执行
&gt;&gt;&gt; callable(5)
False
&gt;&gt;&gt; callable(0)
False
&gt;&gt;&gt; callable(&apos;&apos;)
False
&gt;&gt;&gt; callable(int())
False
&gt;&gt;&gt; callable(lambda x:x+1)
True
</code></pre><p><strong>chr()</strong></p>
<pre><code>功能：参数为一个整型数字，返回值对应ASCII码的字符
&gt;&gt;&gt; chr(5)
&apos;\x05&apos;
&gt;&gt;&gt; chr(115)
&apos;s&apos;
&gt;&gt;&gt; chr(56)
&apos;8&apos;
</code></pre><p><strong>ord()</strong> </p>
<pre><code>功能：返回一个字符的ASCII码值
&gt;&gt;&gt; ord(&apos;s&apos;)
115
&gt;&gt;&gt; ord(&apos;5&apos;)
53
</code></pre><p><strong>classmethod()</strong></p>
<pre><code>功能：classmethod是用来指定一个类的方法为类方法，没有此参数指定的类的方法为实例方法
    &gt;&gt;&gt; class C: #定义一个类
    ...     @classmethod  #声明为类方法，不经过实例化就可以直接调用
    ...     def f(self): #定义一个函数（类的方法）
    ...             print &quot;This is a class method&quot;
    ...
    &gt;&gt;&gt; C.f()  #通过类调用函数
    This is a class method
    &gt;&gt;&gt; c = C()
    &gt;&gt;&gt; c.f()
    This is a class method
    &gt;&gt;&gt; class D:
    ...     def f(self):
    ...             print &quot; This is not a class method &quot;
    ...
    &gt;&gt;&gt; D.f()  #没有经过@classmethod 声明的类方法，必须经过实例化才能被调用
    Traceback (most recent call last):
      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
    TypeError: unbound method f() must be called with D instance as first argument (got nothing instead)
    &gt;&gt;&gt; d = D()
    &gt;&gt;&gt; d.f()
    This is not a class method
</code></pre><p><strong>staticmethod()</strong></p>
<pre><code>    功能：类的静态方法，只能在类内部使用。经过静态类方法声明的类，在调用的时候不需要进行实例化

总结：对比classmethod()和staticmethod()

    静态方法：@staticmethod()
        class Foo(object):
            str = &quot;I&apos;m a static method.&quot;
            def bar():
                print(Foo.str)
            bar = staticmethod(bar)

        Foo.bar()
    返回结果：I&apos;m a static method. 

    类方法：@classmethod()
        class Foo(object):
            str = &quot;I&apos;m a static method.&quot;
            def bar(cls):
                print(cls.str)
            bar = classmethod(bar)
        Foo.bar()
    返回结果：I&apos;m a static method. 
较简单的操作代码：

    静态方法：@staticmethod()
        class Foo:
            str = &quot;I&apos;m a static method.&quot;
            @staticmethod
            def bar():
                print(Foo.str)
        Foo.bar() 
    返回结果：I&apos;m a static method. 

    类方法：@classmethod()
        class Foo:
            str = &quot;I&apos;m a static method.&quot;
            @classmethod
            def bar(cls):
                print(cls.str )
        Foo.bar()
    返回结果：I&apos;m a static method.
</code></pre><p><strong>compile()、eval()、exec()</strong></p>
<pre><code>功能：compile语句是从type类型中将str里面的语句创建成代码对象。
    compile语句的目的是提供一次性的字节码编译，就不用在以后的每次调用中重新进行编译了
语法：compile( str, file, type )
    eveal_code = compile(&apos;1+2&apos;,&apos;&apos;,&apos;eval&apos;)
    &gt;&gt;&gt;eveal_code
    返回结果：&lt;code object &lt;module&gt; at 0x01555D40, file &quot;&quot;, line 1&gt;
    &gt;&gt;&gt;eval(eveal_code)
    返回结果：3

    single_code = compile( &apos;print(&quot;apicloud.com&quot;)&apos;, &apos;&apos;, &apos;single&apos; )
    &gt;&gt;&gt; single_code
    返回结果：&lt;code object &lt;module&gt; at 0x01555B10, file &quot;&quot;, line 1&gt;
    &gt;&gt;&gt; exec(single_code)
    返回结果：apicloud.com
</code></pre><p><strong>complex()</strong></p>
<pre><code>功能：创建一个值为real + imag * j的复数或者转化一个字符串或数为复数。如果第一个参数为字符串，则不需要指定第二个参数。
参数real: int, long, float或字符串；
参数imag: int, long, float
&gt;&gt;&gt;complex()
0j
#数字
&gt;&gt;&gt; complex(1,2)
(1+2j)
#当做字符串处理
&gt;&gt;&gt; complex(&apos;1&apos;)
(1+0j)
#注意：这个地方在“+”号两边不能有空格，也就是不能写成&quot;1 + 2j&quot;，应该是&quot;1+2j&quot;，否则会报错
&gt;&gt;&gt; complex(&apos;1+2j&apos;)
(1+2j)
</code></pre><p><strong>delattr()</strong></p>
<pre><code>参考链接：http://www.cnblogs.com/zhangjing0502/archive/2012/05/16/2503702.html
功能：删除object对象名为name的属性
语法：delattr(object,name) 
参数object：对象。
参数name：属性名称字符串。

&gt;&gt;&gt; class Person:
...     def __init__(self, name, age):
...             self.name = name
...             self.age = age
...
&gt;&gt;&gt; tom = Person(&quot;Tom&quot;, 35)
&gt;&gt;&gt; dir(tom)
[&apos;__doc__&apos;, &apos;__init__&apos;, &apos;__module__&apos;, &apos;age&apos;, &apos;name&apos;]
&gt;&gt;&gt; delattr(tom, &quot;age&quot;)
&gt;&gt;&gt; dir(tom)
[&apos;__doc__&apos;, &apos;__init__&apos;, &apos;__module__&apos;, &apos;name&apos;]
</code></pre><p><strong>getattr()</strong></p>
<pre><code>功能：用于返回一个对象属性，或者方法
class A:   
    def __init__(self):   
        self.name = &apos;zhangjing&apos;  
　　  #self.age=&apos;24&apos;
    def method(self):   
        print(&quot;method print&quot;)  

Instance = A()   
print(getattr(Instance , &apos;name&apos;, &apos;not find&apos;)) #如果Instance 对象中有属性name则打印self.name的值，否则打印&apos;not find&apos;
print(getattr(Instance , &apos;age&apos;, &apos;not find&apos;))  #如果Instance 对象中有属性age则打印self.age的值，否则打印&apos;not find&apos;
print(getattr(a, &apos;method&apos;, &apos;default&apos;))  
#如果有方法method，否则打印其地址，否则打印default   
print(getattr(a, &apos;method&apos;, &apos;default&apos;)()) 
#如果有方法method，运行函数并打印None否则打印default

li=[&quot;swht&quot;,&quot;shen&quot;]
getattr(li,&quot;pop&quot;)
返回结果：&lt;built-in method pop of list object at 0x01AFDA80&gt;
</code></pre><p><strong>setattr()</strong>    </p>
<pre><code>功能：参数是一个对象,一个字符串和一个任意值。字符串可能会列出一个现有的属性或一个新的属性。这个函数将值赋给属性的。该对象允许它提供。
语法：setattr(object, name, value)    
setattr(x,“foobar”,123)相当于x.foobar = 123
</code></pre><p><strong>hasattr()</strong></p>
<pre><code>功能：用于确定一个对象是否具有某个属性
语法：hasattr(object, name) -&gt; bool
    判断object中是否有name属性，返回一个布尔值
li=[&quot;swht&quot;,&quot;shen&quot;]
hasattr(li,&apos;append&apos;)
返回结果：True
</code></pre><p><strong>dict()</strong></p>
<pre><code>功能：字典定义函数，可以创建一个字典，也可以将其他类型（列表、元组、字符串）转换成字典类型
定义：
    dict1 = dict(one = 1, two = 2, a = 3)
    prin（dict1)
    {&apos;one&apos;: 1, &apos;a&apos;: 3, &apos;two&apos;: 2}
类型转换：
    list1 = [&apos;name&apos;,&apos;age&apos;,]
    list2 = [&apos;swht&apos;,18]
    dict(zip(list1,list2))
    返回结果：{&apos;name&apos;: &apos;swht&apos;, &apos;age&apos;: 18}

    new_list= [[&apos;key1&apos;,&apos;value1&apos;],[&apos;key2&apos;,&apos;value2&apos;],[&apos;key3&apos;,&apos;value3&apos;]]
    dict(new_list)
    返回结果：{&apos;key3&apos;: &apos;value3&apos;, &apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;}
</code></pre><p><strong>dir()</strong></p>
<pre><code>功能：查看函数或模块内的操作方法都有什么，输出的是方法列表。
如dir(int)可以直接获取int的所有方法，返回的类型是一个列表
</code></pre><p><strong>divmod()</strong></p>
<pre><code>功能：divmod(a,b)方法返回的是a//b（除法取整）以及a对b的余数
&gt;&gt;&gt; divmod(2,5)
(0, 2)
&gt;&gt;&gt; divmod(12,5)
(2, 2)
</code></pre><p><strong>enumerate()</strong></p>
<pre><code>功能：获取字典的索引值并指定开始值
li = [&apos;swht&apos;,&apos;shen&apos;,&apos;test&apos;]
for i,k in enumerate(li,3): #遍历列表，索引值从3开始
    print(i,k)
#返回结果
3 swht
4 shen
5 test
</code></pre><p><strong>filter()</strong></p>
<pre><code>参考链接：http://www.cnblogs.com/fangshenghui/p/3445469.html
功能：filter(function, sequence)对于队列中的item依次被function处理
def fun(item):
    if item != 4:
        return item
list1 = [5,4,8]
print(list(filter(fun,list1)))
返回结果：[4, 8]
总结：相当于一个过滤函数
</code></pre><p><strong>frozenset()</strong></p>
<pre><code>参考：http://blog.csdn.net/caimouse/article/details/42042051
功能：本函数是返回一个冻结的集合
l = [1, 2, 3, 4, 5, 6, 6, 7, 8, 8, 9]  
print(len(l), l)  
set = frozenset(l)  
print(len(set), set) 
返回结果：11 [1, 2, 3, 4, 5, 6, 6, 7, 8, 8, 9]
         9 frozenset({1, 2, 3, 4, 5, 6, 7, 8, 9})
总结：所谓冻结就是这个集合不能再添加或删除任何集合里的元素。因此与集合set的区别，就是set是可以添加或删除元素，而frozenset不行。frozenset的主要作用就是速度快，它是使用hash算法实现。参数iterable是表示可迭代的对象，比如列表、字典、元组等等
</code></pre><p><strong>locals()、globals()</strong></p>
<pre><code>功能：基于字典的访问局部和全局变量的方式
locals 是只读的，globals 不是
关于名字空间的相关说明请移步参考：http://blog.csdn.net/scelong/article/details/6977867
</code></pre><p><strong>hash()</strong></p>
<pre><code>功能：输出对象的hash值
&gt;&gt;&gt; hash(8)
8
&gt;&gt;&gt; hash(&apos;sd&apos;)
-584109415
&gt;&gt;&gt; hash(&apos;99&apos;)
-1356598271
&gt;&gt;&gt; hash(&apos;asds&apos;)
-1179125483
</code></pre><p><strong>help()</strong></p>
<pre><code>功能：查看函数或模块用途的详细说明
使用方法：help(object)
</code></pre><p><strong>类型转换</strong></p>
<pre><code>int(x [,base ])         将x转换为一个整数    
long(x [,base ])        将x转换为一个长整数    
float(x )               将x转换到一个浮点数    
complex(real [,imag ])  创建一个复数    
str(x )                 将对象 x 转换为字符串    
repr(x )                将对象 x 转换为表达式字符串    
eval(str )              用来计算在字符串中的有效Python表达式,并返回一个对象    
tuple(s )               将序列 s 转换为一个元组    
list(s )                将序列 s 转换为一个列表    
chr(x )                 将一个整数转换为一个字符    
unichr(x )              将一个整数转换为Unicode字符    
ord(x )                 将一个字符转换为它的整数值    
hex(x )                 将一个整数转换为一个十六进制字符串    
oct(x )                 将一个整数转换为一个八进制字符串
</code></pre><p><strong>id()</strong></p>
<pre><code>功能：获取对象的内存地址
id(object)
</code></pre><p><strong>input()</strong></p>
<pre><code>功能:获取用户的输入信息
input(&quot;请输入你的名字:&quot;)
&gt;&gt;&gt;请输入你的名字:swht
swht
</code></pre><p><strong>isinstance()</strong></p>
<pre><code>功能：判断对象类型
isinstance(5,int)
返回结果:True
</code></pre><p><strong>issubclass()</strong></p>
<pre><code>功能：本函数用来判断类参数class是否是类型参数classinfo的子类
class Line:  
    pass  
class RedLine(Line):  
    pass  

class Rect:  
    pass  

print(issubclass(RedLine, Line))  #返回True  Redline是Line的子类
print(issubclass(Rect, Line))  #返回False  
</code></pre><p><strong>iter()</strong></p>
<pre><code>功能：创建一个迭代器
for i in iter((1,2,4,5,6,7,)):
    print(i)
返回结果：1 2 4 5 6 7 #循环遍历元组
</code></pre><p><strong>len()</strong></p>
<pre><code>功能：获取字符串的长度
len(str)
</code></pre><p><strong>max()</strong></p>
<pre><code>功能：返回所有整数中最大的一个数
max(5,6,8,7) 
返回结果：8
</code></pre><p><strong>memoryview()</strong></p>
<pre><code>功能：本函数是返回对象obj的内存查看对象
&gt;&gt;&gt; v = memoryview(b&apos;abc123&apos;)
&gt;&gt;&gt; print(v[1])
98
&gt;&gt;&gt; print(v[0])
97
&gt;&gt;&gt; print(v[2])
import struct  
buf = struct.pack(&quot;i&quot;*12, *list(range(12)))  
x = memoryview(buf)  
y = x.cast(&apos;i&apos;, shape=[2,2,3])  
print(y.tolist()) 
返回结果：[[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]

总结：所谓内存查看对象，就是对象符合缓冲区协议的对象，为了给别的代码使用缓冲区里的数据，而不必拷贝，就可以直接使用。参考链接：http://blog.csdn.net/caimouse/article/details/43083627
</code></pre><p><strong>sorted()</strong></p>
<pre><code>功能：排序
sorted([5, 2, 3, 1, 4])
[1, 2, 3, 4, 5]
</code></pre><p><strong>sum()</strong></p>
<pre><code>功能：返回整数数字的和
sum([1,5,8]) #参数是一个list
返回结果：14
</code></pre><p><strong>super()</strong></p>
<pre><code>功能：用来解决多重继承问题
</code></pre><p><strong>type()</strong></p>
<pre><code>功能：获取对象的类型
type(object)
</code></pre><p><strong>vars()</strong></p>
<pre><code>功能：本函数是实现返回对象object的属性和属性值的字典对象
&gt;&gt;&gt; class Foo:
...     a = 1
...
&gt;&gt;&gt; print(vars(Foo))
{&apos;a&apos;: 1, &apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;Foo&apos; objects&gt;, &apos;__doc__&apos;: None, &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;Foo&apos; objects&gt;, &apos;__module__&apos;: &apos;__main__&apos;}

总结：如果默认不输入参数，就打印当前调用位置的属性和属性值，相当于locals()的功能。如果有参数输入，就只打印这个参数相应的属性和属性值。参考：http://blog.csdn.net/caimouse/article/details/46489079
</code></pre><p><strong>zip()</strong></p>
<pre><code>功能：zip函数接受任意多个（包括0个和1个）序列作为参数，返回一个tuple列表
&gt;&gt;&gt; x = [1,2,3,]
&gt;&gt;&gt; y = [4,5,6,]
&gt;&gt;&gt; z = [7,8,9,]
&gt;&gt;&gt; xyz = zip(x,y,z)
&gt;&gt;&gt; print(xyz)
&lt;zip object at 0x00FBD968&gt;
&gt;&gt;&gt; print(list(xyz))
[(1, 4, 7), (2, 5, 8), (3, 6, 9)]
</code></pre><p>random</p>
<pre><code>功能:产生随机数
import random
random.randint(1,99) #从1-99中产生随机数
</code></pre><p><strong>import</strong>()</p>
<pre><code>功能：查看模块所在的位置
 __import__(&apos;random&apos;) #参数为一个字符串
&lt;module &apos;random&apos; from &apos;D:\\Program Files\\Python\\Python35\\python35.zip\\random.pyc&apos;&gt;
</code></pre><h4 id="open-函数"><a href="#open-函数" class="headerlink" title="open()函数"></a>open()函数</h4><p>博客参考：<a href="http://www.cnblogs.com/songqingbo/p/5102618.html" target="_blank" rel="external">http://www.cnblogs.com/songqingbo/p/5102618.html</a></p>
<p><strong>read()</strong></p>
<pre><code>功能：读取文件中的所有内容，返回的类型是字节
</code></pre><p><strong>readline()</strong></p>
<pre><code>功能：读取文件中的一行数据。返回的类型是字节
</code></pre><p><strong>readlines()</strong></p>
<pre><code>功能：读取文件中的所有内容，返回的类型是list
</code></pre><p><strong>tell()</strong> </p>
<pre><code>功能：查看当前指针位置，返回值类型为整数
</code></pre><p><strong>seek()</strong></p>
<pre><code>功能：指定当前指针位置


files = open(&apos;test.txt&apos;,&apos;r&apos;,encoding=&apos;utf-8&apos;)
files.seek(5)
print(files.read()) #读取指为直接切割针5后面的所有字符
files.truncate() #获取指针5之前的所有字符然后写到原来的文件（或者可以理解）
files.close()
</code></pre><p><strong>扩展</strong></p>
<pre><code>读二进制文件：

    input = open(&apos;data&apos;,&apos;rb&apos;)

读取所有内容：

    f = open(&apos;test.txt&apos;,&apos;r&apos;)
    try:
        all_txt_view = f.read()
    finally:
        f.close()

读取固定字节：

    f = open(&apos;test.txt&apos;,&apos;rb&apos;)
    try:
        while True:
            chunk = f.read(100)
            if not chunk:
                break
            pass
    finally:
        f.close()

读每行：

    list_of_all_the_lines = f.readlines()

如果文件是文本文件，还可以直接遍历文件对象获取每行：

    for line in f:
        print(line)

写文件写文本文件

    output = open(&apos;data&apos;,&apos;w&apos;)

写入多行：

    f.writeline(list_of_text_string)
</code></pre><p>作业：</p>
<pre><code>作业连接：http://www.cnblogs.com/wupeiqi/articles/4950799.html
1. 用户输入一个字符串，将其转换成字典 使用json
2. 增加一条记录
3. （可选）删除一条
4. （可选）线上文件修改


global       
        log 127.0.0.1 local2
        daemon
        maxconn 256
        log 127.0.0.1 local2 info
defaults
        log global
        mode http
        timeout connect 5000ms
        timeout client 50000ms
        timeout server 50000ms
        option  dontlognull

listen stats :8888
        stats enable
        stats uri       /admin
        stats auth      admin:1234

frontend oldboy.org
        bind 0.0.0.0:80
        option httplog
        option httpclose
        option  forwardfor
        log global
        acl www hdr_reg(host) -i www.oldboy.org
        use_backend www.oldboy.org if www

backend test.oldboy.org
        server 100.1.7.9 100.1.7.9 weight 20 maxconn 3000
        #server 100.1.7.9 100.1.7.999 weight 20 maxconn 3000


backend buy.oldboy.org
        server 100.1.7.90 100.1.7.90 weight 20 maxconn 3000

字典：        
{&quot;backend&quot;: &quot;test.oldboy.org&quot;,
 &quot;record&quot;:{
        &quot;server&quot;: &quot;100.1.7.999&quot;,
        &quot;weight&quot;: 20,
        &quot;maxconn&quot;: 30
  }
}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python开发之路/">Python开发之路</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-s12-20160109-day02" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/09/s12-20160109-day02/" class="article-date">
      <time datetime="2016-01-09T07:30:00.000Z" itemprop="datePublished">2016-01-09</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/09/s12-20160109-day02/">pytho自动化开发 day02</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Author:@南非波波</p>
<p>作者注：</p>
<pre><code>经过第一天的学习以及后续的代码练习,给自己一个约定的代码风格、格式：
1. 模块名：
    模块应该使用尽可能短的、全小写命名，可以在模块命名时使用下划线以增强可读性。
    例如：
        login_shop.py
2. 类名定义：
    由于类名要求首字母必须大写，所以这样定义：
    class MyFristClass:  # 类名有三个单词组成，分别首字母大写
        def __init__(self,a):
            pass
3. 函数名定义：
    普通函数：
        选择使用字母小写，单词直接使用下划线_分割：
            shop_mag(users):
                pass
4. 变量名定义：
    全局变量名：
        字母全大写： SHOPLIST
    普通变量名：
        字母小写，单词分割选择使用首字母大写： shopUsers
</code></pre><p>以上规范并不是必须，但是作为个人的编程习惯而言，是一种很好的养成约束。</p>
<p>课程大纲地址： <a href="http://www.cnblogs.com/wupeiqi/articles/5115190.html" target="_blank" rel="external">http://www.cnblogs.com/wupeiqi/articles/5115190.html</a></p>
<h3 id="python知识拾忆："><a href="#python知识拾忆：" class="headerlink" title="python知识拾忆："></a>python知识拾忆：</h3><p>Python2.x与Python3.x关于dict.keys()返回值的类型对比：</p>
<p><img src="http://i.imgur.com/tieH6Vh.png" alt=""></p>
<h4 id="一、python种类"><a href="#一、python种类" class="headerlink" title="一、python种类"></a>一、python种类</h4><p>关于Python的一些版本内部执行的一些原理。从原理上来看待执行快慢的类型，从而选择自己需要的去学习。目前而言，最火的就是cpython了，这也是官方版本的Python。后面出现的pypy渐渐崭露头角，用银角大王的话讲：这货日后指定会火…</p>
<pre><code>1. cpython  使用c解释器生产.pyc(字节码)，然后转换成机器码，最后到cpu
2. javapython java解释器--&gt;字节码--&gt;机器码--&gt;cpu
3. IronPython C#解释器--&gt;字节码 --&gt; 机器码--&gt; cpu
4. pypy  内部使用自己的解释器编译成字节码--&gt;机器码.最后在外部执行的时候直接是机器码，速度要快
</code></pre><p>银角大王推荐阅读书：<strong>《python源码剖析》</strong></p>
<h4 id="二、字节码"><a href="#二、字节码" class="headerlink" title="二、字节码"></a>二、字节码</h4><p>在Python内部字节码直接的转换过程如图：</p>
<p><img src="http://i.imgur.com/U6KPbcR.png" alt=""></p>
<pre><code>python中进行字节码之间的转换流程大概是这样的：字节码类型转换从utf-8转换成gbk类型，首先需要执行解码变成Unicode类型，然后再由Unicode类型编码成gbk类型。[图片来源：银角大王课堂笔记]
</code></pre><h4 id="三、字符串"><a href="#三、字符串" class="headerlink" title="三、字符串"></a>三、字符串</h4><p>博客链接：<a href="http://www.cnblogs.com/songqingbo/p/5126957.html" target="_blank" rel="external">http://www.cnblogs.com/songqingbo/p/5126957.html</a></p>
<p>字符串的常用操作包括但不限于以下操作：</p>
<pre><code>字符串的替换、删除、截取、复制、连接、比较、查找、分割等
</code></pre><p>这里将对字符串的内置操作方法进行总结归纳，重点是以示例的方式进行展示。</p>
<pre><code>使用type获取创建对象的类 type(name)
使用dir获取类的成员dir(name)
使用vars获取类的成员和各个成员的值
</code></pre><p><strong>capitalize</strong></p>
<pre><code>功能：字符串首字母大写
name = &apos;swhthaitun&apos;
name.capitalize()
返回结果：&apos;Swht&apos;
</code></pre><p><strong>casefold()首字母小写</strong></p>
<pre><code>name = &apos;HelloWord&apos;
reault = name.casefold()
print(reault)
返回结果：helloword
</code></pre><p><strong>casefold</strong></p>
<pre><code>功能：将字符串中所有的大写字母转换成小写字母
s1 = &quot;[&apos;bsondump&apos;, &apos;mongo&apos;, &apos;mongod&apos;, &apos;mongodump&apos;, &apos;mongoexport&apos;, &apos;mongofiles&apos;, &apos;mongoimport&apos;, &apos;mongooplog&apos;, &apos;mongoperf&apos;, &apos;mongoLLKJKKore&apos;, &apos;mongos&apos;, &apos;UUUngostat&apos;, &apos;monGGtop&apos;]&quot;
s1.casefold()
返回结果：&quot;[&apos;bsondump&apos;, &apos;mongo&apos;, &apos;mongod&apos;, &apos;mongodump&apos;, &apos;mongoexport&apos;, &apos;mongofiles&apos;, &apos;mongoimport&apos;, &apos;mongooplog&apos;, &apos;mongoperf&apos;, &apos;mongollkjkkore&apos;, &apos;mongos&apos;, &apos;uuungostat&apos;, &apos;monggtop&apos;]&quot;
</code></pre><p><strong>center</strong></p>
<pre><code>功能：字符串宽度填充，使用原有字符串+填充字符构成指定长度的新的字符串
name = &apos;swhthaitun&apos;
name.center(15)
返回结果：&apos;   swhthaitun  &apos; #默认以空格进行填充
name.center(16,&apos;*&apos;)
返回结果：&apos;***swhthaitun***&apos;

功能：字符串居中，以‘*’分割(20为新产生字符串的总的宽度)
name = &apos;HelloWord&apos;
reault = name.center(20,&apos;*&apos;)
print(reault)
返回结果：*****HelloWord******
</code></pre><p><strong>count</strong></p>
<pre><code>功能：统计某个字符在字符串中出现的次数，或在字符串指定区间内完成上述操作
name = &apos;swhthaitun&apos;
name.count(&apos;h&apos;)
返回结果：2
name.count(&apos;h&apos;,0,3)  #从索引值0-3范围的字符中统计&apos;h&apos;出现的次数
返回结果：1

功能：统计子序列出现的次数
name = &apos;HelloWord&apos;
reault = name.count(&apos;W&apos;) #如果换成&apos;w&apos;，返回结果为0，python对大小写敏感
print(reault)
返回结果：1

name = &apos;HelloWord&apos;
reault = name.count(&apos;l&apos;,0,3) #统计单个字符出现的次数,可以指定起始范围,另外在python中起始范围讲究顾头不顾尾的原则，即[0,3)
print(reault)
</code></pre><p><strong>encode</strong></p>
<pre><code>功能：对字符串进行编码操作
name = &apos;swhthaitun&apos;
name.encode()
返回结果：b&apos;swhthaitun&apos;

功能：转变字符串的编码
name = &apos;南非波波&apos;
reault = name.encode(&apos;gbk&apos;)
print(reault)
返回结果：b&apos;\xc4\xcf\xb7\xc7\xb2\xa8\xb2\xa8&apos;
</code></pre><p><strong>endswith</strong></p>
<pre><code>功能：判断字符串是否以某个字符串结尾的，返回值为bool型
name = &apos;swhthaitun&apos;
name.endswith(&apos;s&apos;)
返回结果：False
name.endswith(&apos;n&apos;)
返回结果：True
name.endswith(&apos;tun&apos;)
返回结果：True

name = &apos;Iamalatterboy&apos;
reault = name.endswith(&apos;y&apos;)
print(reault)
返回结果：True
</code></pre><p><strong>expandtabs</strong></p>
<pre><code>功能：将制表符&apos;\t&apos;转换成指定宽度的tab键分割，默认tabsize=8
li = &apos;sw\tht&apos;
li.expandtabs(4)
返回结果：&apos;sw  ht&apos;
li.expandtabs()
返回结果：&apos;sw      ht&apos;
</code></pre><p><strong>find</strong></p>
<pre><code>功能：在字符串中查找指定字符串，找不到时返回-1
name = &apos;swht&apos;
name.find(&apos;s&apos;)
返回结果：0
name.find(&apos;h&apos;)
返回结果：2
</code></pre><p><strong>format</strong></p>
<pre><code>功能：格式化输出字符串
li = &apos;I\&apos;m {},{}&apos; #两个&apos;{}&apos;是占位符
li.format(&apos;swht&apos;,&apos;欢迎来中国&apos;)
返回结果：&quot;I&apos;m swht,欢迎来中国&quot;
参考：http://blog.chinaunix.net/uid-23802873-id-4477364.html
</code></pre><p>__contains__ </p>
<pre><code>功能：包含 --&gt;&apos;eal&apos; in name
name = &apos;swhtkkskjj&apos;
reault = name.__contains__(&apos;swht&apos;)
print(reault)
返回结果：True
</code></pre><p><strong>index</strong></p>
<pre><code>功能：在字符串中查找指定的字符串,找不到时直接报错
name = &apos;swhthaitun&apos;
name.index(&apos;w&apos;)
返回结果：1    
</code></pre><p><strong>join()</strong></p>
<pre><code>功能：字符串连接
name = &apos;swhthaitun&apos;
&apos;*&apos;.join(name)
返回结果：&apos;s*w*h*t*h*a*i*t*u*n&apos;
</code></pre><p><strong>isalnum</strong></p>
<pre><code>功能：检查判断字符串是否包含字母数字字符（http://www.yiibai.com/python/string_isalnum.html）
name = &apos;swhthaitun&apos;
name.isalnum()
返回结果：True
</code></pre><p><strong>isalpha</strong></p>
<pre><code>功能：检测字符串是否只由字母组成（http://www.runoob.com/python/att-string-isalpha.html）
name = &apos;swhthaitun&apos;
name.isalpha()
返回结果：True
</code></pre><p><strong>isdecimal</strong></p>
<pre><code>功能：检查字符串是否只包含十进制字符。这种方法只存在于unicode对象。（参考：http://www.runoob.com/python/att-string-isdecimal.html）
name = &apos;swhthaitun&apos;
name.isdecimal()
返回结果：False
</code></pre><p><strong>isdigit</strong></p>
<pre><code>功能：检测字符串是否只由数字组成。(参考:http://www.runoob.com/python/att-string-isdigit.html)
name = &apos;swhthaitun&apos;
name.isdigit()
返回结果：False
</code></pre><p><strong>isidentifier</strong></p>
<pre><code>功能：检测字符串是否是字母开头
name = &apos;swhthaitun&apos;
name.isidentifier()
返回结果：True
name = &apos;1swhthaitun&apos;
name.isidentifier()
返回结果：False
</code></pre><p><strong>isnumeric</strong></p>
<pre><code>功能：检测字符串是否只由数字组成。这种方法是只针对unicode对象。
name = &apos;swhthaitun&apos;
name.isnumeric()
返回结果：False
Li = &apos;5523&apos;
Li.isnumeric()
返回结果：True
</code></pre><p><strong>isprintable</strong></p>
<pre><code>功能：判断字符串中所有字符是否都属于可见字符
a = &quot;\tPuppy&quot;
a.isprintable()
返回结果：False
name = &apos;swhthaitun&apos;
name.isprintable()
返回结果：True
</code></pre><p><strong>isspace</strong></p>
<pre><code>功能：检测字符串是否为空格
name = &apos;swhthaitun&apos;
name.isspace()
返回结果：False
Li = &apos; &apos;
Li.isspace()
返回结果：True
</code></pre><p><strong>istitle</strong></p>
<pre><code>功能：判断字符串是否适合当作标题（其实就是每个单词首字母大写）
a = &quot;a puppy&quot;
b = &quot;Puppy&quot;
a.istitle()
返回结果：False
b.istitle()
返回结果：True
</code></pre><p><strong>isupper</strong></p>
<pre><code>功能：判断字符串中所有字母字符是否都是大写字母
a = &quot;puppy&quot;
b = &quot;PUPPY&quot;
a.isupper()
返回结果：False
b.isupper()
返回结果：True
</code></pre><p><strong>ljust</strong></p>
<pre><code>功能：返回一个原字符串左对齐,并使用空格填充至指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符串。（参考：http://www.runoob.com/python/att-string-ljust.html）
语法：str.ljust(width[, fillchar])
     width -- 指定字符串长度。
     fillchar -- 填充字符，默认为空格。
name = &apos;swhthaitun&apos;
name.ljust(50,&apos;*&apos;)
返回结果：&apos;swhthaitun****************************************&apos;
</code></pre><p><strong>lower</strong></p>
<pre><code>功能：将所有的字母转换成小写字母
name = &apos;SWHT&apos;
name.lower()
返回结果：&apos;swht&apos;
</code></pre><p><strong>lstrip</strong></p>
<pre><code>功能：去除字符串左边开头的空格
name = &apos;  swht   &apos;
name.lstrip()
返回结果：&apos;swht   &apos;
</code></pre><p><strong>rstrip</strong></p>
<pre><code>功能：去除字符串右边结尾的空格
name = &apos;  swht   &apos;
name.rstrip()
返回结果：&apos;   swht&apos;
</code></pre><p><strong>strip</strong></p>
<pre><code>功能：去除字符串两边的空格
name = &apos;  swht   &apos;
name.rstrip()
返回结果：&apos;swht&apos;
</code></pre><p><strong>maketrans</strong></p>
<pre><code>功能：用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。
注：两个字符串的长度必须相同，为一一对应的关系。
语法：str.maketrans(intab, outtab)
参数：intab -- 字符串中要替代的字符组成的字符串。
      outtab -- 相应的映射字符的字符串。
intab = &quot;swhtr&quot;
outtab = &quot;12345&quot;
name = &quot;hjjksknsnjmk&quot;
name.maketrans(intab, outtab)
返回结果：{104: 51, 114: 53, 115: 49, 116: 52, 119: 50}
</code></pre><p><strong>partition</strong></p>
<pre><code>功能：根据指定的分隔符将字符串进行分割。
    如果字符串包含指定的分隔符，则返回一个3元的元组，第一个为分隔符左边的子串，第二个为分隔符本身，第三个为分隔符右边的子串。
name = &apos;swht&apos;
li = &apos;hhsslswhtolljm&apos;
li.partition(name)
返回结果：(&apos;hhssl&apos;, &apos;swht&apos;, &apos;olljm&apos;)
</code></pre><p><strong>replace</strong></p>
<pre><code>功能：把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次。
语法：str.replace(old, new[, max])
参数：old -- 将被替换的子字符串。
     new -- 新字符串，用于替换old子字符串。
     max -- 可选字符串, 替换不超过 max 次
str = &quot;this is string example....wow!!! this is really string&quot;
str.replace(&quot;is&quot;, &quot;was&quot;)
返回结果：&apos;thwas was string example....wow!!! thwas was really string&apos;
str.replace(&quot;is&quot;, &quot;was&quot;, 3)
返回结果：&apos;thwas was string example....wow!!! thwas is really string&apos;
</code></pre><p><strong>split</strong></p>
<pre><code>功能：字符串分割，默认是空格
name.split()
返回结果：[&apos;swht&apos;]
name.split(&apos;s&apos;) #以&apos;s&apos;字符进行分割
返回结果：[&apos;&apos;, &apos;wht&apos;]
</code></pre><p><strong>__add__</strong></p>
<pre><code>功能：在字符串后面增加指定的字符或字符串
name = &apos;swht&apos;
name.__add__(&apos;e&apos;)
返回结果：&apos;swhte&apos;
li = &apos;hjh&apos;
name.__add__(li)
返回结果：&apos;swhthjh&apos;
</code></pre><p><strong>__contains__</strong></p>
<pre><code>功能：判断指定字符串是否包含在字符串中,返回值为True和False
name = &apos;swht&apos;
name.__contains__(&apos;s&apos;)
返回结果：True
</code></pre><p><strong>__eq__</strong></p>
<pre><code>功能：判断字符串是否相等，返回值为True和False
name = &apos;swht&apos;
li = &apos;test&apos;
name.__eq__(li)
返回结果：False        
</code></pre><p><strong>splitlines</strong>    </p>
<pre><code>功能：按照行分隔，返回一个包含各行作为元素的列表，如果 num 指定则仅切片 num 个行.
语法：str.splitlines( num=string.count(&apos;\n&apos;))
参数：num -- 分割行的次数
Li = &quot;Line1-a b c d e f\nLine2- a b c\n\nLine4- a b c d&quot;
Li.splitlines(0)
返回结果：[&apos;Line1-a b c d e f&apos;, &apos;Line2- a b c&apos;, &apos;&apos;, &apos;Line4- a b c d&apos;]
Li.splitlines(1)
返回结果：[&apos;Line1-a b c d e f\n&apos;, &apos;Line2- a b c\n&apos;, &apos;\n&apos;, &apos;Line4- a b c d&apos;]
</code></pre><p><strong>startswith</strong></p>
<pre><code>功能：判断一个字符串是否以某个或几个字符开始，结果以True或者False返回。
name = &quot;swhtlllds&quot;
name.startswith(&apos;s&apos;)
返回结果：True
</code></pre><p><strong>endswith</strong></p>
<pre><code>功能：判断一个字符串是否以某个或几个字符结束，结果以True或者False返回。
name = &quot;swhtlllds&quot;
name.endswith(&apos;ds&apos;)
返回结果：True
</code></pre><p><strong>swapcase</strong></p>
<pre><code>功能：用于对字符串的大小写字母进行转换。
name = &apos;swht&apos;
name.swapcase()
返回结果：&apos;SWHT&apos;
name = &apos;Swht&apos;
name.swapcase()
返回结果：&apos;sWHT&apos;
</code></pre><p><strong>upper</strong></p>
<pre><code>功能：将字符串中的小写字母转为大写字母
name = &apos;swht&apos;
name.swapcase()
返回结果：&apos;SWHT&apos;
</code></pre><p><strong>title</strong></p>
<pre><code>功能：进行标题转换,即单词首字母大写
name = &apos;swht ni li&apos;
name.title()
返回结果： &apos;Swht Ni Li&apos;
</code></pre><p><strong>translate</strong></p>
<pre><code>功能：根据参数table给出的表(包含 256 个字符)转换字符串的字符, 要过滤掉的字符放到 del 参数中。
方法：str.translate(table[, deletechars]);
参数：table -- 翻译表，翻译表是通过maketrans方法转换而来。
     deletechars -- 字符串中要过滤的字符列表。
intab = &quot;aeiou&quot;
outtab = &quot;12345&quot;
trantab = maketrans(intab, outtab)

str = &quot;this is string example....wow!!!&quot;;
print str.translate(trantab);
返回结果：th3s 3s str3ng 2x1mpl2....w4w!!!
</code></pre><p><strong>zfill</strong></p>
<pre><code>功能：垫零左侧的字符串，以填补宽度
语法：str.zfill(width)
参数：width：最后的字符串宽度
str = &quot;this is string example....wow!!!&quot;        
print str.zfill(40)
print str.zfill(50)
返回结果：00000000this is string example....wow!!!
         000000000000000000this is string example....wow!!!
</code></pre><h4 id="四、列表"><a href="#四、列表" class="headerlink" title="四、列表"></a>四、列表</h4><p>博客链接：<a href="http://www.cnblogs.com/songqingbo/p/5126943.html" target="_blank" rel="external">http://www.cnblogs.com/songqingbo/p/5126943.html</a></p>
<p>列表的基本操作示例展示：</p>
<p><strong>append</strong></p>
<pre><code>功能：列表追加元素
name = [&apos;sd&apos;,&apos;dfdf&apos;,&apos;drer&apos;]
name.append(&apos;sdsd&apos;)
返回结果：name
        [&apos;sd&apos;, &apos;dfdf&apos;, &apos;drer&apos;, &apos;sdsd&apos;]
</code></pre><p><strong>clear</strong></p>
<pre><code>功能：情况列表元素
name = [&apos;sd&apos;,&apos;dfdf&apos;,&apos;drer&apos;]
name.clear()
返回结果：name
         []
</code></pre><p><strong>copy</strong></p>
<pre><code>功能：浅拷贝，即只拷贝第一层的元素
name = [&apos;sd&apos;,&apos;dfdf&apos;,&apos;drer&apos;]
li = [&apos;ssd&apos;]
li = name.copy()
返回结果：li
         [&apos;sd&apos;, &apos;dfdf&apos;, &apos;drer&apos;]

name = [&apos;sd&apos;,&apos;dfdf&apos;,&apos;drer&apos;,[&apos;sddss&apos;,&apos;sdsdsd&apos;]]
li = [&apos;ssd&apos;]
li = name.copy()
返回结果：li
[&apos;sd&apos;, &apos;dfdf&apos;, &apos;drer&apos;, [&apos;sddss&apos;, &apos;sdsdsd&apos;]]
</code></pre><p><strong>count</strong></p>
<pre><code>功能：统计列表指定元素个数
name = [&apos;sd&apos;,&apos;dfdf&apos;,&apos;drer&apos;,[&apos;sddss&apos;,&apos;sdsdsd&apos;]]
name.count(&apos;sd&apos;)
返回结果：1
li = [&apos;sd&apos;,&apos;sdsds&apos;,[&apos;sd&apos;,&apos;dffdg&apos;,],]
li.count(&apos;sd&apos;) #只统计第一层的元素个数
返回结果：1
</code></pre><p><strong>extend</strong></p>
<pre><code>功能：追加字符元素或列表元素
name = [&apos;sd&apos;,&apos;dfdf&apos;,&apos;drer&apos;,[&apos;sddss&apos;,&apos;sdsdsd&apos;]]
li = [&apos;sd&apos;,&apos;sdsds&apos;,[&apos;sd&apos;,&apos;dffdg&apos;,],]
name.extend(&apos;ss&apos;)
返回结果：name
[&apos;sd&apos;, &apos;dfdf&apos;, &apos;drer&apos;, [&apos;sddss&apos;, &apos;sdsdsd&apos;], &apos;s&apos;, &apos;s&apos;]
name.extend(&apos;d&apos;)
返回结果：name
[&apos;sd&apos;, &apos;dfdf&apos;, &apos;drer&apos;, [&apos;sddss&apos;, &apos;sdsdsd&apos;], &apos;s&apos;, &apos;s&apos;, &apos;d&apos;]
name.extend(li)
返回结果：name
[&apos;sd&apos;, &apos;dfdf&apos;, &apos;drer&apos;, [&apos;sddss&apos;, &apos;sdsdsd&apos;], &apos;s&apos;, &apos;s&apos;, &apos;d&apos;, &apos;sd&apos;, &apos;sdsds&apos;, [&apos;sd&apos;, &apos;dffdg&apos;]]
</code></pre><p><strong>index</strong></p>
<pre><code>功能：定位列表中某元素
name = [&apos;sd&apos;,&apos;dfdf&apos;,&apos;drer&apos;,[&apos;sddss&apos;,&apos;sdsdsd&apos;]]
name.index(&apos;sd&apos;)
返回结果：0
name.index(&apos;drer&apos;)
返回结果：2
返回结果：name.index(&apos;dr&apos;)  #当出现某元素不在列表中的时候会直接报错
        Traceback (most recent call last):
          File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
        ValueError: &apos;dr&apos; is not in list
</code></pre><p><strong>insert</strong></p>
<pre><code>功能：在指定索引位置的元素前面插入新的元素
name = [&apos;sd&apos;,&apos;dfdf&apos;,&apos;drer&apos;,[&apos;sddss&apos;,&apos;sdsdsd&apos;]]
name.insert(3,&apos;sd&apos;)
返回结果：name
[&apos;sd&apos;, &apos;dfdf&apos;, &apos;drer&apos;, &apos;sd&apos;, [&apos;sddss&apos;, &apos;sdsdsd&apos;]]
</code></pre><p><strong>pop</strong></p>
<pre><code>功能：删除指定索引值的元素,返回值为当前删除的元素的值。不指定索引值，默认删除最后一个元素
name = [&apos;sd&apos;,&apos;dfdf&apos;,&apos;drer&apos;,[&apos;sddss&apos;,&apos;sdsdsd&apos;]]
name.pop(3)
返回结果：&apos;sd&apos;
</code></pre><p><strong>remove</strong></p>
<pre><code>功能：删除列表中指定的元素
name = [&apos;sd&apos;,&apos;dfdf&apos;,&apos;drer&apos;,[&apos;sddss&apos;,&apos;sdsdsd&apos;]]
name.remove(&apos;sd&apos;)
name
返回结果：[&apos;dfdf&apos;, &apos;drer&apos;, [&apos;sddss&apos;, &apos;sdsdsd&apos;]]
</code></pre><p><strong>reverse</strong></p>
<pre><code>功能：用于反向列表中元素。
name = [&apos;sd&apos;,&apos;dfdf&apos;,&apos;drer&apos;,[&apos;sddss&apos;,&apos;sdsdsd&apos;]]
name.reverse()
name
返回结果：[[&apos;sddss&apos;, &apos;sdsdsd&apos;], &apos;drer&apos;, &apos;dfdf&apos;, &apos;sd&apos;]
</code></pre><p><strong>sort</strong></p>
<pre><code>功能：对单层列表进行元素的排序
name = [&apos;sd&apos;,&apos;dfdf&apos;,&apos;drer&apos;,]
name.sort()
name
返回结果：[&apos;dfdf&apos;, &apos;drer&apos;, &apos;sd&apos;]

name = [&apos;sd&apos;,&apos;dfdf&apos;,&apos;drer&apos;,[&apos;sddss&apos;,&apos;sdsdsd&apos;]]
name.sort() #报错的
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
</code></pre><h4 id="五、元组"><a href="#五、元组" class="headerlink" title="五、元组"></a>五、元组</h4><p>关于元组的常用操作，请参考：<a href="http://www.runoob.com/python/python-tuples.html" target="_blank" rel="external">http://www.runoob.com/python/python-tuples.html</a></p>
<p>博客链接：<a href="http://www.cnblogs.com/songqingbo/p/5126947.html" target="_blank" rel="external">http://www.cnblogs.com/songqingbo/p/5126947.html</a></p>
<p>元组的元素不可修改    ，元组的元素的元素可修改</p>
<p><strong>count(self,value)</strong></p>
<pre><code>功能：统计当前元组中某元素的个数
tup = (55,77,85,55,96,99,22,55,)
tup.count(55)
返回结果：3 
备注：元素‘55’在元组tup中出现了3次
</code></pre><p><strong>index(self, value, start=None, stop=None)</strong></p>
<pre><code>功能：获取元素在元组中的索引值,对于重复的元素,默认获取从左起第一个元素的索引值
tup = (55,77,85,55,96,99,22,55,)
tup.index(55)
返回结果：0
tup.index(85)
返回结果：2
tup.index(55,2,7)
返回结果：3
</code></pre><p><strong>__add__</strong></p>
<pre><code>功能：将另一个元组追加到当前元组后面.__add__()只接收元组类型的序列
tup1 = (12,33,566,78,)
tup2 = (55,66,77,)
tup1.__add__(tup2)
返回结果：(12,33,566,78,55,66,77,)
</code></pre><p><strong>__contains__</strong></p>
<pre><code>功能：包含，判断某元素是否包含在元组中
tup = (55,77,85,55,96,99,22,55,)
tup.__contains__(55)
返回结果：True  
备注：返回值类型是bool型，该方法判断在对成员元素是否存在元组中，程序根据返回不同的bool值进行相应的值返回或者操作
</code></pre><p><strong>__eq__</strong></p>
<pre><code>功能：判断两个元组是否相等，返回值类型为bool型
tup = (55,77,85,55,96,99,22,55,)
tup1 = (55,77,85,55,96,99,22,551,)
tup.__eq__(tup1)
返回结果：False
</code></pre><p><strong>__getattribute__</strong></p>
<pre><code>pass
</code></pre><p><strong>__getitem__</strong></p>
<pre><code>功能：获取指定索引值的元素值
tup = (55,77,85,55,96,99,22,55,)
tup.__getitem__(5)
返回结果：99
</code></pre><p><strong>__getnewargs__</strong></p>
<pre><code>功能：只是获取原来的元组？？无卵用
tup = (55,77,85,55,96,99,22,55,)
tup.__getnewargs__()
返回结果：((55, 77, 85, 55, 96, 99, 22, 55),)
</code></pre><p><strong>__ge__</strong></p>
<pre><code>功能：判断当前元组是否大于等于某个元组
tup = (55,77,85,55,96,99,22,55,)
tup1 = (55,77,85,55,96,99,22,551,)
tup.__ge__(tup1)
返回结果：False #bool类型
</code></pre><p><strong>__gt__</strong></p>
<pre><code>功能：判断当前元组是否大于某个元组
tup = (55,77,85,55,96,99,22,55,)
tup1 = (55,77,85,55,96,99,22,551,)
tup.__ge__(tup1)
返回结果：False #bool类型
</code></pre><p><strong>__hash__</strong></p>
<pre><code>功能：计算元组的hash值
tup = (55,77,85,55,96,99,22,55,)
tup1 = (55,77,85,55,96,99,22,551,)
tup.__hash__()
返回结果：-2123087613
tup1.__hash__()
返回结果：1338854611
</code></pre><p><strong>__init__</strong></p>
<pre><code>功能：初始化作用，无返回值
</code></pre><p><strong>__iter__</strong></p>
<pre><code>功能：获取元组的内存地址
tup = (55,77,85,55,96,99,22,55,)
tup1 = (55,77,85,55,96,99,22,551,)
tup.__iter__()
返回结果：&lt;tuple_iterator object at 0x01C21F70&gt;
tup1.__iter__()
返回结果：&lt;tuple_iterator object at 0x01C21F50&gt;
</code></pre><p><strong>__len__</strong></p>
<pre><code>功能：获取元组的长度
tup.__len__()  #该方法已经被放到python的内置函数中，可以使用len(tup)获取长度
返回结果：8
</code></pre><p><strong>__le__</strong></p>
<pre><code>功能：判断当前元组是否小于等于某个元组
tup = (55,77,85,55,96,99,22,55,)
tup1 = (55,77,85,55,96,99,22,551,)
tup.__le__(tup1)
返回结果：True #bool类型
</code></pre><p><strong>__lt__</strong></p>
<pre><code>功能：判断当前元组是否小于某个元组
tup = (55,77,85,55,96,99,22,55,)
tup1 = (55,77,85,55,96,99,22,551,)
tup.__lt__(tup1)
返回结果：True #bool类型
</code></pre><p><strong>__mul__</strong></p>
<pre><code>功能：把当前元组按照某个值的倍数进行元组的扩展，产生新的元组
tup = (55,77,85,55,96,99,22,55,)
tup.__mul__(2)
返回结果：(55, 77, 85, 55, 96, 99, 22, 55, 55, 77, 85, 55, 96, 99, 22, 55)
tup.__iter__()
返回结果：&lt;tuple_iterator object at 0x01C21F70&gt;
tup.__mul__(2).__iter__()
返回结果：&lt;tuple_iterator object at 0x01C2F050&gt;
</code></pre><p><strong>__new__</strong></p>
<pre><code>pass
</code></pre><p><strong>__ne__</strong></p>
<pre><code>功能：判断当前元组不等于某个元组
tup = (55,77,85,55,96,99,22,55,)
tup1 = (55,77,85,55,96,99,22,551,)
tup.__ne__(tup1)
返回结果：True #bool类型
</code></pre><p><strong>__repr__</strong></p>
<pre><code>功能：将元组转换成一个字符串
tup = (55,77,85,55,96,99,22,55,)
tup.__repr__()
返回结果：&apos;(55, 77, 85, 55, 96, 99, 22, 55)&apos;
 type(tup.__repr__())
返回结果：&lt;class &apos;str&apos;&gt;
</code></pre><p><strong>__rmul__</strong></p>
<pre><code>功能：？？怎么感觉跟__mul__一个德行？？
tup = (55,77,85,55,96,99,22,55,)
tup.__rmul__(2)
返回结果：(55, 77, 85, 55, 96, 99, 22, 55, 55, 77, 85, 55, 96, 99, 22, 55)
</code></pre><h4 id="六、字典"><a href="#六、字典" class="headerlink" title="六、字典"></a>六、字典</h4><p>博客链接：<a href="http://www.cnblogs.com/songqingbo/p/5127044.html" target="_blank" rel="external">http://www.cnblogs.com/songqingbo/p/5127044.html</a></p>
<p>字典的常用操作：</p>
<p><strong>clear</strong></p>
<pre><code>功能：清空字典
dict_li = {&apos;users&apos;:&apos;swht&apos;,&apos;age&apos;:&apos;18&apos;,}
dict_li.clear()
返回结果：dict_li
        {}
</code></pre><p><strong>copy</strong></p>
<pre><code>功能：浅拷贝
dict_li = {&apos;users&apos;:&apos;swht&apos;,&apos;age&apos;:&apos;18&apos;,}
dict_li.copy()
返回结果：{&apos;age&apos;: &apos;18&apos;, &apos;users&apos;: &apos;swht&apos;}
dict_li = {&apos;users&apos;:&apos;swht&apos;,&apos;age&apos;:&apos;18&apos;,&apos;address&apos;:{&apos;sd&apos;:&apos;dz&apos;}}
dict_li.copy()
返回结果：{&apos;age&apos;: &apos;18&apos;, &apos;users&apos;: &apos;swht&apos;, &apos;address&apos;: {&apos;sd&apos;: &apos;dz&apos;}}
</code></pre><p><strong>fromkeys()</strong></p>
<pre><code>功能：用于创建一个新字典，以序列seq中元素做字典的键，value为字典所有键对应的初始值。
语法：dict.fromkeys(seq[, value]))
参数：seq -- 字典键值列表。
     value -- 可选参数, 设置键序列（seq）的值。
li = [&apos;users&apos;,&apos;age&apos;]
dict_li = dict.fromkeys(li,&apos;swht&apos;)
返回结果：dict_li
        {&apos;age&apos;: &apos;swht&apos;, &apos;users&apos;: &apos;swht&apos;}
</code></pre><p><strong>get</strong></p>
<pre><code>功能：获取字典的value值
dict_li = {&apos;users&apos;:&apos;swht&apos;,&apos;age&apos;:&apos;18&apos;,}
dict_li.get(&apos;users&apos;)
返回结果：&apos;swht&apos;
</code></pre><p><strong>items</strong></p>
<pre><code>功能：返回可遍历的(键, 值) 元组数组
dict_li = {&apos;users&apos;:&apos;swht&apos;,&apos;age&apos;:&apos;18&apos;,}
dict_li.items()
返回结果：dict_items([(&apos;age&apos;, &apos;18&apos;), (&apos;users&apos;, &apos;swht&apos;)])
</code></pre><p><strong>keys</strong></p>
<pre><code>功能：获取字典可遍历的键
dict_li = {&apos;users&apos;:&apos;swht&apos;,&apos;age&apos;:&apos;18&apos;,}
dict_li.keys()
返回结果：dict_keys([&apos;age&apos;, &apos;users&apos;])
</code></pre><p><strong>pop</strong></p>
<pre><code>功能：删除字典中指定的键值
dict_li = {&apos;users&apos;:&apos;swht&apos;,&apos;age&apos;:&apos;18&apos;,}
dict_li.pop(&apos;age&apos;)
返回结果：&apos;18&apos;
</code></pre><p><strong>popitem</strong></p>
<pre><code>功能：随机返回并删除字典中的一对键和值
dict_li = {&apos;users&apos;:&apos;swht&apos;,&apos;age&apos;:&apos;18&apos;,}
dict_li.popitem()
返回结果：(&apos;age&apos;, &apos;18&apos;)
dict_li
{&apos;users&apos;: &apos;swht&apos;}
</code></pre><p><strong>setdefault</strong></p>
<pre><code>功能：查找键值，如果键不已经存在于字典中，将会添加键并将值设为默认值。
dict_li = {&apos;users&apos;:&apos;swht&apos;,&apos;age&apos;:&apos;18&apos;,}
dict_li.setdefault(&apos;ID&apos;,5)
返回结果：5
dict_li
返回结果：{&apos;age&apos;: &apos;18&apos;, &apos;users&apos;: &apos;swht&apos;, &apos;ID&apos;: 5}
</code></pre><p><strong>update</strong></p>
<pre><code>功能：把指定字典的键值更新到当前字典中
dict_li = {&apos;users&apos;:&apos;swht&apos;,&apos;age&apos;:&apos;18&apos;,}
dict_ai = {&apos;address&apos;:&apos;山东&apos;}
dict_li.update(dict_ai)
dict_li
返回结果：{&apos;age&apos;: &apos;18&apos;, &apos;users&apos;: &apos;swht&apos;, &apos;address&apos;: &apos;山东&apos;}
</code></pre><p><strong>values</strong></p>
<pre><code>功能：获取字典的所有值
dict_li = {&apos;age&apos;: &apos;18&apos;, &apos;users&apos;: &apos;swht&apos;, &apos;address&apos;: &apos;山东&apos;}
dict_li.values()
返回结果：dict_values([&apos;18&apos;, &apos;swht&apos;, &apos;山东&apos;])
</code></pre><h3 id="七、set集合"><a href="#七、set集合" class="headerlink" title="七、set集合"></a>七、set集合</h3><p>博客链接：<a href="http://www.cnblogs.com/songqingbo/p/5128066.html" target="_blank" rel="external">http://www.cnblogs.com/songqingbo/p/5128066.html</a></p>
<pre><code>set集合是一个无序且不重复的集合。
创建一个set集合：
    name = set(&apos;sdd&apos;)
    name
    返回结果：{&apos;d&apos;, &apos;s&apos;}
</code></pre><p><strong>add</strong></p>
<pre><code>功能：增加集合元素
name = {&apos;d&apos;, &apos;s&apos;}
name.add(&apos;d&apos;)
name
返回结果：{&apos;d&apos;, &apos;s&apos;}
name.add(&apos;sd&apos;)
name
返回结果：{&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
</code></pre><p><strong>clear</strong></p>
<pre><code>功能：清空集合元素
name = {&apos;d&apos;, &apos;s&apos;}
name.clear()
name
返回结果：{}
</code></pre><p><strong>copy</strong></p>
<pre><code>功能：浅拷贝
name = {&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
li = name.copy()
返回结果：li
        {&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
</code></pre><p><strong>difference</strong></p>
<pre><code>功能：取差集
name = {&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
li = set()
name.difference(li)
返回结果：name.difference()
{&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
</code></pre><p><strong>difference_update</strong></p>
<pre><code>功能：删除当前set中的所有包含在 new set 里的元素
li = (&apos;s&apos;, &apos;d&apos;)
name = {&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
name.difference_update(li)
name
返回结果：{&apos;sd&apos;}
</code></pre><p><strong>discard</strong></p>
<pre><code>功能：移除元素
name = {&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
name.discard(&apos;s&apos;)
返回结果：name 
        {&apos;sd&apos;, &apos;d&apos;}
</code></pre><p><strong>intersection</strong></p>
<pre><code>功能：取交集,建立新的set集合
li = (&apos;s&apos;, &apos;d&apos;)
name = {&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
name.intersection(li)
返回结果：{&apos;d&apos;, &apos;s&apos;}
</code></pre><p><strong>intersection_update</strong></p>
<pre><code>功能：取交集,更新原来的set集合
li = (&apos;s&apos;, &apos;d&apos;)
name = {&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
name.intersection_update(li)
返回结果：{&apos;d&apos;, &apos;s&apos;}
</code></pre><p><strong>isdisjoint</strong></p>
<pre><code>功能：判断没有交集，返回True,否则,返回False
li = {&apos;s&apos;, &apos;d&apos;}
name = {&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
name.isdisjoint(li)
</code></pre><p><strong>issubset</strong></p>
<pre><code>功能：判断是否是子集
li = {&apos;s&apos;, &apos;d&apos;}
name = {&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
name.issubset(li)  #判断name是不是li的子集
返回结果：False
li.issubset(name)  #判断li是不是name的子集
返回结果：True
</code></pre><p><strong>issuperset</strong></p>
<pre><code>功能：判断是否是父集
li = {&apos;s&apos;, &apos;d&apos;}
name = {&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
name.issuperset(li)  #判断name是不是li的父集
返回结果：True
li.issuperset(name)  #判断li是不是name的父集
返回结果：False
</code></pre><p><strong>pop</strong></p>
<pre><code>功能：移除集合元素
name = {&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
name.pop()
返回结果：&apos;sd&apos; #随机删除集合元素
se1 = {&apos;a&apos;,&apos;s&apos;,&apos;sb&apos;}
se1.pop()
返回结果：&apos;sb&apos;
</code></pre><p><strong>remove</strong></p>
<pre><code>功能：移除指定集合元素
name = {&apos;sd&apos;,&apos;d&apos;,&apos;s&apos;}
name.remove(&apos;s&apos;)
返回结果：name
{&apos;sd&apos;, &apos;d&apos;}
</code></pre><p><strong>symmetric_difference</strong></p>
<pre><code>功能：去两个集合的差集，建立新的set集合对象
name = {&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
li = {&apos;s&apos;, &apos;d&apos;}
name.symmetric_difference(li)
返回结果：{&apos;sd&apos;}
</code></pre><p><strong>symmetric_difference_update</strong></p>
<pre><code>功能：去两个集合的差集，更新原来的集合对象
name = {&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
li = {&apos;s&apos;, &apos;d&apos;}
name.symmetric_difference_update(li)
返回结果：{&apos;sd&apos;}
</code></pre><p><strong>union</strong></p>
<pre><code>功能：并集，创建新的对象
name = {&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
li = {&apos;s&apos;, &apos;d&apos;,&apos;h&apos;}
name.union(li)
返回结果：{&apos;h&apos;, &apos;s&apos;, &apos;d&apos;, &apos;sd&apos;}
</code></pre><p><strong>update</strong></p>
<pre><code>功能：更新已有集合
name = {&apos;sd&apos;, &apos;d&apos;, &apos;s&apos;}
name.update(&apos;df&apos;)
name
返回结果：{&apos;sd&apos;, &apos;d&apos;, &apos;f&apos;, &apos;s&apos;}
</code></pre><h4 id="八、类与对象"><a href="#八、类与对象" class="headerlink" title="八、类与对象"></a>八、类与对象</h4><p><img src="http://i.imgur.com/O2wZsUd.png" alt=""></p>
<p>对象</p>
<pre><code>python中一切事物皆对象,对象是一开始就有的,只是我们无法访问它。访问对象需要以变量的形式去访问（即创建变量指向到对象的，变量即对对象的引用）
在python中，一个对象的特征也称为属性（attribute）。它所具有的行为也称为方法（method）
结论：对象=属性+方法
</code></pre><p>类</p>
<pre><code>在python中，把具有相同属性和方法的对象归为一个类（class）
比如人类，动物，植物等等，这些都是类的概念。 
类是对象的模板或蓝图，类是对象的抽象化，对象是类的实例化。类不代表具体的事物，而对象表示具体的事物。
类包含描述对象的方法。
</code></pre><h4 id="int"><a href="#int" class="headerlink" title="int"></a>int</h4><pre><code>取绝对值：
    age = -19
    age.__abs__() #int类函数调用
    abs(-19) #内置函数方式操作
取商和余数：
    age = 95
    age.__divmod__(10) #95/10 --&gt;(9,5)
相加：
    a = 5，b=6
    a.__add__(b) #调用int的类函数add，相当于a + b  --&gt;11
    a + b #内置函数方式操作
</code></pre><p>作业：</p>
<pre><code>1. 博客整理
2. 购物商城实现
    1. 商品展示，价格
    2. 购物车添加商品（进行差异商品，同一种商品应该只存在一条数据）
    3. 付款（根据钱进行判断是否可以满足付款）
3. 预习
    http://www.cnblogs.com/wupeiqi/articles/5115190.html  后面的部分
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python开发之路/">Python开发之路</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-s12-20151226-day01" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/16/s12-20151226-day01/" class="article-date">
      <time datetime="2015-12-16T07:30:00.000Z" itemprop="datePublished">2015-12-16</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/16/s12-20151226-day01/">pytho自动化开发 day01</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Author:@南非波波</p>
<p>作者注：</p>
<p>　　python学习旅程正式开启，这一天将是一个新的开始。希望我们在python开发的道路上多多积累、多分享！</p>
<p> 一、python简介</p>
<pre><code>python应用 
    Disgus Voitze Yelip Mozilla Quora  Redit
    豆瓣、知乎、sohu、腾讯、网易、金山、雅虎、Facebook、 Instagram（图片分享）
python2与python3比较
    经过多年的发展，python3已经得到更多的第三方优秀函数库兼容，对比python2来说，python3表现出来的精简高效特性让开发者们跃跃欲试。
    另外，python2.7.11作为python2版本的最后一个版本，不再有新版本推出，这样官方更多的引导开发者快速的向python3版本上进行转移。
    在本次学习的过程中，我们会穿插在python2和python3两个版本之间进行学习，后续的测试代码在开头会明确标记python的使用版本。相关注释都会对python2和python3的差异进行描述。
</code></pre><p>二、python安装</p>
<pre><code>1.windows端安装
    安装包下载地址：
        python2.7版本：
            https://www.python.org/ftp/python/2.7.11/python-2.7.11.amd64.msi
        python3.5版本：
            https://www.python.org/ftp/python/3.5.1/python-3.5.1-amd64.exe  #安装版
            https://www.python.org/ftp/python/3.5.1/python-3.5.1-embed-win32.zip #免安装版
    安装步骤：
        使用可执行程序进行安装，按照流程进行安装即可，注意在安装的时候选择“安装路径”和一些必要的插件，比如pip、easy_install等
        使用免安装的文件（可嵌入的）进行环境配置：
        ![](http://i.imgur.com/U827QAb.jpg)
2.linux端安装
    centos6等常用系统自带的python版本为2.6，有特殊需求的朋友可能需要升级到python2.7或者python3版本。下面链接以python2.7.8为例进行编译安装。
        http://swht1278.blog.51cto.com/7138082/1728427
    提供一下python版本的下载地址：
        python2.7.11版本：
            https://www.python.org/ftp/python/2.7.11/Python-2.7.11.tgz
        python3.5版本：
            https://www.python.org/ftp/python/3.5.1/Python-3.5.1.tgz
3.Ubuntu端安装
    最新版本的Ubuntu系统（15.04等）已经自带了python2.7.9和python3.4.5两个版本的python环境，我们只需要在shell终端输入python2或python3进行调用即可。老版本的系统升级python环境需要以下操作：
        # 增加python源
        sudo add-apt-repository ppa:fkrull/deadsnakes
        # update 软件列表
        sudo apt-get update
        # 安装python3
        sudo apt-get install python3.5
</code></pre><p>三、基础概念</p>
<pre><code>变量：Python 是动态类型语言， 也就是说不需要预先声明变量的类型。变量是对象的引用，变量只是将指针指向了对象所在的内存地址。变量的类型和值在赋值那一刻被初始化。
变量起名：
    1.显式--&gt;通俗易懂
    2.nums_of_alex_gf = 19 
    3.NumsOfAlexGf = 20  驼峰写法
    4.中横线不能作为变量的命名字符
    5.数字不能作为开头，但可以在中间或者结尾
    6.特殊字符不能作为变量名的组成部分
    7.不能使用空格
    8.关键字不能声明为变量
</code></pre><p>四、运算符</p>
<pre><code>算术运算符
    +  -  *  /   //  %  **
    /:传统除法，将执行地板除法，
    //:浮点除法，即去尾法除法，保留位数与除数和被除数的小数位数有关 （取整除，返回商的部分）
    **：平方运算
比较运算符
    &lt;  &lt;=  &gt;  &gt;=  ==  !=   &lt;&gt;
    不等于：!=   &lt;&gt;
    返回值是：True 和 False
赋值运算符
    &gt;&gt;&gt; counter = 0 
    &gt;&gt;&gt; miles = 1000.0 
    &gt;&gt;&gt; name = &apos;Bob&apos; 
    &gt;&gt;&gt; counter = counter + 1 
    &gt;&gt;&gt; kilometers = 1.609 * miles 
    &gt;&gt;&gt; print &apos;%f miles is the same as %f km&apos; % (miles, kilometers)
    1000.000000 miles is the same as 1609.000000 km
    支持简写：n=n*3 -&gt; n*=3  但不支持自增自减，因为“-” 和”+”是单目字符，--n -&gt; -(-n)n
位运算符
    &amp;      按位与      （a&amp;b）
    |      按位或    （a|b）
    ^    按位异或    （a^b）
    ~    按位取反    （~a）
    &lt;&lt;    左移动     a&lt;&lt;1 整体向左移动，结果是原来数值的2倍
    &gt;&gt;  右移动    a&gt;&gt;1 整体向右移动，结果是原来数值的1/2
逻辑运算符
    and 布尔“与”     同真为True
    or  布尔“或”     同假为False
    not    布尔“非”     非True即False
成员运算符
    in     如果在指定序列中找到指定的值，返回True
    not in 如果在指定序列中没找到指定的值，返回False
身份运算符
    is  判断两个标识符是不是引用自同一个对象
        type(names) is list 判断某个变量值的类型（list、int、dic）
    is not 判断两个标识符是不是引用自不同对象
</code></pre><p>五、字符编码</p>
<pre><code>python2 中在输入中文字符的时候会报字符编码的错误，在python3中已经引入了Unicode（万国码、统一码、），它为每种语言中的每个字符设定了统一并且唯一的二进制编码，规定所有的字符和符号最少由16位二进制来表示（2个字节），即2 ** 16 = 65536
UTF-8，是对Unicode编码的压缩和优化，它不再使用最少2个字节，而是将所有的字符和符号进行分类：ascii码中的内容用1个字节保存，欧洲的字符用2个字节保存，东亚的字符用3个字节保存

示例
python2
    #!/usr/local/env python2
    # -*- coding: utf-8 -*-  # 声明使用的字符类型，否则会报错
    &apos;&apos;&apos;
    @swht
    &apos;&apos;&apos;
    print &quot;你好！&quot;

python3
    #!/usr/local/env python3
    &apos;&apos;&apos;
    @swht
    &apos;&apos;&apos;
    print (&quot;你好！&quot;)

总结：在python3中完全不用考虑字符编码的问题，python解释器会自行处理字符类型的问题
</code></pre><p>六、python流程控制</p>
<pre><code>流程控制分为两大类：条件判断和循环
其中循环又分为两类：for循环和while循环
条件判断和循环可以单独存在，也可以嵌套使用，以处理更为复杂的逻辑问题。
</code></pre><p>下面会从<em>if条件判断</em>、<em>for循环</em>和<em>while循环</em>进行代码示例：</p>
<h4 id="if-ex-py"><a href="#if-ex-py" class="headerlink" title="if_ex.py"></a>if_ex.py</h4><pre><code>#!/usr/bin/env python3
&apos;&apos;&apos;
@swht
&apos;&apos;&apos;
LuckyNum = 9
# 让用户输入一个数值与指定的值进行比较，当然这里没有处理用户输入为空的情况
# strip() 可以截取用户输入字符串首尾的空格
UserInputNum = int(input(&quot;请从1-100之间选择一个数字输入:&quot;).strip())
if UserInputNum &gt; LuckyNum:
    print(&quot;你输入的数字比我的LuckNum要大哦!&quot;)
elif UserInputNum &lt; LuckyNum:
    print(&quot;你输入的数字比我的LuckNum要小哦!&quot;)
else:
    print(&quot;恭喜你猜中了我的LuckNum,原来你就是我的幸运天使!&quot;)
</code></pre><h3 id="while-ex-py"><a href="#while-ex-py" class="headerlink" title="while_ex.py"></a>while_ex.py</h3><pre><code>#!/usr/bin/env python3
&apos;&apos;&apos;
@swht
&apos;&apos;&apos;
LuckyNum = 9
# 设置一个标志位，用于程序判断退出循环，
flag = True
while flage:
UserInputNum = int(input(&quot;请从1-100之间选择一个数字输入:&quot;).strip())
if UserInputNum &gt; LuckyNum:
    print(&quot;你输入的数字比我的LuckyNum要大哦!&quot;)
elif UserInputNum &lt; LuckyNum:
    print(&quot;你输入的数字比我的LuckyNum要小哦!&quot;)
else:
    print(&quot;恭喜你猜中了我的LuckyNum,原来你就是我的幸运天使!&quot;)
    flag = False 
</code></pre><h3 id="for-ex-py"><a href="#for-ex-py" class="headerlink" title="for_ex.py"></a>for_ex.py</h3><pre><code>#!/usr/bin/env python3
&apos;&apos;&apos;
@swht
&apos;&apos;&apos;
LuckyNum = 9
for count in range(3):
    UserInputNum = int(input(&quot;请从1-100之间选择一个数字输入:&quot;).strip())
    if UserInputNum &gt; LuckyNum:
        print(&quot;你输入的数字比我的LuckyNum要大哦!&quot;)
    elif UserInputNum &lt; LuckyNum:
        print(&quot;你输入的数字比我的LuckyNum要小哦!&quot;)
    else:
        print(&quot;恭喜你猜中了我的LuckyNum,原来你就是我的幸运天使!&quot;)
        break
else:
    print(&quot;你输入的次数已达到3次,程序即将退出!&quot;)
</code></pre><p>对比break和countnue</p>
<pre><code>break是结束整个循环体，continue是结束单次循环

示例
    #!/usr/local/env python3
    &apos;&apos;&apos;
    @swht
    &apos;&apos;&apos;
    x = 0
    while x &lt; 10:
        if x ==3:
            break
        x += 1
        print(&quot;x=%s&quot; % x)
    输出结果：    x=1
                x=2
                x=3
    直接退出了整个while循环
</code></pre><p>七、格式化输出</p>
<pre><code>使用&apos;&apos;&apos;string&apos;&apos;&apos;可以很方便的将多行内容进行注释，另外这个符号还有一个功能，那就是文档描述的功能。一般而言，在程序的前面后有一个文档说明，包括作者信息，版本信息，功能等

#!/usr/bin/env python
&apos;&apos;&apos;
@swht
&apos;&apos;&apos;

name = input(&quot;name:&quot;)
age = input(&quot;age:&quot;)
job = input(&quot;job:&quot;)

print(&quot;Information of:&quot; + name + &quot;\nname:&quot; + name + &quot;\nage:&quot; + age + &quot;\njob:&quot; + job)
print(&quot;Information of %s\nname:%s\nage:%s\njob:%s&quot; %(name,name,age,job))
print(&apos;&apos;&apos;
    Infomation of %s
             name:%s
              age:%s
              job:%s
    &apos;&apos;&apos; % (name,name,age,job))
</code></pre><p>八、数据类型：</p>
<p><em>列表转换成元组：tuple(name_list)</em></p>
<p><em>元组转换成列表：list(元组_name)</em></p>
<pre><code>1.数字
    int     整型
    long     长整型
    float     浮点型
2.布尔
    1    真
    0    假
3.字符串
        stinglist = “Hello World”
    字符串操作：
        (参考：http://www.cnblogs.com/zhxiang/p/3385242.html
        http://www.jb51.net/article/47956.htm)
        移除空白：stinglist.strip()
        移除特殊字符：stinglist.lstrip().rstrip(&apos;,&apos;)
        分割：&gt;&gt;&gt; stringlist[2]
                 &apos;l&apos;
        长度：&gt;&gt;&gt; len(stringlist)
                 11
        索引：&gt;&gt;&gt; stringlist.index(&apos;W&apos;) #字母‘W’所在的索引值
                 6
        切片：&gt;&gt;&gt; stringlist[0:3] #顾前不顾尾
                 &apos;Hel&apos;
        字符串在输出时的对齐：
            &gt;&gt;&gt; stringlist[0:3]
            &apos;Hel&apos;
            &gt;&gt;&gt; stringlist[0:3].ljust(5) #ljust(width,[fillchar]) fillchar为填充字符，默认为空格
            &apos;Hel  &apos;
        字符串拼接：
            &gt;&gt;&gt; stringlist += s
            &gt;&gt;&gt; stringlist
            &apos;Hello Worldab,cde,fgh,ijk&apos;
        大小写转换：
            &gt;&gt;&gt;stringlist.lower() #小写
               &apos;hello world&apos;
            &gt;&gt;&gt; stringlist.upper() #大写
                &apos;HELLO WORLD&apos;
            &gt;&gt;&gt; stringlist.swapcase() #大小写互换
                &apos;hELLO wORLD&apos;
            &gt;&gt;&gt; stringlist.capitalize() #首字母大写
                &apos;Hello world&apos; 
            &gt;&gt;&gt; string.capwords(stringlist) #以空格分割，每个单词首字母大写
                &apos;Hello World&apos;
        字符串翻转：
            &gt;&gt;&gt; s
            &apos;sdsds sdsdsff&apos;
            &gt;&gt;&gt; s = s[::-1]
            &gt;&gt;&gt; s
            &apos;ffsdsds sdsds&apos;
        字符串查找：
            &gt;&gt;&gt; stringlist.find(&apos;World&apos;)
                6
        判断是否为整型：
            &gt;&gt;&gt; stringlist.isdigit()
                False
        判断字符串是否为空格：
            &gt;&gt;&gt; stringlist.isspace()
                False
        转换成列表：
            &gt;&gt;&gt; stringlist.split() #默认以空格为分割
                [&apos;Hello&apos;, &apos;World&apos;]

4.列表（dir(name_list)获取列表操作帮助）
    参考：http://www.jb51.net/article/46768.htm
    name_list = [&apos;alex&apos;, &apos;sddkd&apos;, &apos;shdjsjd&apos;, &apos;shen&apos;, &apos;swht&apos;, &apos;test&apos;]
    移除空白：name_list.strip()
    获取元素：name_list[index_num]
    索引：name_list.index(&quot;swht&quot;)  获取指定元素的索引值
    追加：name_list.append(&quot;test&quot;) 在列表后面追加一个元素
    插入：name_list.insert(3,&quot;ssdd&quot;) 在索引值3后面插入新的元素
    删除：name_list.pop() 删除最后一个元素
         name_list.remove(&quot;test&quot;) 删除指定的元素
    排序：name_list.sort()  对元素按照ASCII码进行排序
        python3 里面不能同时sort int 和 str类型
    反转顺序：name_list.reverse()  对列表中的元素进行反转操作
    切片：name_list[0:3]  切取索引值从0-2的值（切片顾头不顾尾）
    扩展：name_list.extend(name_list2) 在一个列表后面追加另一个列表的元素，或者追加一个变量中的单个字符
5.元组
    &gt;&gt;&gt; namelist = (&quot;swht&quot;,&quot;test&quot;)
    &gt;&gt;&gt; type(namelist)
        &lt;class &apos;tuple&apos;&gt;
    索引：&gt;&gt;&gt; namelist.index(&apos;swht&apos;) #查找某个字符串的索引值
             0
    统计：&gt;&gt;&gt; namelist.count(&apos;swht&apos;) #统计某个字符串出现的次数
             1
6.字典（无序）
    参考：http://www.jb51.net/article/47990.htm

    不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住
    键必须不可变，所以可以用数，字符串或元组充当，所以用列表就不行

    dict = {&quot;swht&quot;:&quot;test123&quot;,&quot;shen&quot;:&quot;test124&quot;,&quot;test&quot;:&quot;test125&quot;}
    访问字典里的值：
        &gt;&gt;&gt; dict[&quot;swht&quot;]
            &apos;test123&apos;
    增加字典里的值：
        &gt;&gt;&gt; dict[&quot;alex&quot;] = &quot;test126&quot;
        &gt;&gt;&gt; dict
        {&apos;test&apos;: &apos;test125&apos;, &apos;shen&apos;: &apos;test124&apos;, &apos;swht&apos;: &apos;test123&apos;, &apos;alex&apos;: &apos;test126&apos;}

    删除字典当中的元素：
        &gt;&gt;&gt; del dict[&quot;test&quot;]
        &gt;&gt;&gt; dict
        {&apos;shen&apos;: &apos;test124&apos;, &apos;swht&apos;: &apos;test123&apos;, &apos;alex&apos;: &apos;test126&apos;}
        &gt;&gt;&gt;                
    清空字典里的所有条目：
        &gt;&gt;&gt; dict.clear()
        &gt;&gt;&gt; dict
        {}
    删除字典：del dict
</code></pre><p>九、文件操作</p>
<pre><code>简单操作：
    filename = open(&quot;文件路径&quot;,&quot;模式&quot;)    #打开文件
    filename.write(&apos;内容&apos;)    #往文件中写入内容
    filename.read()        #一次性加载文件中的内容到内存
    filename.readlines()    #一次性加载所有的内容到内存，并根据行分割成字符串
    filename.close()    #关闭文件句柄
</code></pre><p>十、作业</p>
<pre><code>作业一：编写登录接口
</code></pre><p>，</p>
<pre><code>作业二：多级菜单    
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python开发之路/">Python开发之路</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016  <a href="https://github.com/swht" target="_blank" title="南非波波github主页">南非波波</a>
            </div>
            <div class="footer-right">
                <a href="http://www.cnblogs.com/songqingbo/" target="_blank" title="南非波波博客园主页">南非波波博客园主页</a>            
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >本站到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="/js/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>